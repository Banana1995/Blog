[{"title":"ArrayList源码解析","date":"2018-05-14T12:56:35.266Z","path":"2018/05/14/ArrayList源码分析/","text":"ArrayList源码##field 1234private static final int DEFAULT_CAPACITY = 10;//默认的数组容量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//初始化时加载一个空数组private transient Object[] elementData;//实际用来存储数据的数组private int size;//数组大小 构造器1234public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; 默认的无参构造器就是简单的将数组引用指向类定义的空数组对象。 123456789public ArrayList(Collection&lt;? extends E&gt; c) &#123; //将集合转换为存储数据的数组 elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) //若不是Object类型的数组，则将数组copy到Object类型的数组中去 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 方法 新增方法 12345678910111213 public void add(int index, E element) &#123; //确保index的位置没有超出数组的范围 rangeCheckForAdd(index);//保证数组的容量是否足以添加进去元素，并且将modCount的值自增1 ensureCapacityInternal(size + 1); // Increments modCount!! //将index位置后面的数据往后移1位 System.arraycopy(elementData, index, elementData, index + 1, size - index); //将元素放置在index位置上 elementData[index] = element; //数据长度+1 size++; &#125; fail-fast机制在遍历一个集合时，当集合结构被修改，会抛出Concurrent Modification Exception。 fail-fast会在以下两种情况下抛出ConcurrentModificationException （1）单线程环境 集合被创建后，在遍历它的过程中修改了结构。 但是迭代器的remove()方法会让expectModcount和modcount 相等，所以在遍历集合的过程中只能通过迭代器的remove()方法进行删除元素。 （2）多线程环境 当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; //将修改次数+1 modCount++; // overflow-conscious code //增加数组长度 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //新数组长度为原先数组长度的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //若新长度依旧小于minCapacity，则将minCapacity作为新长度 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //新长度大于MAX_ARRAY_SIZE，则将新长度置为最大的int值 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //将就数组copy到新数组上 // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); //MAX_ARRAY_SIZE的值为Integer.MAX_VALUE - 8 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; get方法 12345public E get(int index) &#123; //确保index的位置没有超出数组的范围 rangeCheck(index); return elementData(index);&#125; remove方法 1234567891011121314151617 public E remove(int index) &#123; //检查是否数组下标越界 rangeCheck(index);//修改次数+1 modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) //将index位置后面的数组往前移1位 System.arraycopy(elementData, index+1, elementData, index, numMoved); //将size的值-1，并将数组最后一位的数据引用置为null 让GC自动回收未被引用的对象 elementData[--size] = null; // clear to let GC do its work//将被移除的对象返回出去 return oldValue; &#125; 123456789101112131415161718public boolean remove(Object o) &#123; if (o == null) &#123; //若是空对象的话则遍历数组将其移除 for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; //不是空对象则遍历数组，通过equals方法判断对象是否相等，相等则将其移除 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 1234567891011private void fastRemove(int index) &#123; //修改次数+1 modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) //将index位置后面的数组往前移1位 System.arraycopy(elementData, index+1, elementData, index, numMoved); //将size的值-1，并将数组最后一位的数据引用置为null 让GC自动回收未被引用的对象 elementData[--size] = null; // clear to let GC do its work&#125; 12345678910public void clear() &#123; //修改次数+1 modCount++; //将所有的数组引用都置为null 让GC回收 // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; //数组大小置为0 size = 0;&#125; ​由上面源码可以看出，ArrayList的删除操作本质上都是将数组移位，末尾数组引用置为null，让GC自动回收垃圾对象。 迭代器123456789101112131415161718192021222324252627282930313233343536373839404142private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 先是一个Itr的类，实现了迭代器接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; 然后通过一个ListItr继承Itr类，并同时实现了ListIterator接口。 参考文章参考文章一","tags":[]},{"title":"HashMap源码解析","date":"2018-05-13T08:04:04.549Z","path":"2018/05/13/HashMap源码/","text":"HashMap源码1.构造器123456789101112131415161718/**构造器默认两个参数：initialCapacity 哈希表（键值对数组）初始化容量（默认为16,2的4次方 loadFactor 加载因子 （默认为0.75）*/public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; init(); &#125; 2.方法12345678910111213 void addEntry(int hash, K key, V value, int bucketIndex) &#123; //判断是否需要对原先的hash表扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; //对hash表扩容 并将旧hash表的内容放入新hash表中 resize(2 * table.length); //通过hash()方法来获取key的hash值 hash = (null != key) ? hash(key) : 0; //根据hash值重新获取Entry在数组中的index bucketIndex = indexFor(hash, table.length); &#125;//新增一个键值对 在hash表中的bucketIndex位置放入一个Entry createEntry(hash, key, value, bucketIndex); &#125; 12345678910111213void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; //将所有的旧hash表的键值对转换到新hash表上 transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; 123456public void clear() &#123; modCount++; //使用Arrays工具类，将hash表的数据都填充成null Arrays.fill(table, null); size = 0; &#125; 1234567891011121314151617 final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125;//获取key的hash值 int hash = (key == null) ? 0 : hash(key); //遍历在hash表中key的hash值所对应位置的链表 通过key.equasls方法来确定key所对应的键值对 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 1234567891011121314151617181920212223242526 public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; //给hash表扩容，若表为空，则按照初始化时的threshold值创建hash表。 //threshold=capacity * loadFactor //若不为空，则该方法扩容为原来hash表的2倍 inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); //若根据key的hash值计算出的hash表位置已经存在了键值对，则遍历该链表，将新的Entry添加到链表的最后 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125;//将hash表的修改次数+1 为了实现fast-fail机制 modCount++; addEntry(hash, key, value, i); return null; &#125; 1234567891011121314151617181920212223242526272829303132333435363738final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length); //指向链表当前对象前一个对象的引用 Entry&lt;K,V&gt; prev = table[i]; //指向链表当前对象的引用 Entry&lt;K,V&gt; e = prev; while (e != null) &#123; //遍历链表数据直至找到key对应的Entry //next为指向链表当前数据下一个对象的引用 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; //hash表修改次数+1 modCount++; //hash表的大小-1 size--; //此时当前一个链表前一个数据与当前数据为同一个对象，说明hash表当前位置不存在链表， //直接将key所对应hash表当前数据的next引用指向当前数据的下一个对象。（链表的删除思想） if (prev == e) table[i] = next; else //此时说明hash表当前位置存在链表，将前一个数据的next引用指向当前数据的下一个对象 prev.next = next; //这是Entry内部类定义的hook方法，每次删除数据都需要调用一次。 e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e;&#125; hook方法就是钩子方法 3. Entry类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//静态内部类 实现了Map类的内部接口 用于存储键值对static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; //复写equals方法 public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125; /** * This method is invoked whenever the value in an entry is * overwritten by an invocation of put(k,v) for a key k that's already * in the HashMap. */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; /** * This method is invoked whenever the entry is * removed from the table. */ void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; 4.迭代器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 //通过一个抽象内部类HashIterator实现了Iterator接口 //HashMap提供的key和value迭代器都是通过继承这个HashIterator实现的private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; Entry&lt;K,V&gt; next; // next entry to return int expectedModCount; // For fast-fail int index; // current slot Entry&lt;K,V&gt; current; // current entry HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if ((next = e.next) == null) &#123; Entry[] t = table; //当next为null时说明e是hash表当前index位置的链表的最后一个元素 //通过while语句内的方式实现next往后移位直至不为null的一个元素 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125; &#125; 123456789101112131415161718//value迭代器内部类private final class ValueIterator extends HashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125; &#125;//key迭代器内部类 private final class KeyIterator extends HashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125; &#125;//Entry迭代器内部类 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; 5.关于hash表的两个问题 如何设计才能使减小hash冲突？ 针对如何获取在hash表中的位置，HashMap中主要通过三个部分来减小散列冲突： 第一部分，首先根据Object.hashcode得到一个散列值，Object.hashCode是一个native方法。一般情况下可以认为是该对象的地址信息散列得到的，也就是相当于是对象的ID，同一个对象有相同的ID。这样得到的散列值还是比较合理的. 12345678910111213141516final int hash(Object k) &#123; int h = hashSeed; //对于String的hashCode需要另外计算 if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). //二次散列 h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 第二部分，桶的数量设计。一般由哈希值得到桶的位置都是将哈希值除以桶的数量得到的余数就是桶的位置。一般来说想要尽可能的减少散列冲突有两类办法，一类是使用素数数量的桶，例如hashTable，一类是使用2的幂次数量的桶，例如hashmap，hashmap使用2的次幂的桶有个好处，就是可以用位运算来算，只要将散列值和桶的数量-1相与就是桶的位置不需要除。这样相对来说速度快一些。hashmap里有个静态方法indexof就是用来做这个的。具体下文会说到。 1234567static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\"; //长度为2的幂次的hash表，用位运算来将散列值和桶的数量-1相与 就是数组的index,这样比采用除更快 //比如length是4，那如果h是0-3则返回的值就是0-3，如果是h=4则返回0，h=5则返回1 //length-1是因为数组下标从0开始 return h &amp; (length-1);&#125; 第三部分，hashseed，第二部分中曾经说道通过将哈希值与桶的数量-1相与得到桶的位置。但是这样做有一个小的问题。当哈希值非常大，而桶的数量很小的时候回出现仅仅依靠哈希值的低位来散列的结果。这样即使散列值做的很好耶没有办法得到很好的散列。这时hashseed的作用就体现出来的，hashseed通过右移部分哈希值，然后将其亦或得到的结果进行在进行定位桶的位置。这样做就综合考虑了高位和低位的值。从而减小了散列冲突的可能性。此外由于java的语言特性，对于String的情况其hashseed需要额外设计。 123456789101112131415161718192021222324252627282930313233private static class Holder &#123; /** * Table capacity above which to switch to use alternative hashing. */ static final int ALTERNATIVE_HASHING_THRESHOLD; static &#123; String altThreshold = java.security.AccessController.doPrivileged( new sun.security.action.GetPropertyAction( \"jdk.map.althashing.threshold\")); int threshold; try &#123; threshold = (null != altThreshold) ? Integer.parseInt(altThreshold) : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT; // disable alternative hashing if -1 if (threshold == -1) &#123; threshold = Integer.MAX_VALUE; &#125; if (threshold &lt; 0) &#123; throw new IllegalArgumentException(\"value must be positive integer.\"); &#125; &#125; catch(IllegalArgumentException failed) &#123; throw new Error(\"Illegal value for 'jdk.map.althashing.threshold'\", failed); &#125; ALTERNATIVE_HASHING_THRESHOLD = threshold; &#125; &#125; static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;但是这个静态类常量也是可以根据虚拟机参数的设定来更改的。这也就是Holder这个类这段静态代码的意义了。可以通过调整虚拟机的参数来设定这个域值。关于Holder类是参考别人的文章来的，说实话我也没有完全搞清楚。 在发生hash冲突时，如何解决？ 在发生hash冲突之后，HashMap采用单向链表方式来存储键值对。在前面介绍的getEntry、put等方法的时候，都有遍历链表。 关于final加上final的仅仅是相当于当前的引用不在改变，但是容器的元素是恶意增删的，元素的内容也是可以改变的。 参考链接参考文章一","tags":[]}]