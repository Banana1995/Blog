[{"title":"Java基本类型与类加载、方法调用","date":"2018-09-01T13:31:00.753Z","path":"2018/09/01/Java基本类型与类加载、方法调用/","text":"一、 Java代码的运行方式1. Java程序需要运行在虚拟机中Java虚拟机为java程序的运行提供了一个软件环境，这样做的好处是，可以使Java程序在不同的硬件平台上运行。Java程序被编译成为字节码文件后，只要在不同的平台上安装好Java虚拟机就可以运行了。 同时，Java虚拟机还为Java程序提供了一种托管环境，这个环境可以给Java程序提供一些很便捷的功能，如垃圾回收和自动内存管理等 2. Java虚拟机如何运行字节码JVM运行Java程序，首先需要将它的class文件加载至内存的方法区中。在运行时，会执行方法区内的代码。Java的对象存在堆内存中，在栈内存中又分为面向本地方法的本地方法栈和面向Java方法的Java方法栈，以及记录每个线程执行位置的PC寄存器，JVM会在当前线程的Java方法栈中生成一个栈帧。每次执行一个方法，相当于栈帧的进栈和出栈。 从硬件的角度来讲，机器是不能直接执行java字节码的。因此，jvm需要交java字节码翻译成机器码。在HotSpot里面，翻译成机器码的过程有两种方式，一种是解释执行，即逐条将字节码翻译成机器码。一种是即时编译（JIT），教一个方法中所有的字节码，全部编译成机器码之后再执行。解释执行的优势在于无需等待编译，而即时编译方式的优势在于，实际执行速度更快。 在HotSpot中，将需要多次执行的热点代码，使用即时编译的方式执行。将执行次数小于15次定义为非热点代码，这一部分代码是通过解释执行的方式执行。 二、基本类型在JVM中，变量存储的数据是可以超出它定义的范围的。boolean类型的数据在JVM中被翻译为1和0，但是我们可以通过修改字节码的方式，将2存储为boolean数据。 值域小的数据类型向值域大的类型转换时，是不需要进行数据强转的。 基本类型的包装类型之间是无法进行强制转换。 java中的正无穷和负无穷，都是有明确的数值的。在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000。超出了正无穷和负无穷之间的其他数字对应的浮点数是NaN。 NaN和任何一个浮点数（不管是0还是NaN）比较时，除了!=返回true以外，其他均返回false。 1.存储在java的方法栈帧中分为局部变量区和字节码的操作数栈。局部变量就相当于一个数组，除了long和double占两个数组单元以外，其他基本数据类型都只占用一个数组单元（32位是4个字节，64位是8个字节），也就是说，其他数据类型都和int型一样，在栈帧中占4个字节（64位的HotSpot占8个字节）。注意：这里是指在栈里面，而在堆中的字段或数据里面byte、char、short分别占有一个字节，两个字节，两个字节。 也就是说跟它们的值域是相吻合的。 一个int型的数据存储进字段或数组中时，是会进行隐式的的掩码操作。举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位字节会被截掉。同样，对于boolean类型来说，在存储时会显示的进行掩码操作，只取最后一位存入字段或数组中。 2.加载我们需要将堆中全部数据加载到栈中计算，也就是说我们需要将boolean、byte、char、short加载到操作数栈中，而后将栈中的数值当成int型来计算。对于char和byte来说，无符号型数据加载伴随着0扩展。char占有两字节，会被复制到栈中的低两字节，高两字节则用0补充。 同理，对于有符号类型的数据加载则进行符号扩展，高两字节用符号位填充。 三、类加载类的加载过程主要是三大步骤。分别为加载、链接和初始化。 1. 加载加载的过程就是查找字节流，并且创建这个类。加载需要借助类加载器。在JVM中，类加载器使用双亲委派模式，收到一个类加载请求之后，需要先转派给父类加载器，父类加载器没有找到所请求的类的情况下，子类加载器才会尝试去加载。 最基础的类加载器是启动类加载器（boot classLoader），它是由C++实现的，没有对应的Java对象，因此只能用null来代表它。除了启动类加载器以外，其他的类加载器都是java.lang.ClassLoader的子类，这些类加载器都需要启动类加载器加载进JVM中才能使用。 除了启动类加载器以外，还有一些较为重要的加载器如扩展类加载器和应用类加载器。扩展类加载器的父类是启动类加载器，应用类加载器的父类是扩展类加载器。 默认情况下，应用程序中的类是由应用类加载器加载的。我们可以自己实现类加载器来完成自定义的一些功能，如class文件的加密解密等。 JVM中，类的唯一性是由类加载器实例以及类的全名一同确认的。所以同一段字节码，被两个类加载器加载之后也会得到两个不同的类。 相当于造房子的时候，找到一个老师傅来在一个地址上开始创建过程。 2. 链接链接又分为验证，准备和解析三个阶段。 验证是为了确保被加载的类能够符合JVM的约束条件。相当于上报监管部门审批造房。 准备是为了给被加载类的静态字段分配内存。相当于盖好了毛坯房。 解析是为了将被加载类的类成员、字段等符号引用解析成实际引用。如果符号引用指向的是一个未被加载的类，那么解析会出发那个类的加载，但不一定出发类的链接和初始化。这里的符号引用是指，编译器在编译的时候将被引用的字段、类、方法生成一个符号引用来代替它本身。而将符号引用解析未实际引用就是将在字节码中的符号引用替换位在JVM中的实际内存地址。 如果将这段话放在盖房子的语境下，那么符号引用就好比，“张三的房子”这种说法。不管他存不存在，我们都可以用这种说法来指代张三的房子，实际应用则好比是实际的通讯地址，如果我们想要与张三通信，那么必须要将“张三的房子”变成实际的通讯地址。如果这个实际的通讯地址不存在，则需要启动张三的盖房子过程的第一步，即选择好师傅在一个地址上开始创建。 3. 初始化静态代码块中的代码和直接赋值操作被编译器放置在同一个方法中，叫做。 类的初始化便是为常量值字段赋值以及执行方法。 四、方法调用1. 重载、重写、动态绑定与静态绑定 不建议重载可变长参数的方法。因为这可能会导致java编译器无法确定应该调用哪个目标方法。 java编译器在编译的时候已经区分了重载，所以我们可以认为在jvm里面不存在重载这个概念。 jvm中的动态绑定指的是需要在运行过程中，根据调用者的动态类型来识别目标方法。而静态绑定指的是在解析时便能够直接识别目标方法的情况。 java字节码中调用相关的指令共有五种: invokestatic:用于调用静态方法。 invokespecial:用于调用私有实例方法，构造器，以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法。 invokevirtual:用于调用非私有实例方法。 invokeinterface:用于调用接口方法。 invokedynamic:用于调用动态方法。 对于invokevirtual 和invokedynamic 虚拟机需要在执行过程中，根据调用的动态类型来确定具体的目标方法。也就是说这两个编译指令，需要使用动态绑定。 对于静态绑定而已，符号引用被解析成实际引用时，这个实际引用是一个指向方法的指针。对于动态绑定而言，实际引用则是一个方法表的索引。 2. 动态绑定在JVM中，静态绑定包括用于调用静态方法的invokestatic指令和用于调用构造器，私有实例方法以及父类非私有实例方法的invokespecial 指令。如果虚方法调用指向一个标记为final的方法，那么JVM也可以静态绑定该虚方法调用的目标方法。 方法表 在类加载的时候，除了为静态字段分配内存以外，还会构造与该类相关的方法表。 方法表的本质是一个数组，每个数组元素指向一个当前类以及其父类中非私有实例方法。对于动态绑定而言，实际引用则是方法表的索引值。 在执行过程中，JVM将获取调用者的实际类型，并在实际类型的虚方法表中，根据索引值获得目标方法，这个过程便是动态绑定。 内联缓存 内联缓存，本质上是一种加快动态绑定的技术。它能够缓存虚方法的调用者动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果已经到缓存过的类型，内联缓存便会直接调用该类型所对应的目标方法。","tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"见识","date":"2018-08-12T11:13:40.000Z","path":"2018/08/12/见识/","text":"《见识》这本书是偶然从一个公众号的文章推送里面得知的。后来得知是吴军写的便直接买回来看看。写这篇文章是为了记录下读了这本书之后所收获到的几点。 从整体上来说，这本书阐述了吴军老师对人生、对职业、对投资的思考和建议。 一、关于人生从这个角度来说，我喜欢这本书的第一章标题，叫做幸福是目的，成功是手段。这章里面作者说，一个人需要相信自己的命运。而关于命，每个人是有不同的理解。 命运取决于两个因素，一个是环境因素，是由我们的出身和环境来决定的。而另一个是我们自己对未来走向的规划，这一点是我们自己努力博弈出来的。所谓的命，我们能掌握的就是一个人看问题和做事情的方法，仅此而已，但是他们决定了一个人的一生。 一个人的出生、生活环境和他受到的教育都会对他整个人生的命运产生非常大的影响。而我们常说”命运是掌握在自己的手里“指的是我们可以规划自己的未来方向，通过自己的努力获得想要的人生。对于一个普通人来说，想要逆袭是非常难，非常难的一件事情。作者在书中举了个例子说你可能需要花半辈子时间，来弥补自己的不足。然后再花半辈子的时间来追赶别人。因为别人的先天条件比你好的话，那么可能他只要付出三分的努力，就可以达到你付出十分努力所带来的效果。因此你必须要花很长的时间来弥补自己的不足，然后再努力的去追赶人家的脚步。 1.对男生女生的建议人生最重要的投资其实是投资自己。对男生来说，选择好一个配偶十分重要。一个女生，她所表现出来的气质涵养，实际上跟她的家庭有很大的关系。选择一个聪明的跟你价值观完全相符合的女生，这对于你自己人生的未来会大有裨益。同时，男生需要有足够的独立性，承担自己未来对家庭的义务。在一段婚姻中，双方都需要明白关系的亲密程度和重要性依次是“夫妻优先于子女，更优先于双方的父母。” 有很多人觉得结婚是两个家庭的事情。然而在这本书里面，作者说，婚姻它并不一定是两个家庭的事情，而是两个人要分得清楚大家和小家。两个人在婚姻中需要分清大家和小家之间的边界。 一个人，特别是年轻的时候，可塑性非常重要。两个人在一起时间一长，肯定会遇到矛盾，能够有一些柔韧，彼此妥协的解决问题，相互适应，才能更好、更长远的走下去。 对于女生来说，需要分清楚婚姻与恋爱的不同。恋爱是激情，是化学物质分泌所带来的愉悦；而婚姻则是两个人共同构造一个舒适体。在这个舒适体中，双方都会受益，彼此成长。不要总觉得老实的男人才能靠的住，或者找一个自己可以控制的人。因为你会发现很多身边看似老实的男人，会做出一些让你们大跌眼镜的事情。其实这些东西它本质上并没有什么意外的，因为人性就摆在那里。女生应该靠自己的能力去辨别一个，对自己好的男生。而对自己好，不应该靠男生怎么说来评判，要去发现他是怎么做。需要判断这个人的价值观和爱情观是否与自己相符，是否认可夫妻间的关系的重要性高于其他关系的重要性。只要仔细观察就可以发现他对你们之间关系的在乎程度。 当然，一个男生最终能否对你好，还要看他有没有这个能力。因为大部分男生都会描绘一个美好的未来，但是很多人根本无力去实现它。 2.做人和作诗最近我在办公室中，跟一些同事玩得越来越熟。有些同事会说我是一个很会说话的人。当我听到他们这样评价我的时候，其实我的内心对自己多少是有点失望的。因为我知道自己不是个情商很高的人，我只是会偶尔抖个机灵，然后不向别人吝啬我的赞美。可能这些东西在别人的眼中，会有拍马屁的倾向。在这本书里面，作者把这些东西称之为会做人。在这个社会中并不缺会做人的人，但是缺会做诗的人。 这里的作诗指的是，他们有一种理想主义式的叛逆精神。在我的理解里，这大概是一种纯粹的理想主义。有一些了解我的朋友，可能因为觉得我喜欢老罗而认为我是个很理想主义的人。但是我其实更倾向于把自己归结为是一个现实理想主义者。我非常的认同和赞美理想主义精，但是我觉得脱离了现实的理想主义行为，是一种非常不理智的，甚至会给自己和家人带来生活上的窘境的行为。当然我更不喜欢那些把自己利益看得很重的精致利己主义者。我喜欢的是像鲁迅那样，一边拿着国民政府的钱，一边去骂国民政府。大概我的信条是应该在很多事情上有着理想主义的原则，但是不能脱离现实而活着。守住自己的底线，照顾好自己的家人，而不是用一种很幼稚的理想主义行为去跟这个丑恶世界进行搏斗。 3.非线性增长这本书的第四章叫做大家智慧。作者写了一些名人的故事，他告诉我们，做事情要认清成本并且看透本质。关于看透本质这件事情，我有另外个理解，叫做非线性增长。这是我从投资理念中学来的，不管是人生还是投资，在很多的时候都不是一个线性增长的过程。它是一个缓慢的由量变累积产生质变的非线性增长过程。它需要前期不断的进行投入累积，达到了临界点之后，发生一个突变带来很多的回报。所以我们需要看透这个增长过程的本质是非线性的，并不是投入多少就会得到多少回报。而是需要找到那个临界点，不断的积累，之后就会产生质变获得很大的收益。 就拿工作这件事情来说，工资的增长并不是线性的，它是一个人内在价值的外在定价。所以说，作者给毕业生的建议是，在工作的前三年不要太去关注工资多少，而需要关注的是自己内在价值的提升。你自己的内在价值才是工资的本质。等过了几年工作上有了很好的工作经验的累积和技能的提升。这些内在价值的积累产生质变就会体现在你的工资的大幅增长上，会很容易的翻倍增长。这一点跟延迟满足感也是同样的道理。就是说我们需要放弃前期短暂的满足感，而不断的积累，坚持到未来产生更大的收益。 3.做好最后的1%在做事情的时候，需要做好最后的1%。因为其实很多时候人与人之间的能力差距并没有那么大，但是正是这最后的1%却会拉开很大的差距。这一点是我需要始终铭记的，我在很多方面的最后1%都做的不够好。 二、关于职业1. 职业误区在职业方面，作者给我最大的启发是：不要走入一个工作和职业分不清的误区。 工作是谋生的手段，你去单位上班然后单位给了你一份工资就两清了。然而，职业却是需要从事一辈子的事情。为了这个一辈子的发展，应该选择性的做一些对职业有利的事情，不论是否有报酬或者报酬的高低。 对待自己的职业需要专业的工作态度。所谓的专业，就是一切以工作目标达成为中心，所有的会议、沟通都是以此为核心。不管在任何情况下，能够把事情做好才能够体现出你的职业素质。成为一个专业人士，也是我入职以后，邹总在给我们的新人培训中所提出的一点希望。希望我们能够专业人士的态度，把属于自己的每件事情做好，而不去考虑当前的一些短暂利益。 另外一个启发是：不要把自己当成一个单位的过客，而是将自己当成主人。对比我之前在恒生的工作经验来说，我其实从一开始入职恒生的时候，就想把恒生作为一个不错的跳板。其实这样的想法对我来说是非常不利的。在整个工作过程中，我并没有去做一个专业人士应该做的事情。所以我希望在以后我所经历的每一家公司，都有一种主人翁的意识。不仅仅需要把这当成是一份工作，而是当成我的职业来做。成为一个专业的人士，对我来说很重要。 为了避免陷入这些误区，作者给我们提出了几个解决办法： 第一，任何时候都要为人谦卑，只有谦卑才能更有效的沟通。 第二，要用正确的方法对待语言暴力和其他故意伤害。 第三，永远要明确工作不是为了公司或者他人，而是为了自己的职业发展这个既定的大方向。想要成为领导者，要平实的学习做一个领导。走出自己的一亩三分地，主动的多做事情，多跟人打交道，去帮助他人，支持自己的老板和团队。 第四，注重长期效益，把一件事情放到2到3年的时间周期来看，这时候我们对它的态度就会完全的不同。永远在一家公司不要有过客心态，要抱着学本事的心态去专心的干事情。 第五，作为一个基层员工，需要有大局观。你不仅需要看到你工作中所专注的一些细节，你需要看到整个项目，整个团队是如何运行的。 2. 伪工作者作为一个程序员，我自然的想要在工作的时候追求效率减少加班。在这本书中，作者提出了我们要拒绝做一个伪工作者。 我们首先需要确定，愿景-目标-道路。愿景就是说我们要确定一个明确的方向，然后在这个明确的方向上，我们需要设置一些阶段性的目标，战略的核心就是达到这些既定的目标，进而实现我们的愿景。 第二点是，即使听到了不中听的话也一定要虚心找出其中的合理之处。每次遇到别人和自己意见相左时，一定要开启寻找对方合理性的开关，这样会对你自己有很大的提升。 第三点时，凡事要做记录。做记录的过程其实是，有思考了一遍，这样会使得你进步更快。 同时作者还分享了自己谷歌目标工作管理方法。将自己的年度目标，列成一个表格。然后再制作一个消耗跟踪曲线来跟踪自己的目标完成情况。 三、关于投资1.金钱观这本书的最后一部分作者关于投资的一些看法。每个人都需要有一个正确的金钱观和理性的投资观。首先是金钱观，在现实生活中，要有那种没有钱是万万不能的思想。如果太过理想的去抛弃了很多东西的话，只会让你的生活变得很糟糕，并且没有能力照顾你的家人。鲁迅先生自己曾讲，饭碗可以跟理想分开。每个人都需要在这个现实的世界中很好的生活下去，所以你需要努力的保住你的饭碗。这一点是非常重要的。 另外一点是：钱只有花出去了，才是你的。在很多时候，我们不应该吝啬自己。就我自己来说，凡是我觉得会提高自己生活品质的东西就肯定会买。但是我会根据自己的收入，来分配投资和消费的比例。因为有些东西，它并不是很紧急的。比如我最近一直想买的键盘和音箱，但是我这个月已经买了手机，而这些东西又不是非常紧急。所以，我可以把剩下的钱部分用作生活费，另一部分用作投资理财。等下个月的工资发下来之后，再去买键盘和音响。 2.投资观再来说说投资观。因为我的工作跟金融有关，同时我也很爱钱。所以很自然的对投资理财感兴趣。之前我读过一本书，它说你在投资的时候，首先需要确定的一点就是风险意识。我一开始并不知道怎么看待这个风险意识。但是关注了这个行业一段时间之后，就发现那些很著名的理财投资人，他们都会给自己和自己的家庭买上各种各样的保险。其实保险它的本质上就是转移你的生活风险。大家都知道，在现实生活中，一场疾病很可能会把一个家庭的财务状况给带入低估。但是如果我们提前配置了保险的话可能情况就会好很多，这就是风险意识的一种体现。 其实不仅是理财，在生活中的任何事情都有风险，如果我们提前有了风险意识，并且对可能发生的这些风险的情况，作出应对策略的话，那么我们就可以很好的应对生活中的那些未知情况。 这本书里作者提出的投资些思想和投资观点，跟我以前对于投资的认识是很相似的，比如专业人士并不一定会比我们自己投资做的好。 对于投资来说，最好的投资品种还是权益类产品。这里的权益类产品指的是债券、股票、指数基金等。从历史数据来看，不论是哪个国家，投资股市都是回报率最高的一种方式。而单个股票的投资风险是很高的，因为它存在于价值归零的可能。但是如果你投资指数基金的话，情况就完全不一样。你只要在指数低估的区间买入，然后长期持有或者定期投入的话，就可以获得一个相对不错的收益。所以对于普通的上班族来说，努力工作扩大每月的现金流，然后将每月的闲钱去投资到指数基金中，会给我们带来相对不错的受益。同时我们需要有足够的风险意识，给自己配置上保险来应对可能发生的亏损情况。","tags":[{"name":"吴军","slug":"吴军","permalink":"http://yoursite.com/tags/吴军/"}]},{"title":"自私的基因","date":"2018-07-30T15:13:40.000Z","path":"2018/07/30/自私的基因/","text":"这本书开始的时候，作者提出了达尔文进化论的物竞天择，适者生存中的“适者”到底是什么？是种群，个体，还是物种？都不是，在作者看来，基因是自然选择的单位。而所有的动物，植物，个体，都是基因控制的生存机器而已。基因的目的只有一个，那就是复制自己。所以，从这个角度出发，就有了这本书的名称——自私的基因。 基因的目的是为了让自己复制下去。所以他们选择了各种各样的策略，让自己尽可能的复制下去。那些会控制蛋白质给自己制造生存机器的基因则更大概率能在自然选择的情况下生存下去。所以自然选择使得制造生存机器的基因可以不断地复制，生存下来。于是，基因通过控制蛋白质合成的方式，来控制着生存机器。而基因无法知道，动物会在生存过程中遇到什么样的情况。所以它们会给这些动物，预先制定好策略。比如它们不知道北极熊出生后，会面临哪些遭遇。但是基因会给北极熊准备好厚厚的毛发，来帮助他们御寒。这就是基因的预测行为，它其实就像程序员写的代码一样。只是指定了固定模式下的蛋白质合成方式，而不去关心实际代码所处理的数据。 作者在这本书中又提到了进化稳定性策略（ESS），这种策略是一种自然选择上稳定性的策略，一旦一种稳定性策略确立起来之后，任何偏离这种策略的行为都会受到自然选择的惩罚。而这种策略的稳定性，并不在于它有利于这个群体中的个体，而是因为它的内部没有背叛行为。一个生物种群理论上可以达到多种稳定性策略，但是最终会以一种稳定性策略方式生存下去，这将取决于他们优先达到了哪一种稳定性策略。从基因的角度来说，基因库是由一组进化上稳定的基因形成的，这组基因成为一个不受任何新基因侵犯的基因库。而大部分因为基因突变、重新组合而产生的新基因，将会偏离这种稳定性策略，必然会受到自然选择的惩罚。但是新基因侵入一组稳定性基因库，偶尔也会获得成功。一旦成功，就会立马在基因库中散布开来，最终形成一组新的稳定性策略。按照这种进犯策略类推，一个种群可以从一个稳定性进化策略跳向另外一个稳定性进化策略。这就是进化的过程。 把个体动物视为独立的生存机器，便于理解进犯行为。但是如果有关个体是近亲的话，这一模式也许会失去效用，因为近亲体内存在着很大一部分共同的基因，而每一个基因同时需要忠于不同的个体。从基因的角度，也可以解释我们的近亲利他主义。如果一个个体为了拯救十个近亲而牺牲，操作个体对亲属表现利他行为的基因，就有可能因此失去一个拷贝，但同时，一个基因的大量拷贝却得以保存。从这个角度来说，父母之爱和兄弟姐妹的利他行为的形成，都可以用完全相同的原因来解释，在收益者体内存在这个利他性基因的可能性更大。 同时从自私的基因角度来看，很多生物界的动物会选择自发的计划生育。而他们这种行为的目的，其实是为了让自己后代的成活率更高，以保证自己的基因可以复制延续下去。 在父母与子女之间也存在着欺骗和自私行为，而这种行为正是自私基因的延伸。幼儿欺骗父母，为了获取更多的食物和理想的生存条件，是为了使基因可以复制下去。而父母防止幼儿欺骗，是为了使自己的基因，可以更好的复制到下一代身上去。因为父母能够能够给的资源是有限，而他们为了使自己的基因可以复制下去，必须选择性的将更多的资源给活下去可能性更大的子女。这些只是从基因的角度来说，不牵涉到任何有意识的行为。 如果说我们从中有什么可以借鉴的话，那么就是我们必须把利他主义的美德，灌输到我们子女的头脑中去，因为我们不能指望他们的本性中有利他主义的成分。 在自然界中，雌性的卵子比较珍贵，而雄性的精子相对廉价。所以雌雄两性为了使自己的基因有更大的可能性复制下去，他们分别进化出不同的策略来对抗对方。在书中，作者提到雌性可以选择大丈夫策略或者家庭幸福策略来选择自己的配偶。而雄性则会有不同的策略来对抗。 作者在书中还提出了一种新的复制基因。叫做meme(觅母)。作者认为，文化的传播和遗传相类似，即它能导致某种形式的进化。遗传的进化能以存在于一种稳定状态，向另一种稳定状态转变而取得进展。而觅母，从广义上说可以称为模仿过程，从一个大脑转向另一个大脑的过程。以这样的方式在觅母库中进行繁殖。觅母和基因一样，也是自私的。 然而，即使我们着眼于阴暗面，假定人基本上是自私的。我们自觉的预见能力，能够防止自己纵容盲目的复制基因，干出那些最坏的、过分的自私行为。在必要时，我们也可以抗拒那些灌输到我们头脑里的自私觅母，我们甚至可以讨论如何审慎的培植纯粹的，无私的利他主义，这种利他主义在自然界里是没有立足之地的。在整个世界历史上也是前所未有的，我们是作为基因机器而被建造的，是作为觅母机器而被培养的，但我们具备足够的力量去反对我们的缔造者，在这个世界上只有我们，我们人类，能够反抗自私的复制基因的暴政。 关于自然界中的互惠利他行为，作者也通过自私基因的角度来给出了解释。这里作者提出了，一个经典的，博弈论概念。叫做囚徒困境。在简单的囚徒困境中。无论怎么算，最好的策略是永远背叛，因为这是个零和博弈。然而所幸，在自然界中，我们并不是处于简单的囚徒困境中，而是充满了囚徒困境的重复博弈，这是一个非零和博弈。在有记忆的生物中，对于这种囚徒困境的重复博弈，我们最好的策略是：合作与互助 。也就是说，好人终有好报。 一想到人一生下来就有太多的东西是受基因控制的，就不免感到有点悲哀。我们的一切行为，所有的本能和心理因素都受着基因的影响，不过所幸，我们是可以反抗的。","tags":[{"name":"理查德道金斯","slug":"理查德道金斯","permalink":"http://yoursite.com/tags/理查德道金斯/"}]},{"title":"深入理解泛型","date":"2018-06-27T11:40:59.000Z","path":"2018/06/27/深入理解泛型/","text":"类型擦除Java的泛型本质是参数化类型，就是将数据类型做为一个参数，在使用的时候再指定它的具体类型。但是因为Java使用了类型擦除，所以这个参数只存在于编译期，在运行期JVM是并不知道泛型的存在。 上图运行结果可以看出，在JVM运行时将new ArrayList&lt;String&gt;()与new ArrayList&lt;Integer&gt;()看作是同一个class类。 泛型参数会擦除到它的第一个边界。如果没有边界，则默认擦除到Object类。 无论我们如何定义一个泛型类型，相应的都会有一个原始类型被自动提供。原始类型的名字就是擦除类型参数的泛型类型的名字。 如果泛型类型的类型变量没有限定() ，那么我们就用Object作为原始类型；如果有限定()，我们就XClass作为原始类型；如果有多个限定()，我们就用第一个边界的类型变量XClass1类作为原始类型； 类型擦除带来的麻烦###1. 泛型数组 Java中不允许直接以这种方式创建泛型数组List&lt;String&gt;[] c = new List&lt;String&gt;[3] 。如果Java允许创建泛型数组则会产生一个下面的问题： 1234567List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed. 实际上是不允许的Object o = lsa; //强转为Object类型Object[] oa = (Object[]) o; //强转为Object[]数组List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check 通过了存储校验 String s = lsa[1].get(0); // Run-time error: ClassCastException. 产生类型强转异常 上面代码的最后一句会产生运行时异常。这是因为JVM进行类型擦除之后是不知道泛型信息的，而数组是有协变效应的。所以支持将不同数据类型的数据放入到Object[]类型的数组中，所以就会导致取出数据的时候产生ClassCastException。 在取出数据的时候，泛型可以使得编译期上述最后一行代码不需要进行类型强转也可以通过编译器的检查（这是泛型设计的作用之一），但是在实际运行过程中又产生了ClassCastException 异常，这违背了泛型的设计原则（在编译期不出现 未经检查的转换 ，运行期就不会报出类型转换异常）。 Java允许创建无边界通配符类型的数组，如下： 12345678List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type. Object o = lsa;Object[] oa = (Object[]) o;List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();li.add(new Integer(3));oa[1] = li; // Correct. oa[2] = \"123\";//Object[]数组可以存储任意类型的对象数据String s = (String) lsa[1].get(0); // Run time error, but cast is explicit. 上述代码的最后一行也会产生运行期类型强转异常，但是使用类型通配符数组，在取出元素类型时，则需要显式的强转数据类型。这一点使得 协变：A是B的父类，并且A的容器也是B的容器的父类，则称之为协变。 泛型是不支持协变的，但是支持“伪协变”，意思是指泛型本身不支持协变，但是可以通过设置上下边界来实现类似协变的特性。 2.泛型的多态我们先来看一个泛型父类： 12345678910111213141516public class Fruit&lt;T&gt; &#123; private T fruit; public Fruit(T fruit) &#123; this.fruit = fruit; &#125; protected T getFruit()&#123; return this.fruit; &#125; protected void setFruit(T f)&#123; this.fruit=f; &#125;&#125; 如果一个子类试图重写父类的getFruit方法的话，则有如下代码： 123456789public class Apple extends Fruit&lt;String&gt; &#123; private String name; @Override protected void setFruit(String f) &#123; this.name = f; &#125;&#125; 上面子类的protected void setFruit(String f) 方法试图覆盖父类的同名方法，但是实际上由于泛型擦除的原因 父类擦除后的set方法变成了protected void setFruit(Object f) 。此时，子类重写的方法与父类方法中的参数类型已不相同。因此，这样无法达到重写父类方法的目的。 在实际的重写中，编译器为我们解决了这个麻烦： 1234/*编译器在子类中自动生成了一个桥方法，由这个桥方法重写了父类的方法，再调用我们重写的子类方法*/protected void setFruit(Object f)&#123; setFruit（（String）f）；&#125; 如此一来，相当于在子类自动生成了个代理方法来解决了泛型由类型擦除带来的多态问题 如果在子类中我们再试图复写父类的get 方法的话,则会产生一个与我们自己定义的get 方法签名相同但是返回参数不同的桥方法： 12345678/*我们在子类中自己定义的重写方法*/protected String getFruit() &#123; return this.name;&#125;/*编译器自动生成的桥方法*/protected Object getFruit() &#123; return getFruit();&#125; 事实上，这个桥方法在编译器中存在是合法的。且看下面的几个知识点： 方法签名 确实只有方法名+参数列表 。这毫无疑问！ 我们绝对不能编写出方法签名一样的多个方法 。如果这样写程序，编译器是不会放过的。这也毫无疑问！ 最重要的一点是：JVM会用参数类型和返回类型来确定一个方法。 一旦编译器通过某种方式自己编译出方法签名一样的两个方法(只能编译器自己来创造这种奇迹，我们程序员却不能人为的编写这种代码)。JVM还是能够分清楚这些方法的，前提是需要返回类型不一样。 3.泛型中方法的冲突如果我们在一个泛型类中定义了一个如下所示的equals 方法，则编译器会不让通过： 1234// 编译不通过public boolean equals(T obj) &#123; return super.equals(obj);&#125; 则会有如下错误： 【Error】 Name clash: The method equals(T) of type Pair has the same erasure as equals(Object) of type Object but does not override it。 其中原因正是由于泛型的类型擦除，导致我们编写的equals 方法变成了public boolean equals(Object obj) 。此方法签名与Object 类中的equals方法签名相同。这就变成了覆盖父类的方法，然而我们的本意并不是想覆盖父类的方法。因此，如果这里编译器不报出错误的话，会给程序猿隐形中带来一个大坑。 4.创建泛型实例通过new 关键字创建泛型是不可行的，一是由于泛型擦除，二是由于编译器不知道T是否有默认的构造器。可以通过以下几种方法来创建泛型的实例： 1. 传递一个工厂对象，并且通过它来创建实例12345678910111213141516171819202122232425262728interface FactoryI&lt;T&gt; &#123; T create();&#125;class Foo2&lt;T&gt; &#123; private T x; public &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory) &#123; x = factory.create(); &#125; // ...&#125;class IntegerFactory implements FactoryI&lt;Integer&gt; &#123; public Integer create() &#123; return new Integer(0); &#125;&#125;class Widget &#123; public static class Factory implements FactoryI&lt;Widget&gt; &#123; public Widget create() &#123; return new Widget(); &#125; &#125;&#125;public class FactoryConstraint &#123; public static void main(String[] args) &#123; new Foo2&lt;Integer&gt;(new IntegerFactory()); new Foo2&lt;Widget&gt;(new Widget.Factory()); &#125;&#125; 创建一个创建实例的工厂对象，在泛型类中使用工厂对象来创建泛型实例。然后每个实例的具体类型自己实现工厂方法的接口，创建自己的实例即工厂对象，作为构造器入参传递给泛型类的构造器。 2. 利用模板设计模式123456789101112131415161718abstract class GenericWithCreate&lt;T&gt; &#123; final T element; GenericWithCreate() &#123; element = create(); &#125; abstract T create();&#125;class X &#123;&#125;class Creator extends GenericWithCreate&lt;X&gt; &#123; X create() &#123; return new X(); &#125; void f() &#123; System.out.println(element.getClass().getSimpleName()); &#125;&#125;public class CreatorGeneric &#123; public static void main(String[] args) &#123; Creator c = new Creator(); c.f(); &#125;&#125; 将创建实例的工作放在钩子方法中，通过子类去实现它，以达到创建实例的目的。 3. 利用Class类的反射123public &lt;T&gt; T getObject(Class&lt;T&gt; t) throws Exception &#123; return t.newInstance();&#125; 5. 静态方法与泛型静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。 即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。 12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： \"StaticGenerator cannot be refrenced from static context\" */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 6. 泛型类与异常 泛型类不能继承Throwable类，所以泛型类的对象既不能捕获也不能抛出。 123public class Problem&lt;T&gt; extends Exception &#123; ... &#125; 假设上面是合法的，那么在catch的时候，我们就可以有如下的方式： 1234567try &#123; ...&#125; catch (Problem&lt;String&gt; e1) &#123; &#125; catch (Problem&lt;Integer&gt; e1) &#123; &#125; Problem类在编译后会擦除泛型信息，这就相当于上面同时catch住了两个相同的异常，这在Java语法中是不允许的。 不能在catch子句中使用泛型变量，如： 1234567public static &lt;T extends Throwable&gt; void doSomething(Class&lt;T&gt; t)&#123; try &#123; ... &#125; catch (T e) &#123; //编译错误 ... &#125;&#125; 假设上面合法，那么下面的情况就会导致catch顺序不符合Java语法： 123456789public static &lt;T extends Throwable&gt; void doSomething(Class&lt;T&gt; t)&#123; try &#123; ... &#125; catch(T e) &#123; //此处泛型擦除后变成了 catch（Throwable e） ... &#125; catch(IndexOutOfBounds e) &#123; ... &#125; &#125; ？与T的区别 如果类型参数在方法声明中只出现一次，可以用通配符代替它。 当一个泛型用来表达方法的两个参数之间的关系时，则需要应该使用T，如： 1234public static &lt;T&gt; T autoConvertType(T obj)&#123; return(T)obj;&#125; ?表示不确定的类型，T表示一个固定的类型，可以作为一个变量类型在方法体的函数中调用，如： 12345678public static void printColl(ArrayList&lt;T&gt; al)&#123; Iterator&lt;T&gt; it = al.iterator(); while(it.hasNext()) &#123; T t = it.next(); System.out.println(t.toString()); &#125; &#125; 为什么需要引入泛型 保证代码类型安全。 在编译期不出现 未经检查的转换 ，运行期就不会报出类型转换异常。 提高了代码可重用性 在《Java核心技术》中对泛型的定义是： “泛型” 意味着编写的代码可以被不同类型的对象所重用。 在泛型中，可以将不同数据类型作为参数来使用，这就可以使得不同数据类型公用同一套代码，自然提升了代码的可重用性。 泛型接口比较实用的使用场景就是用作策略模式的公共策略 作为策略模式的公共策略，会被很多类实现，同时需要支持传入不同的数据类型作为参数。 123456public interface Comparator &#123; public int compare(T lhs, T rhs); public boolean equals(Object object);&#125; 泛型接口定义基本的规则，作为引用传递给客户端，这样就可以在运行的时候传入不同的策略实现类。 消除强制类型转换 存储任意类型的数据在集合中，但是取出来的时候都是object类型，此时必须强转。使用了泛型之后，编译器会自动插入类型转换的代码。所见即所得，使用时直接得到目标类型。 为了创建容器类 根据《Java 编程思想》中的描述，泛型出现的动机在于： 有许多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。 在《effective java》中也建议使用List来代替Array，因为List可以保证编译期的类型安全，而Array不能。 何时产生未经检查的异常使用泛型类或泛型方法时，没有指定参数化类型的具体数据类型是什么的时候，编译器会自动检查泛型的参数化类型，会报出未经检查的异常。 以上内容来自于对其他博客的整理和自己的思考,参考文章链接如下： 参考文章一 参考文章二 参考文章三 参考文章四 参考文章五","tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java基础/"}]},{"title":"辛德勒的名单","date":"2018-06-17T05:06:51.000Z","path":"2018/06/17/辛德勒的名单/","text":"Whoever saves one life, save the world entire 毕业的时候，因为马上就没有六维了。所以我离开学校之前，特意买了一块硬盘。从六维上下了很多电影资源放在里面。而辛德勒的名单就一直放在硬盘里面，你一直没有看它。直到最近，我决定把我看过的每一部影片，都写一篇博客记录下来，于是我开始翻起了我的硬盘，发现了这部电影。 没想到，影片居然是连姆尼森主演的。不得不说，年轻的连姆尼森真的很帅。 当最后柏林来的命令需要把所有的犹太人送到奥斯威辛集中营的时候。辛德勒在面临和老会计离别的时候，老会计终于肯跟辛德勒喝一杯酒。 辛德勒按人头算钱向军官买下了这些所有的工人，他要把他们都带回他的家乡，他要拯救快被灭族的犹太人。 海伦，一直在纳粹军官家做仆人，然而军官却爱上了她，但是她是一个犹太人。也正是这个原因，军官才一直没有杀了她。到后来，辛德勒试图把她带走的时候。军官居然想和他一起，白头偕老。但是在那个背景下，他们之间的爱情是不被允许的所以军官后来让辛德勒带走了她。 当德国宣布投降之后，辛德勒身为一个纳粹，不得不开始逃亡，在离别之前，所有的犹太人来打造了这枚戒指来送给他。这一段的表演太棒了，辛德勒哭的特别伤心，对自己没有拯救更多的人而愧疚。 当你挽救了一条生命，就等于挽救了全世界。 影片的最后介绍了，辛德勒救下来的犹太人的现状。后来辛德勒获得了耶路撒冷大屠杀纪念馆颁赠的正义勋章并受邀在当地的正义路种植了一棵小树，而那棵树一直到今天还存在。至今在波兰活着的犹太人还不到4000人。然而辛德勒犹太人的后裔已经超过6000人。在那样的时代下，当你身边全都是恶魔的时候，你很难不被同化成一个恶魔。在电影里有一幕是，当犹太人迁往隔离区时，孩子向那些犹太人扔泥土并且大喊着。看到这里，我心里十分震惊，在那个时代背景下连一个孩子都认为犹太人是最低等最下贱的种族。 但是，即便是在那样的时代下，也有像辛德勒这样伟大的人，有着自己独立的人格和思想。在这个肮脏的世界里维持着自己的良知，艰难的与那些恶魔对抗下去。 看完电影觉得自己非常幸运地生活在一个没有战争的国度，同时也没有宗教信仰主义。每次一想到这里都会觉得自己身处在一个如此安全的环境里真的应该感谢我们的祖国。 另一个感觉就是，即使在现如今的时代下，也有很多人是没有自己的良知的，就像电影里的纳粹一样，他们在干着吸人血的事情，比如往奶粉里掺三聚氰胺的。同时也有很多人是没有自己的思想和独立的人格的，就像电影里的小女孩一样，这类人很可悲，但这类人也很多，就像现在网上的那些键盘侠一样。然而真正能够改变这个世界的，是辛德勒这类人，他们怀揣着正义的理想，在这个肮脏的世界里摸爬滚打，不惜弄脏自己的双手也要坚持下去。大概这就是为什么老罗会说，未来是属于那些愿意弄脏自己双手的人的~","tags":[{"name":"史蒂文·斯皮尔伯格","slug":"史蒂文·斯皮尔伯格","permalink":"http://yoursite.com/tags/史蒂文·斯皮尔伯格/"}]},{"title":"星际穿越","date":"2018-06-10T12:20:29.000Z","path":"2018/06/10/星际穿越/","text":"诺兰大神14年的电影，上周末又拿出来再刷一遍，看得我好几次起鸡皮疙瘩，非常感动。看完觉得从另一个角度理解了时间，空间，虫洞，黑洞，同时诺兰又在电影里加上了人性和爱。 老物理学家说他害怕的是时间。是的，他已经解出了那个方程式，知道一切无望。只有B计划才是唯一能将人类种族繁衍下去的办法。他直到临终前都一直在说Do not go gentle into that good night 。诗里的night或许指的是地球上人类的灭亡，所以他即使已经算出了方程式，也希望可以找到一些方法拯救留在这个星球上的人类。所以他说自己害怕的是时间。在临终前，告诉了墨菲真相，他希望墨菲可以Do not go gentle into that good night,或许她可以拯救留在这个星球上的人类。 不要温和地走入那良夜 不要温和地走入那良夜，老年人应该燃烧并对着日暮呼喊；怒斥、怒斥那光明的微灭。 尽管聪明人临终时知道黑暗真确，是因为他们的话语没有迸射闪电，他们并不温和地走入那良夜。 好人，当最后一浪涌过，号呼他们脆弱的功业本可以很光辉地起舞于绿色的海湾，也怒斥、怒斥那光明的微灭。 狂放的人碰见并歌唱过太阳的飞越，意识到，太晚了，他们曾使它在途中哀叹，他们也并不温和地走入那良夜。 沉肃的人，临死时用目眩的视觉看到瞎眼也能像流星般闪耀而欣欢，也怒斥、怒斥那光明的微灭。 而您呀，我的父亲，身处高度的悲切，请用您的热泪诅咒、祝福我，我祈愿。不要温和地走入那良夜，怒斥、怒斥那光明的微灭。 上面是这首诗的一个翻译版本。这首诗原本是诗人写给临危的父亲的，诺兰将这首诗作为电影的主题，是写给临危的地球和人类的。Do not go gentle into that good night像是老教授对人类的呐喊，而库珀和墨菲则像是在rage against the dying of the light 最后，男主马修麦康纳和安妮海瑟薇的新片《宁静》最近曝光了预告片，期待一波~","tags":[{"name":"诺兰","slug":"诺兰","permalink":"http://yoursite.com/tags/诺兰/"}]},{"title":"Git以及TortoiseGit安装使用","date":"2018-06-10T12:02:12.000Z","path":"2018/06/10/Git使用手册/","text":"1. 下载安装Git-2.8.3-64-bit.exe程序 默认选项一直next即可。 本地初始化git的配置项，设置username和email，使用如下命令： 12git config --global user.name \"abc\"git config --global user.email \"123abc@163.com\" –global 表示全局属性，所有的git项目都会公用这个属性。因为Git是分布式版本控制系统，需要一个用户名和email作为一个标识。 2. 配置ssh key 生成秘钥对 在Git Bash中输入以下命令 ： 1ssh-keygen -t rsa -C &quot;123abc@163.com&quot; 之后可以不用设置密码，按下3个回车键即可。接下来可以去默认路径 C:\\Users\\banana\\.ssh下查看生成的两个文件，分别为 私钥：id_rsa 公钥：id_rsa.pub ​ 添加公钥到远程仓库打开GitHub主页，在Settings–&gt;SSH and GPG keys中，点击New SSH key 按钮； 再打开公钥文件，将其中的字符串完整复制，粘贴到key 中 执行ssh -T git@github.com 命令，查看公钥是否配置成功了，如下图所示则表示成功： 将私钥添加到自己的系统中 使用命令： ssh-add ~/.ssh/id_rsa 添加私钥至系统中，若无效的话，建议采取以下两种方法： 先执行 eval &#39;ssh-agent-s&#39; 再执行 ssh-add ~/.ssh/id_rsa ； 先执行ssh-agent bash --login -i 启动bash，或者说把bash挂到ssh-agent下面，再执行 ssh-add 当看到下图所示结果时，则表示成功了 3. 配置远程仓库 登录github账号，新建一个远程仓库。 在本地建一个与仓库同名的文件夹，在文件夹中打开Git Bash，执行如下命令： 123456789101112echo &quot;# commang&quot; &gt;&gt; README.md新建一个README.md文件，写入“# commang”git init初始化git文件夹，创建master分支和.git文件夹git add README.md将工作区中的README.md文件添加进暂存区git commit -m &quot;first commit&quot;将暂存区的文件提交到master分支上git remote add origin git@github.com:abc/gitTest.git配置远程仓库地址命名为origingit push -u origin master将本地master分支的数据push到远程仓库的master分支上 若没能成功push去服务器的话，可以去检查下本地.git 文件夹下的config 文件，其中的url必须与上述命令中的远程地址相同。 4.安装TortoiseGit-2.6.0.0-64bit.msi文件 下载TortoiseGit和中文语言包 默认选项一直next即可。 创建本地仓库，在文件夹中右键--&gt;Git在这里创建版本库 （我使用的是中文版本），如下图： 不用勾选，直接确定即可。 设置网络和远端 1. 右键--&gt;设置 将本地安装Git的ssh.exe路径地址配置到网络上，如下图： 我的Git是安装在C:\\software\\Git\\路径下 。 2. 将远程仓库的地址粘贴到URL和推送URL 中，如下图： 至此，你已经可以愉快的使用右键进行push和update了，但是会时不时遇到需要输入密码，但是你怎么输都不对的情况。 5. 使用本地Pageant记住你的私钥密码 开始菜单找到TortoiseGit菜单下的puttygen，打开puttygen 选择导入秘钥 选择C:\\Users\\Administrator.ssh目录下的私钥，并输入秘钥密码 选择save private key，将私钥另存为ppk格式的秘钥 开始菜单找到TortoiseGit菜单下的pageant，打开 点击add key，选择ppk秘钥，输入密码 每次开机启动pagent并添加ppk秘钥 点击torise git – settings 设置network—ssh的路径，设置为“C:\\Program Files\\TortoiseGit\\bin\\TortoisePlink.exe” 6. 使用过程遇到的问题 在新文件下拉取远程仓库报错：You asked to pull from the remote ‘origin’, but did not specify:a branch. Because this is not the default configured remotefor your current branch, you must specify a branch on the command line. 找到：.git/config文件 添加如下 123[branch &quot;master&quot;] remote = origin merge = refs/heads/master 在设置git远端地址时，尽量修改远端名称 如果不设置的话，在同一个文件夹下，新建两个文件夹，在这两个文件夹中分别拉取不同仓库的内容时就会报错 当新建了一个空的远程仓库，本地创建了一个关联到远端地址的仓库后，不要尝试拉取，否则会报出Couldn&#39;t find remote ref master错误信息 idea使用Git时，需要配置ssh 设置私钥地址 ​ 设置Git地址和SSH executable 为Native 设置github地址 对于重命名改名字等操作都可以在本地，修改完后添加进版本控制再push到远端仓库即可 对于在第2步中修改了本地远端的名称的操作，如果在idea中拉取代码的话，回报出这个错误： 1234Can&apos;t Update No tracked branch configured for branch master or the branch doesn&apos;t exist. To make your branch track a remote branch call, for example, git branch --set-upstream-to origin/master master (show balloon) 此时，可以执行命令git branch --set-upstream-to origin-repo/master master 意思是使我们在git设置的本地远程名称origin-repo/master追踪远程仓库的master分支 ​ ​","tags":[{"name":"GIT","slug":"GIT","permalink":"http://yoursite.com/tags/GIT/"}]},{"title":"Nginx安装部署web工程","date":"2018-05-30T11:40:59.000Z","path":"2018/05/30/Nginx安装部署web工程/","text":"Nginx安装1. 下载依赖包 如果你的服务器可以连接网络的话可以直接通过命令的方式下载tar包 下载PCRE库 wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz 下载zlib库 wget http://zlib.net/zlib-1.2.10.tar.gz 下载OpenSSL库 wget https://www.openssl.org/source/openssl-1.0.2o.tar.gz 如果你的服务器无法联网，可以自行去上面的wget命令后面的地址下载对应的tar包文件，ftp路径也可以直接通过浏览器打开，再将他们传到服务器中。 2. 安装依赖包 安装PCRE库 tar -zxvf pcre-8.37.tar.gz 先使用命令解压tar包 cd pcre-8.38 进去解压后的文件目录 ./configure 运行初始化脚本 如果此时你不是用root用户安装，或者希望指定安装根路径，可以使用--prefix=参数来指定安装路径 如：使用./configure --prefix=/home/test/pcre命令来指定将pcre安装到/home/tese/pcre目录下 make 使用make命令尝试编译 make install 编译安装 安装zlib库 tar -zxvf zlib-1.2.10.tar.gz 先使用命令解压tar包 cd zlib-1.2.10 进去解压后的文件目录 ./configure 运行初始化脚本 如果此时你不是用root用户安装，或者希望指定安装根路径，可以使用--prefix=参数来指定安装路径 如：使用./configure --prefix=/home/test/zlib命令来指定将zlib安装到/home/test/zlib目录下 make 使用make命令尝试编译 make install 编译安装 安装OpenSSL库 tar -zxvf openssl-1.0.2o.tar.gz 使用命令解压tar包即可 3. 安装Nginx3.1 安装步骤 先下载Nginx的tar包，我这里选择的是最新的稳定版nginx-1.14.0.tar.gz 跟上面安装依赖包一样，如果你的服务器可以联网的话建议使用wget http://nginx.org/download/nginx-1.14.0.tar.gz命令来下载tar包；如果不能联网的话建议自己通过浏览器访问http地址下载 tar -zxvf nginx-1.14.0.tar.gz 解压Nginx的tar包 cd nginx-1.14.0 进入解压后的目录 ./configure运行初始化脚本 注意：Nginx默认的安装路径是/usr/local/nginx,如果你不是使用root用户的话，就不能使用该路径。这里同样可以使用--prefix=参数来指定安装路径 同时，你可以使用--with-pcre=/home/test/pcre-8.38来指定pcre安装路径 使用--with-zlib=/home/test/zlib来指定zlib的安装路径 make 使用make命令尝试编译 make install 编译安装 cd sbin 进入sbin目录下 ./nginx 启动Nginx 同时可以使用 ./nginx -s reload 重启Nginx 使用./nginx -s stop 关停Nginx 3.2 Nginx常用编译选项 make是用来编译的，它从Makefile中读取指令，然后编译。 make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。 configure命令是用来检测你的安装平台的目标特征的。它定义了系统的各个方面，包括nginx的被允许使用的连接处理的方法，比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本，执行结束时，它会创建一个Makefile文件。nginx的configure命令支持以下参数： --prefix=*path* 定义一个目录，存放服务器上的文件 ，也就是nginx的安装目录。默认使用 /usr/local/nginx。 --sbin-path=*path* 设置nginx的可执行文件的路径，默认为 *prefix*/sbin/nginx. --conf-path=*path* 设置在nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为*prefix*/conf/nginx.conf. --pid-path=*path* 设置nginx.pid文件，将存储的主进程的进程号。安装完成后，可以随时改变的文件名 ， 在nginx.conf配置文件中使用 PID指令。默认情况下，文件名 为`prefix/logs/nginx.pid`. --error-log-path=*path* 设置主错误，警告，和诊断文件的名称。安装完成后，可以随时改变的文件名 ，在nginx.conf配置文件中 使用 的error_log指令。默认情况下，文件名 为*prefix*/logs/error.log. --http-log-path=*path* 设置主请求的HTTP服务器的日志文件的名称。安装完成后，可以随时改变的文件名 ，在nginx.conf配置文件中 使用 的access_log指令。默认情况下，文件名 为*prefix*/logs/access.log. --user=*name* 设置nginx工作进程的用户。安装完成后，可以随时更改的名称在nginx.conf配置文件中 使用的 user指令。默认的用户名是nobody。 --group=*name* 设置nginx工作进程的用户组。安装完成后，可以随时更改的名称在nginx.conf配置文件中 使用的 user指令。默认的为非特权用户。 --with-select_module --without-select_module 启用或禁用构建一个模块来允许服务器使用select()方法。该模块将自动建立，如果平台不支持的kqueue，epoll，rtsig或/dev/poll。 --with-poll_module --without-poll_module 启用或禁用构建一个模块来允许服务器使用poll()方法。该模块将自动建立，如果平台不支持的kqueue，epoll，rtsig或/dev/poll。 --without-http_gzip_module — 不编译压缩的HTTP服务器的响应模块。编译并运行此模块需要zlib库。 --without-http_rewrite_module 不编译重写模块。编译并运行此模块需要PCRE库支持。 --without-http_proxy_module — 不编译http_proxy模块。 --with-http_ssl_module — 使用https协议模块。默认情况下，该模块没有被构建。建立并运行此模块的OpenSSL库是必需的。 --with-pcre=*path* — 设置PCRE库的源码路径。PCRE库的源码（版本4.4 - 8.30）需要从PCRE网站下载并解压。其余的工作是Nginx的./ configure和make来完成。正则表达式使用在location指令和 ngx_http_rewrite_module 模块中。 --with-pcre-jit —编译PCRE包含“just-in-time compilation”（1.1.12中， pcre_jit指令）。 --with-zlib=*path* —设置的zlib库的源码路径。要下载从 zlib（版本1.1.3 - 1.2.5）的并解压。其余的工作是Nginx的./ configure和make完成。ngx_http_gzip_module模块需要使用zlib 。 --with-cc-opt=*parameters* — 设置额外的参数将被添加到CFLAGS变量。例如,当你在FreeBSD上使用PCRE库时需要使用:--with-cc-opt=&quot;-I /usr/local/include。.如需要需要增加 select()支持的文件数量:--with-cc-opt=&quot;-D FD_SETSIZE=2048&quot;. --with-ld-opt=*parameters* —设置附加的参数，将用于在链接期间。例如，当在FreeBSD下使用该系统的PCRE库,应指定:--with-ld-opt=&quot;-L /usr/local/lib&quot;. 典型实例(下面为了展示需要写在多行，执行时内容需要在同一行) 12345678&gt; ./configure&gt; --sbin-path=/usr/local/nginx/nginx&gt; --conf-path=/usr/local/nginx/nginx.conf&gt; --pid-path=/usr/local/nginx/nginx.pid&gt; --with-http_ssl_module&gt; --with-pcre=../pcre-4.4&gt; --with-zlib=../zlib-1.1.3&gt; 部署web工程1. 关于Nginx配置文件在部署web工程前，我们需要了解Nginx的配置文件。Nginx的配置文件存放在nginx/conf/nginx.conf。我们需要打开这个文件根据自己的web工程需求配置这个文件。 在nginx配置文件中主要分为四部分：main 全局设置，server主机设置，upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）和 location（URL匹配特定位置后的设置） main部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。 先贴一个配置文件，再来按照这个文件进行说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#user nobody;#在配置文件的顶级main部分，worker角色的工作进程的个数，master进程是接收并分配请求给worker处理。这个数值简单一点可以设置为cpu的核数grep ^processor /proc/cpuinfo | wc -l，也是 auto 值，如果开启了ssl和gzip更应该设置成与逻辑CPU数量一样甚至为2倍，可以减少I/O操作。如果nginx服务器还有其它服务，可以考虑适当减少。worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123;#写在events部分。每一个worker进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。nginx作为反向代理服务器，计算公式 最大连接数 = worker_processes * worker_connections/4，所以这里客户端最大连接数是1024，这个可以增到到8192都没关系，看情况而定，但不能超过后面的worker_rlimit_nofile。当nginx作为http服务器时，计算公式里面是除以2。 worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件， 减少用户空间到内核空间的上下文切换。对于普通应用设为 on，如果用来进行下载等应用 磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。 sendfile on; # tcp_nopush on; #长连接超时时间，单位是秒。长连接请求大量小文件的时候，可以减少重建连接的开销， 但假如有大文件上传，65s内没上传完成会导致失败。如果设置时间过长，用户又多，长时 间保持连接会占用大量资源。 keepalive_timeout 65; # gzip压缩功能设置 # 开启gzip压缩输出，减少网络传输 gzip on; #设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是20。建议设置成大于1k的字节数，小于1k可能会越压越大 gzip_min_length 1k; #设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。 gzip_buffers 4 16k; #gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu) gzip_comp_level 6; #匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。 gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml; #和http头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过gzip压缩的页面，例如，用Squid缓存经过Nginx压缩的数据。。 gzip_vary on; # http_proxy 设置 #允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值 client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数 client_body_buffer_size 128k; #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 75; #连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时) proxy_read_timeout 75; #设置代理服务器（nginx）从后端realserver读取并保存用户头信息的缓冲区大小，默认 与proxy_buffers大小相同，其实可以将这个指令值设的小一点 proxy_buffer_size 4k; #proxy_buffers缓冲区，nginx针对单个连接缓存来自后端realserver的响应，网页平均 在32k以下的话，这样设置 proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2） proxy_busy_buffers_size 64k; #当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。 proxy_temp_path（可以在编译的时候）指定写到哪那个目录。。 proxy_temp_file_write_size 64k; #指定将上面的临时文件写到哪那个目录。 proxy_temp_path /usr/local/nginx/proxy_temp 1 2; # 设定负载均衡后台服务器列表 upstream arc &#123; #ip_hash; server 192.168.10.100:8080 max_fails=2 fail_timeout=30s ; server 192.168.10.101:8080 max_fails=2 fail_timeout=30s ; &#125; # 很重要的虚拟主机配置 server &#123; #虚拟主机监听的端口 listen 8001; #服务器名 server_name localhost; #charset utf-8; #access_log logs/host.access.log main; #对 / 所有做负载均衡+反向代理 location / &#123; #定义服务器的默认网站根目录位置。 root html; #定义路径下默认访问的文件名 index index.jsp index.html index.htm; #请求转向arc定义的服务器列表，即反向代理，对应upstream负载均衡器。 proxy_pass http://arc; #下面这几个就这么设置吧 具体的我也不清楚 proxy_redirect off; # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; ## 其它虚拟主机，server 指令开始&#125; 2. 部署前端工程将web项目上传到Nginx的安装目录中的html文件夹中。修改nginx.conf配置文件。 遇到的问题 web端不能访问 检查防火墙是否关闭！关闭防火墙：service iptables stop 非root用户报出bind() to 0.0.0.0:80 failed (13:Permission denied)错误 这是由于非root用户启动时，nginx.conf文件中配置的端口为80，而在Linux中只有root用户才能使用1024以下的端口。所以只要讲配置文件中的端口修改为1024以上即可。 参考链接Nginx安装 Nging下部署项目，配置文件修改 nginx服务器安装及配置文件详解","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"}]},{"title":"关于第一次换工作的面试经验","date":"2018-05-27T15:13:40.000Z","path":"2018/05/27/关于第一次换工作的面试经验/","text":"因为一直想去南方的城市。所以我决定离开恒生去深圳发展，于是在2018年3月份的时候开始计划准备离职，那时候我还在北京。当时已经跟我的主管老大提出离职的意向。离职的流程大概要走一个月左右，在这一个月的时间内，我开始准备一些面试的东西，主要还是java基础这一块。所以从那个时候起，我开始写一些笔记，然后参加一些面试，主要是想通过这种方式，来增加自己的面试经验,了解自己有哪些不足的地方。然后当时恒生也在招人，所以就跟着几个老同事一起面了几个开发。在这里记录一下，我从2018年4月份至2018年5月份，这一个多月的时间里，参加过的所有面试经历，还有碰到的一些的面试题以及我个人对面试这件事情的看法和总结。 先锋支付面试流程先锋支付的面试流程是先参加笔试，笔试之后紧接着参加面试。这也是大多数公司都会采用的一种面试流程。当然也有很多公司追求效率直接让你参加面试。笔试和面试题 内连接，左连接，全连接之间的区别。 chmod 给文件授权和find命令的使用 如何在数据库每一秒钟都有数据写入的时候进行拆表。 spring scope？ 这个问题经常遇到，我在目前工作的这家公司笔试的时候也遇到过。 spring动态代理 实现方式和配置 java的几种加密方式 定时任务的实现方式 final,finally,finalize这三者之间的区别。 策略模式，命令模式与模板模式之间的区别。 灵狮区块链面试流程这家公司是约的电话面试。面试官人很好，面试问到的内容，基本上都是关于java基础然后跟面试官聊的也比较久，双方对彼此都有一个比较好的了解。面试题 java内存模型，堆内存和栈内存的区别。 spring aop使用了什么设计模式? 关于spring aop的考察也是会经常遇到的问题。主要需要了解的就是spring aop的实现方式，它是通过动态代理实现的，然后面试官又会扩展的问道，动态代理有几种实现方式？ socket网络编程 如何实现线程之间的通信。 这里主要是看一下juc包的源码 hashmap的数据结构，以及实现方式。 关于这一块，我有写过它的源码分析文章。 mongodb与传统数据库有什么区别？ 以及mangodb常用的命令这个问题我也遇到过很多次其实问的都不难，是一些比较基础的东西。 关于jpa的了解。 其实这里暴露了我的一个问题。我当时不知道jpa是啥。包括在后来的面试中，一个面试官问我关于orm的理解。其实我也不太清楚，orm是什么东西。所以在面试的时候，关于这些特别基础的常识性的东西，还是需要了解清楚。否则答不上来的话，会让人觉得你比较业余。而我当时，只顾着复习java基础的东西，关于框架这一块学习的不多。之前在公司，都是使用现成的框架，也没有去折腾过jpa，orm 查询sql语句优化。关于sq优化的问题我在很多面试中都遇到过。 左连接，右连接，与内连接之间的区别？ 这个问题我在之前的面试中就已经遇到过。 平时喜欢钻研的技术？ 这个问题其实在很多公司面试的时候都会问到。很多面试官其实就是项目组的技术负责人，然后他们会考察你作为一个开发人员对于技术的热情。所以这个时候，如果你有写过一些，技术博客，或者看过一些源码，或者直接把github账号展现给面试官看的话，会是一个优势。 嘉联支付面试流程嘉联支付的面试流程是先笔试，然后紧接着跟技术负责人聊。笔试和面试题 mybatis分页实现。 这个我之前在恒生的时候已经看过mybatis分页的源代码。这一块主要是通过分页插件拦截器实现的。 springaop原理。 这个问题我在上面遇到过。 对spring mvc和severlet的了解。 关于spring mvc这一块的东西在面试中还是会经常遇到的。因为我之前一直是做后台的开发，所以对前台mvc的东西了解的不多。去找工作面试的话，还是应该要全面一点，至少要了解一些常用的东西。要做到你知道这是一个什么东西，即使你不精通，但是哪怕你写过一个简单的demo。也比直接说，我不知道要强。 单例模式手写。 嘉联支付的笔试要求手写出单例模式。当时我并没有完整的写出来。程序里面忘了加static关键字。 zk分布式锁的实现。 sql去重有哪些方法。 软通动力面试流程软通动力的面试也是先笔试再面试的形式。但是软通动力的面试官真的很不专业。所以不建议大家以后去这种，外包公司去面试，其实对于你刷面试经验并没有太大的帮助。因为你极有可能碰到的是一个非常不靠谱的面试官，他不懂得怎么面试。 笔试和面试题 说一下nginx如何部署。 这个我不会，没答上来。 为什么选用mongodb。 这个问题我当时直接说了一下mangodb，它解决了我们哪些业务场景的问题 查看数据库表用户命令。 这个问题我也没有答上来。 说一下spring MVC 说一下serverlet 说一下java这门语言 当面试官问出这些问题的时候，我其实是比较反感的。首先，面试一定是面试者和公司双方之间的交流。并不是单纯的面试官问面试者问题。所以，对于面试者来说，在一场面试中，他需要从面试官那里充分了解这个公司。所以经常有一些面试官会问，你有些什么想要从我这里获知的。对于面试官来说，他想要知道的是，面试者是否达到了自己这个岗位的要求。 因此当面试官问我怎么看java这门语言的时候。我觉得这种问题除了让面试官秀自己的优越感以外，其他毫无意义。即使我这个问题回答的再好，也并不能体现我开发技能有多好，最多只能体现出我对java这门语言的理解水平。 说一下java并发和多线程。 在回答这一题的时候，我直接说出了一种最简单的实现方式。后来我反思了一下，觉得我说得并不好，因为其实面试官肯定知道这种简单的东西，他希望的是你要答出他的痛点。你需要讲出多线程并发编程的时候，哪些需要注意的事项。这个也是我后来跟一个猎头朋友，还有一个技术负责人聊天的时候，他们给我的一点提示，对我的帮助还是很大的。 关于软通动力面试后的总结在经过了软通动力的面试之后，我自己反思了一下在这场面试中有哪些不足的地方？最后我得到的收获是，第一点对于自己原本就，不是太有兴趣的公司，应该直接不去面试，否则其实是浪费自己的时间。本来我是想通过面试来刷一下自己的面试经验。但是后来我发现，会经常碰到一些不太靠谱的面试官。就像软通动力的这个面试官一样，甚至我答完了面试官的问题之后，我还没有来得及问他一些关于公司的事情，他就直接让我在那里等结果。结果等了一个小时也没有结果。非常不尊重面试者。所以从那之后，任何外包公司的面试我一律不去。第二点是，我没有回答好面试官的说一下XXX系列问题，其实这种问题很难回答，你可以往简单的说，也可以往复杂了说。而且因为这个问题不具体，你不知道面试官的痛点在哪里，很难把这个问题回答的很好。有水平的面试官，他会根据你说出的答案，不断的进行深挖。这样才能体现出你对一个技术点，了解的深度。然而在像软通动力这种外包公司里他们并不注重技术，所以他们的面试官，也不太会注重深挖你的技术。这也是我不建议大家去外包公司面试的原因。因为你有很大的概率会遇到这种麻瓜面试官。 赢时胜面试流程赢时胜的面试流程也是先笔试再面试。面试过程面试官没有问太多技术性的问题，主要是针对笔试题问了些简单的问题，大多数时间聊的还是业务上的事情。因为我之前做的是银行的开发，刚好跟他们的一个现有的项目对口。所以后来赢时胜还是给我发了offer。但是这些大公司都会压你的工资。他们根据工作经验划分出不同的薪资水平，然后根据面试者的面试情况，压低面试者的薪资。他们的这种做法让我觉得很不喜欢，所以虽然后来拿了offer，但是也不是我期望的薪资，当时作为一个保底就先接受了。这里也说一下关于，期望薪资的问题。我之前刷面试经验的时候会去面很多做外包的小公司，然后这些公司出于人力成本的考虑，本来就不会给岗位开出很高的薪资，但是他们会在，招聘信息上把薪资上限的很高。比如三年工作经验以内，给的薪资水平是9k到18k这种。其实他们真正能跟岗位开出的工资也就是9k左右，即使你面试的情况再好，也不可能到18k。当我带着13k期望薪资去面试他们这种岗位的时候，面试官看到你的期望薪资，其实就已经觉得你不太合适了。然后如果他们觉得你的面试情况好的话，肯定会压低你的薪资。 木槿科技面试流程木槿科技的面试时先HR面，人力会跟你大体上聊一些离职原因，之前负责的工作，期望薪资这些。然后是技术负责人面试，他们没有笔试环节。面试题 你对ORM的了解 这里就再次丢脸了，没答出来 zk如何实现分布式锁 这个问题也是之前遇到过的 简述Jdbc的编程过程 这个我之前一直没有自己写过，都是通过使用Mybatis框架来做的这个事情。 Redis的几种数据结构 Hash型数据存储的基本使用命令 这个我之前看过这些简单的命令，但是当时忘了也没答上来。 木槿科技面试总结 在面试木槿的时候遇到过几次很基础，很简单的问题没有答出来。而在这之前我准备的面试方向都是Java基础比较深入的应用。面试了这几家公司发现他们大多数其实问的内容都很简单，根本不会涉及到很深的原理性问题，也不会深挖技术细节。而很多很简单的概念其实我不是很清楚，之前也没关注过这些，所以导致了我很受挫，在面试的时候这种问题答不出来显得很业余。 华锐金融面试流程华锐的面试也是采用先笔试后面试的方式进行面试和笔试题 一个文件里面包含很多个乱序不重复的电话号码，需要在20兆内存的空间内，将这些电话号码进行排序，并重新输出到另一个文件内。 这一题我没有做出来。 java内存模型中，堆内存和栈内存的区别。 垃圾回收算法 如何复制一个对内存中的对象？ 华锐面试的总结其实一开始我笔试题做得并不好，技术面之后，我一度以为自己已经挂了。没想到后来人力资源，和面试官一起讨论了一下，觉得我还可以。紧接着后来就是人力资源给我介绍一下这家公司详细情况。介绍完之后，立马就进行了ceo面。跟ceo聊的很好，然后也了解了这个公司的团队情况，觉得非常厉害，也是我期望的那种工作团队。从面试体验也可以看出来，整个公司团队的，效率和执行力是非常高的。CEO非常尊重工程师，面试结束之后，亲自把我送到了电梯门口。面试是当天上午十点开始的，等结束的时候，快下午1点了。后来我回到家里，下午两三点的时候，人力给我发来录用通知，开出的薪资条件，远远超过了我的期望。可以看出来他们非常的有诚意，也非常尊重工程师文化。通过华锐的面试，给我的感觉是，运气也非常的重要。所以在找工作面试的时候，不要因为，有几家面试失败了，就轻易的看低自己，一定要坚持下去，尽量去一家你想去的公司。如果这家公司从一开始就压榨你的薪资的话，也不用指望你入职之后能有多大的改善","tags":[{"name":"面试总结","slug":"面试总结","permalink":"http://yoursite.com/tags/面试总结/"}]},{"title":"老无所依","date":"2018-05-27T11:40:59.000Z","path":"2018/05/27/老无所依/","text":"天一给我推荐的科恩兄弟系列，反派发型很萌，又很聪明，演员是西班牙人，叫哈维尔巴登。把反派演的很有魅力，天一称之为影史上最难忘的反派之一，其实在我心里最好的反派依旧是小丑。 一直没看懂为什么片名叫老无所依，但是很喜欢这张海报 向来很喜欢红色，这张海报简直大爱 看完电影你就知道为什么我要放这张图了，设计的很棒","tags":[{"name":"科恩兄弟","slug":"科恩兄弟","permalink":"http://yoursite.com/tags/科恩兄弟/"}]},{"title":"ArrayList源码解析","date":"2018-05-13T11:40:59.000Z","path":"2018/05/13/ArrayList源码分析/","text":"ArrayList源码field1234private static final int DEFAULT_CAPACITY = 10;//默认的数组容量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//初始化时加载一个空数组private transient Object[] elementData;//实际用来存储数据的数组private int size;//数组大小 构造器1234public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; 默认的无参构造器就是简单的将数组引用指向类定义的空数组对象。 123456789public ArrayList(Collection&lt;? extends E&gt; c) &#123; //将集合转换为存储数据的数组 elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) //若不是Object类型的数组，则将数组copy到Object类型的数组中去 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);&#125; 方法 新增方法 12345678910111213 public void add(int index, E element) &#123; //确保index的位置没有超出数组的范围 rangeCheckForAdd(index);//保证数组的容量是否足以添加进去元素，并且将modCount的值自增1 ensureCapacityInternal(size + 1); // Increments modCount!! //将index位置后面的数据往后移1位 System.arraycopy(elementData, index, elementData, index + 1, size - index); //将元素放置在index位置上 elementData[index] = element; //数据长度+1 size++; &#125; fail-fast机制在遍历一个集合时，当集合结构被修改，会抛出Concurrent Modification Exception。 fail-fast会在以下两种情况下抛出ConcurrentModificationException （1）单线程环境 集合被创建后，在遍历它的过程中修改了结构。 但是迭代器的remove()方法会让expectModcount和modcount 相等，所以在遍历集合的过程中只能通过迭代器的remove()方法进行删除元素。 （2）多线程环境 当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; //将修改次数+1 modCount++; // overflow-conscious code //增加数组长度 if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //新数组长度为原先数组长度的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //若新长度依旧小于minCapacity，则将minCapacity作为新长度 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //新长度大于MAX_ARRAY_SIZE，则将新长度置为最大的int值 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //将就数组copy到新数组上 // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); //MAX_ARRAY_SIZE的值为Integer.MAX_VALUE - 8 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; get方法 12345public E get(int index) &#123; //确保index的位置没有超出数组的范围 rangeCheck(index); return elementData(index);&#125; remove方法 1234567891011121314151617 public E remove(int index) &#123; //检查是否数组下标越界 rangeCheck(index);//修改次数+1 modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) //将index位置后面的数组往前移1位 System.arraycopy(elementData, index+1, elementData, index, numMoved); //将size的值-1，并将数组最后一位的数据引用置为null 让GC自动回收未被引用的对象 elementData[--size] = null; // clear to let GC do its work//将被移除的对象返回出去 return oldValue; &#125; 123456789101112131415161718public boolean remove(Object o) &#123; if (o == null) &#123; //若是空对象的话则遍历数组将其移除 for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; //不是空对象则遍历数组，通过equals方法判断对象是否相等，相等则将其移除 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125; 1234567891011private void fastRemove(int index) &#123; //修改次数+1 modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) //将index位置后面的数组往前移1位 System.arraycopy(elementData, index+1, elementData, index, numMoved); //将size的值-1，并将数组最后一位的数据引用置为null 让GC自动回收未被引用的对象 elementData[--size] = null; // clear to let GC do its work&#125; 12345678910public void clear() &#123; //修改次数+1 modCount++; //将所有的数组引用都置为null 让GC回收 // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; //数组大小置为0 size = 0;&#125; ​由上面源码可以看出，ArrayList的删除操作本质上都是将数组移位，末尾数组引用置为null，让GC自动回收垃圾对象。 迭代器123456789101112131415161718192021222324252627282930313233343536373839404142private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 先是一个Itr的类，实现了迭代器接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[lastRet = i]; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; ArrayList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; &#125; 然后通过一个ListItr继承Itr类，并同时实现了ListIterator接口。 参考文章参考文章一","tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://yoursite.com/tags/集合源码/"}]},{"title":"HashMap源码解析","date":"2018-05-13T11:40:59.000Z","path":"2018/05/13/HashMap源码/","text":"HashMap源码1.构造器123456789101112131415161718/**构造器默认两个参数：initialCapacity 哈希表（键值对数组）初始化容量（默认为16,2的4次方 loadFactor 加载因子 （默认为0.75）*/public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; init(); &#125; 2.方法12345678910111213 void addEntry(int hash, K key, V value, int bucketIndex) &#123; //判断是否需要对原先的hash表扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; //对hash表扩容 并将旧hash表的内容放入新hash表中 resize(2 * table.length); //通过hash()方法来获取key的hash值 hash = (null != key) ? hash(key) : 0; //根据hash值重新获取Entry在数组中的index bucketIndex = indexFor(hash, table.length); &#125;//新增一个键值对 在hash表中的bucketIndex位置放入一个Entry createEntry(hash, key, value, bucketIndex); &#125; 12345678910111213void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; //将所有的旧hash表的键值对转换到新hash表上 transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);&#125; 123456public void clear() &#123; modCount++; //使用Arrays工具类，将hash表的数据都填充成null Arrays.fill(table, null); size = 0; &#125; 1234567891011121314151617 final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125;//获取key的hash值 int hash = (key == null) ? 0 : hash(key); //遍历在hash表中key的hash值所对应位置的链表 通过key.equasls方法来确定key所对应的键值对 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 1234567891011121314151617181920212223242526 public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; //给hash表扩容，若表为空，则按照初始化时的threshold值创建hash表。 //threshold=capacity * loadFactor //若不为空，则该方法扩容为原来hash表的2倍 inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); //若根据key的hash值计算出的hash表位置已经存在了键值对，则遍历该链表，将新的Entry添加到链表的最后 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125;//将hash表的修改次数+1 为了实现fast-fail机制 modCount++; addEntry(hash, key, value, i); return null; &#125; 1234567891011121314151617181920212223242526272829303132333435363738final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); int i = indexFor(hash, table.length); //指向链表当前对象前一个对象的引用 Entry&lt;K,V&gt; prev = table[i]; //指向链表当前对象的引用 Entry&lt;K,V&gt; e = prev; while (e != null) &#123; //遍历链表数据直至找到key对应的Entry //next为指向链表当前数据下一个对象的引用 Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; //hash表修改次数+1 modCount++; //hash表的大小-1 size--; //此时当前一个链表前一个数据与当前数据为同一个对象，说明hash表当前位置不存在链表， //直接将key所对应hash表当前数据的next引用指向当前数据的下一个对象。（链表的删除思想） if (prev == e) table[i] = next; else //此时说明hash表当前位置存在链表，将前一个数据的next引用指向当前数据的下一个对象 prev.next = next; //这是Entry内部类定义的hook方法，每次删除数据都需要调用一次。 e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e;&#125; hook方法就是钩子方法 3. Entry类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//静态内部类 实现了Map类的内部接口 用于存储键值对static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; //复写equals方法 public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125; /** * This method is invoked whenever the value in an entry is * overwritten by an invocation of put(k,v) for a key k that's already * in the HashMap. */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; /** * This method is invoked whenever the entry is * removed from the table. */ void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; 4.迭代器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 //通过一个抽象内部类HashIterator实现了Iterator接口 //HashMap提供的key和value迭代器都是通过继承这个HashIterator实现的private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; Entry&lt;K,V&gt; next; // next entry to return int expectedModCount; // For fast-fail int index; // current slot Entry&lt;K,V&gt; current; // current entry HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if ((next = e.next) == null) &#123; Entry[] t = table; //当next为null时说明e是hash表当前index位置的链表的最后一个元素 //通过while语句内的方式实现next往后移位直至不为null的一个元素 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125; &#125; 123456789101112131415161718//value迭代器内部类private final class ValueIterator extends HashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125; &#125;//key迭代器内部类 private final class KeyIterator extends HashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125; &#125;//Entry迭代器内部类 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; 5.关于hash表的两个问题 如何设计才能使减小hash冲突？ 针对如何获取在hash表中的位置，HashMap中主要通过三个部分来减小散列冲突： 第一部分，首先根据Object.hashcode得到一个散列值，Object.hashCode是一个native方法。一般情况下可以认为是该对象的地址信息散列得到的，也就是相当于是对象的ID，同一个对象有相同的ID。这样得到的散列值还是比较合理的. 12345678910111213141516final int hash(Object k) &#123; int h = hashSeed; //对于String的hashCode需要另外计算 if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). //二次散列 h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 第二部分，桶的数量设计。一般由哈希值得到桶的位置都是将哈希值除以桶的数量得到的余数就是桶的位置。一般来说想要尽可能的减少散列冲突有两类办法，一类是使用素数数量的桶，例如hashTable，一类是使用2的幂次数量的桶，例如hashmap，hashmap使用2的次幂的桶有个好处，就是可以用位运算来算，只要将散列值和桶的数量-1相与就是桶的位置不需要除。这样相对来说速度快一些。hashmap里有个静态方法indexof就是用来做这个的。具体下文会说到。 1234567static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : \"length must be a non-zero power of 2\"; //长度为2的幂次的hash表，用位运算来将散列值和桶的数量-1相与 就是数组的index,这样比采用除更快 //比如length是4，那如果h是0-3则返回的值就是0-3，如果是h=4则返回0，h=5则返回1 //length-1是因为数组下标从0开始 return h &amp; (length-1);&#125; 第三部分，hashseed，第二部分中曾经说道通过将哈希值与桶的数量-1相与得到桶的位置。但是这样做有一个小的问题。当哈希值非常大，而桶的数量很小的时候回出现仅仅依靠哈希值的低位来散列的结果。这样即使散列值做的很好耶没有办法得到很好的散列。这时hashseed的作用就体现出来的，hashseed通过右移部分哈希值，然后将其亦或得到的结果进行在进行定位桶的位置。这样做就综合考虑了高位和低位的值。从而减小了散列冲突的可能性。此外由于java的语言特性，对于String的情况其hashseed需要额外设计。 123456789101112131415161718192021222324252627282930313233private static class Holder &#123; /** * Table capacity above which to switch to use alternative hashing. */ static final int ALTERNATIVE_HASHING_THRESHOLD; static &#123; String altThreshold = java.security.AccessController.doPrivileged( new sun.security.action.GetPropertyAction( \"jdk.map.althashing.threshold\")); int threshold; try &#123; threshold = (null != altThreshold) ? Integer.parseInt(altThreshold) : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT; // disable alternative hashing if -1 if (threshold == -1) &#123; threshold = Integer.MAX_VALUE; &#125; if (threshold &lt; 0) &#123; throw new IllegalArgumentException(\"value must be positive integer.\"); &#125; &#125; catch(IllegalArgumentException failed) &#123; throw new Error(\"Illegal value for 'jdk.map.althashing.threshold'\", failed); &#125; ALTERNATIVE_HASHING_THRESHOLD = threshold; &#125; &#125; static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;但是这个静态类常量也是可以根据虚拟机参数的设定来更改的。这也就是Holder这个类这段静态代码的意义了。可以通过调整虚拟机的参数来设定这个域值。关于Holder类是参考别人的文章来的，说实话我也没有完全搞清楚。 在发生hash冲突时，如何解决？ 在发生hash冲突之后，HashMap采用单向链表方式来存储键值对。在前面介绍的getEntry、put等方法的时候，都有遍历链表。 关于final加上final的仅仅是相当于当前的引用不在改变，但是容器的元素是恶意增删的，元素的内容也是可以改变的。 参考链接参考文章一","tags":[{"name":"集合源码","slug":"集合源码","permalink":"http://yoursite.com/tags/集合源码/"}]}]