<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小蚂蚁爱吃香蕉</title>
  
  <subtitle>It&#39;s what you do in the dark puts you in the light</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-30T15:09:43.557Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小蚂蚁爱吃香蕉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode记录</title>
    <link href="http://yoursite.com/2020/03/04/LeetCode/"/>
    <id>http://yoursite.com/2020/03/04/LeetCode/</id>
    <published>2020-03-04T14:35:39.000Z</published>
    <updated>2020-03-30T15:09:43.557Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode记录总结"><a href="#LeetCode记录总结" class="headerlink" title="LeetCode记录总结"></a>LeetCode记录总结</h1><p>本文章主要记录LeetCode刷题学到的知识</p><a id="more"></a><h2 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242.Valid Anagram"></a>242.Valid Anagram</h2><p>题目：</p><blockquote><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p></blockquote><p>我的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ((s.isEmpty() &amp;&amp; !t.isEmpty())||s.length()!=t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] tchars = t.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] schars = s.toCharArray();</span><br><span class="line">       Arrays.sort(tchars);</span><br><span class="line">        Arrays.sort(schars);</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tchars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tchars[i] != schars[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路是想通过将字符串排序，然后逐一对比字符。看到官方有种解法是通过哈希映射，先准备一个26长度的int数组，将每个字符与<code>a</code>相减得出对应的ASCII码，将其作为数组的下标，s的字符对下标上的值++，t的字符对下标上的值–。最后，判断这个数组有没有不为0的，若不为0，则说明字符不一样。<strong>以后遇到字符串比较的问题，可以往数组映射上进行考虑</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        counter[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        counter[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> count : counter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题的follow up是，如果字符串是unicode编码的，那么怎么实现。那样的话我的这种解法依然有效，但是使用定长数组的解法则不行，需要使用hashmap来代替数组。</p><p>Unicode相关：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></p><h2 id="LCCI-01-01-Is-Unique"><a href="#LCCI-01-01-Is-Unique" class="headerlink" title="LCCI.01.01 Is Unique"></a>LCCI.01.01 Is Unique</h2><p>题目：</p><blockquote><p>Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?</p></blockquote><p>我的思路是直接采用整形数组，将每个字符与<code>A</code>相减得出的数字作为数组下标，将数组的值+1，当发现某个字符对应的数组值大于1时，则说明该字符重复了，返回false。</p><p>题目说的是不采用其他数据结构，而我用了数组来解，其实也是一种数据结构。看了题解，发现可以用整形的bit位代替数组，将每个字符与<code>A</code>的差作为数字1的左移位数，这样每次和mark的值相与，若字符没重复着则会为0，不为0则说明重复了。在不重复的时候，用或运算来将mark的bit位置位。贴出我修改后的解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (astr.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = astr.toCharArray();</span><br><span class="line">        <span class="keyword">long</span> flag =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="keyword">long</span> i = aChar - <span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">if</span> ((flag &amp; (<span class="number">1L</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                flag =flag|(<span class="number">1L</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-02-Check-Permutation"><a href="#LCCI-01-02-Check-Permutation" class="headerlink" title="LCCI.01.02 Check Permutation"></a>LCCI.01.02 Check Permutation</h2><p>题目：</p><blockquote><p>Given two strings,write a method to decide if one is a permutation of the other.</p></blockquote><p>此题类似与#242 valid anagram 那道题。可以采用相同的解法。但是看到题解里有采用异或的方式来解的，异或本身的原理是：<code>0^a=a;1^a=a取反</code>。因此当用0跟字符串每个字符异或后，得到的值是字符串每个字符相异或的。这样对两个字符串进行异或后再对两个值进行比较，若相等则说明是同个字符串，否则为不同字符串。</p><p>解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CheckPermutation</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> s1 == <span class="keyword">null</span> &amp;&amp; s2 == <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">char</span>[] s1Chars = s1.toCharArray();</span><br><span class="line">       <span class="keyword">char</span>[] s2Chars = s2.toCharArray();</span><br><span class="line">       <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> s1Char : s1Chars) &#123;</span><br><span class="line">           a = a ^ s1Char;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> s2Char : s2Chars) &#123;</span><br><span class="line">           b = b ^ s2Char;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> a == b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-03-String-toURL"><a href="#LCCI-01-03-String-toURL" class="headerlink" title="LCCI.01.03 String toURL"></a>LCCI.01.03 String toURL</h2><p>题目：</p><blockquote><p>Write a method to replace all spaces in a string with ‘%20’. You may assume that the string has sufficient space at the end to hold the additional characters,and that you are given the “true” length of the string. (Note: If implementing in Java,please use a character array so that you can perform this operation in place.)</p></blockquote><p>刚开始理解错了题目的意思，以为要将字符串中的空格全部替换为<code>%20</code>，后来测试才发现，需要转换的字符串其实是给定的长度，所以只需要遍历字符串，将给定长度内的空格字符替换为<code>%20</code>即可。</p><p>解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpaces</span><span class="params">(String S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span>[] charArray = S.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = charArray[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">                res.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-04-Palindrome-Permutation"><a href="#LCCI-01-04-Palindrome-Permutation" class="headerlink" title="LCCI.01.04 Palindrome Permutation"></a>LCCI.01.04 Palindrome Permutation</h2><p>题目：</p><blockquote><p>Given a string, write a function to check if it is a permutation of a palin­ drome. A palindrome is a word or phrase that is the same forwards and backwards. A permutation is a rearrangement of letters. The palindrome does not need to be limited to just dictionary words.</p></blockquote><p>可以把题目中的回文字符串理解为一个字符串中字母出现次数为奇数的不超过1个。理解了这个之后，就可以使用哈希映射的方式来解决这个问题了，先将每个字母对应的数字放到数组中，然后将数组的值奇数，作为出现此处。最后判断次数是否为奇数即可。此处判断是否为奇数可以使用<code>(a&amp;1)==1</code>来判断，若位与后结果为1，则说明是奇数。</p><p>关于位运算总结可以参考这篇博客：<a href="http://blog.tomtung.com/2007/05/bitwise-operation/" target="_blank" rel="noopener">位运算总结</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPermutePalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>|| s.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; letters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> aChar : chars) &#123;</span><br><span class="line">        letters.merge(aChar, <span class="number">1</span>, (a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> letter : letters.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((letter&amp;<span class="number">1</span>)==<span class="number">1</span>)&amp;&amp; (++flag)&gt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-05-One-Away"><a href="#LCCI-01-05-One-Away" class="headerlink" title="LCCI.01.05 One Away"></a>LCCI.01.05 One Away</h2><p>题目：</p><blockquote><p>There are three types of edits that can be performed on strings: insert a character, remove a character, or replace a character. Given two strings, write a function to check if they are one edit (or zero edits) away.</p></blockquote><p>此题并不是单词的判断字符串少了几个字符的问题，而是两个字符串除了不一样的那个字符外，其他字符的顺序也需要一直。没有想到更好的办法，于是我采用的是双指针暴力法。双指针类的题目需要分清不同情况下两个指针的处理，在这题中，两个字符串长度相差大于1肯定返回false，其他的分为长度相同和长度相差为1来分别处理。长度相同时，最多有一个字符可以不一样。长度相差为1时，短字符串的顺序必须与长字符串一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (first == <span class="keyword">null</span> || second == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     String longer = first.length() &gt;= second.length() ? first : second;</span><br><span class="line">     String shorter = first.length() &lt; second.length() ? first : second;</span><br><span class="line">     <span class="keyword">if</span> (longer.length() - shorter.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (longer.isEmpty() || shorter.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">return</span> longer.length() - shorter.length() &lt;= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (longer.length() == shorter.length()) &#123;</span><br><span class="line">                 </span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; longer.length(); k++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (longer.charAt(k) != shorter.charAt(k)) &#123;</span><br><span class="line">                 flag++;</span><br><span class="line">                 <span class="keyword">if</span> (flag &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (; j &lt; shorter.length(); ) &#123;</span><br><span class="line">             <span class="keyword">if</span> (longer.charAt(i) != shorter.charAt(j)) &#123;</span><br><span class="line">                 i++;</span><br><span class="line">                 flag++;</span><br><span class="line">                 <span class="keyword">if</span> (flag &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             i++;</span><br><span class="line">             j++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-06-Compress-String"><a href="#LCCI-01-06-Compress-String" class="headerlink" title="LCCI.01.06 Compress String"></a>LCCI.01.06 Compress String</h2><p>题目：</p><blockquote><p>Implement a method to perform basic string compression using the counts of repeated characters. For example, the string aabcccccaaa would become a2blc5a3. If the “compressed” string would not become smaller than the original string, your method should return the original string. You can assume the string has only uppercase and lowercase letters (a - z).</p></blockquote><p>这题我采用普通的遍历法做出来了，需要注意的是不能使用哈希映射的方法。因为相同字母在不连续位置出现是不能统计到一起去的。看题解中，有同学<strong>在字符的最后补了一位来规避遍历时处理最后一个字符的特殊情况</strong>，这种思路值得学习。还有的同学采用了双指针的思路，一个指针遍历字符，另个指针统计相同的字符个数。</p><p>我的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.isEmpty()||S.length()&lt;<span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>[] chars = S.toCharArray();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> repeat = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                repeat++;</span><br><span class="line">                <span class="keyword">if</span> (i == chars.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(chars[i]).append(repeat);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(chars[i - <span class="number">1</span>]).append(repeat);</span><br><span class="line">                repeat = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == chars.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    sb.append(chars[i]).append(repeat);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.length() &lt;= sb.length() ? S : sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-07-Rotate-Matrix"><a href="#LCCI-01-07-Rotate-Matrix" class="headerlink" title="LCCI.01.07 Rotate Matrix"></a>LCCI.01.07 Rotate Matrix</h2><p>题目：</p><blockquote><p>Given an image represented by an N x N matrix, where each pixel in the image is 4 bytes, write a method to rotate the image by 90 degrees. Can you do this in place?</p></blockquote><p>一开始我的解题思路是通过新建一个二维数组，然后，将矩阵进行转换，按照<code>a=j,b=N-i-j</code>的逻辑转换，最后再将转换后的数组复制到原数组中。这样会导致空间复杂度为O(N)。看了书本上的解法是原地旋转，由外层向内层每一层都是将上边移到右边，右边移到下边，下边移到左边，左边移到上边。通过这种方式完成整个矩阵的旋转。这种方式的实现逻辑交易较为清晰，时间复杂度为O(N2)。修改我的解法后，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = matrix.length;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> layer = <span class="number">0</span>; layer &lt; N / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = layer; j &lt; N - layer - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = matrix[layer][j];</span><br><span class="line">            matrix[layer][j] = matrix[N - j - <span class="number">1</span>][layer];<span class="comment">//left-&gt;top</span></span><br><span class="line">            matrix[N - j - <span class="number">1</span>][layer] = matrix[N - layer - <span class="number">1</span>][N - j - <span class="number">1</span>];<span class="comment">//bottom-&gt;left</span></span><br><span class="line">            matrix[N - layer - <span class="number">1</span>][N - j - <span class="number">1</span>] = matrix[j][N - layer - <span class="number">1</span>];<span class="comment">//right-&gt;bottom</span></span><br><span class="line">            matrix[j][N - layer - <span class="number">1</span>] = top;<span class="comment">//top-&gt;right</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>矩阵旋转时，可以将矩阵的数组下标写出来，然后找出每一步转换的<code>i，j</code>的规律。一般无非就是<code>x=j,y=length-i-1</code>这种情况。</p><h2 id="LCCI-01-08-Zero-Matrix"><a href="#LCCI-01-08-Zero-Matrix" class="headerlink" title="LCCI.01.08 Zero Matrix"></a>LCCI.01.08 Zero Matrix</h2><p>题目：</p><blockquote><p>Write an algorithm such that if an element in an MxN matrix is 0, its entire row and column are set to 0.</p></blockquote><p>我的思路是将矩阵中应该被清0的行和列分别用数组记录下来。然后再拿行数组和列数组处理矩阵中对应的行和列。但是这样占用的空间复杂度为O(N)。参考书本上给出的优化方案是，将矩阵的第一行和第一列作为行数组和列数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">       <span class="keyword">int</span> cloumns = matrix[<span class="number">0</span>].length;</span><br><span class="line">       <span class="keyword">int</span>[] rowsToZero = <span class="keyword">new</span> <span class="keyword">int</span>[rows];</span><br><span class="line">       <span class="keyword">int</span>[] cloums = <span class="keyword">new</span> <span class="keyword">int</span>[cloumns];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                   rowsToZero[i]=<span class="number">1</span>;</span><br><span class="line">                   cloums[j]=<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowsToZero.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (rowsToZero[i] == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">//set i row to 0</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                   matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cloums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cloums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix.length; j++) &#123;</span><br><span class="line">                   matrix[j][i]=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-01-09-String-Rotation"><a href="#LCCI-01-09-String-Rotation" class="headerlink" title="LCCI.01.09 String Rotation"></a>LCCI.01.09 String Rotation</h2><p>题目：</p><blockquote><p>Given two strings, s1 and s2, write code to check if s2 is a rotation of s1 (e.g.,”waterbottle” is a rotation of”erbottlewat”). Can you use only one call to the method that checks if one word is a substring of another?</p></blockquote><p>这一题我给它想的复杂了，第一反应是通过双指针来做，结果没有做出来。考虑的情况漏了。看了书本才想起用包含子串的方法应该是最简单的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlipedString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.isEmpty() || s2.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.isEmpty() &amp;&amp; s2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() != s2.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       String s1s1 = s1+s1;</span><br><span class="line">    <span class="keyword">return</span> s1s1.contains(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-01-Remove-Duplicate-Node"><a href="#LCCI-02-01-Remove-Duplicate-Node" class="headerlink" title="LCCI.02.01 Remove Duplicate Node"></a>LCCI.02.01 Remove Duplicate Node</h2><p>题目：</p><blockquote><p>Write code to remove duplicates from an unsorted linked list.</p></blockquote><p>此题的follow up是想让不用额外的空间来实现，于是我直接采用双指针法。一个指针指向尾部，另个之前在前面做判重。这样会增加时间复杂度，为O(N2)；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeDuplicateNodes</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode tail = head;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = tail.next;</span><br><span class="line">        <span class="keyword">boolean</span> nextIsDup = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 != tail.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val == next.val) &#123;</span><br><span class="line">                nextIsDup = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1= head;</span><br><span class="line">        <span class="keyword">if</span> (nextIsDup) &#123;</span><br><span class="line">            <span class="comment">//delete current node</span></span><br><span class="line">            tail.next= next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            tail = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-02-Kth-Node-From-End-of-List"><a href="#LCCI-02-02-Kth-Node-From-End-of-List" class="headerlink" title="LCCI.02.02 Kth Node From End of List"></a>LCCI.02.02 Kth Node From End of List</h2><p>题目：</p><blockquote><p>Implement an algorithm to find the kth to last element of a singly linked list. Return the value of the element.</p></blockquote><p>这题的第一想法觉得很简单，用遍历就可以实现。看了follow up 说可以用递归和双指针。递归没有什么想法，于是便实现了一个双指针版本的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode b = head;</span><br><span class="line">    ListNode a = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">        b=b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (b.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        b=b.next;</span><br><span class="line">        a=a.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴上题解里的递归解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开始全局变量 K 保持不变</span></span><br><span class="line">    <span class="keyword">int</span> K = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当节点在最末尾时触发返回</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head.val;</span><br><span class="line">        <span class="comment">// 返回的值</span></span><br><span class="line">        <span class="keyword">int</span> val = kthToLast(head.next, k);</span><br><span class="line">        <span class="comment">// 一旦触发返回，从第一个产生返回的位置用 K 计数</span></span><br><span class="line">        <span class="keyword">if</span> (K++ &gt;= k) &#123;</span><br><span class="line">            <span class="comment">// 当到达或超过倒数第 k 时，即 K &gt;= k 时保持返回值不变</span></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没到达则更新需要返回的值</span></span><br><span class="line">            <span class="keyword">return</span> head.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-03-Delete-Middle-Node"><a href="#LCCI-02-03-Delete-Middle-Node" class="headerlink" title="LCCI.02.03 Delete Middle Node"></a>LCCI.02.03 Delete Middle Node</h2><p>题目：</p><blockquote><p>Implement an algorithm to delete a node in the middle (i.e., any node but the first and last node, not necessarily the exact middle) of a singly linked list, given only access to that node.</p></blockquote><p>这题我并没有想到解法，其实链表的操作不应该被固定思维给限制住。这题可以通过将当前节点替换为下一节点，并将下一节点删除的方式来实现。代码也非常简单。主要考察的是这种思维。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    node.val=node.next.val;</span><br><span class="line">    node.next=node.next.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-04-Partition-List"><a href="#LCCI-02-04-Partition-List" class="headerlink" title="LCCI.02.04 Partition List"></a>LCCI.02.04 Partition List</h2><p>题目：</p><blockquote><p>Write code to partition a linked list around a value x, such that all nodes less than x come before all nodes greater than or equal to x. If x is contained within the list, the values of x only need to be after the elements less than x (see below). The partition element x can appear anywhere in the “right partition”; it does not need to appear between the left and right partitions.</p></blockquote><p>这一题我的思路是通过使用双指针来做，一个指针做遍历，另个指针指向小于x的数据的next。若遍历遇到小于x的值，则将其与小于x的next交换即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p1 = head;</span><br><span class="line">    ListNode p2 = head;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p2.val &lt; x) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = p1.val;</span><br><span class="line">            p1.val = p2.val;</span><br><span class="line">            p2.val = temp;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处需要注意的是，当我尝试使用如下异或来做交换操作时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.val = p1.val^p2.val;</span><br><span class="line">p2.val = p1.val^p2.val;</span><br><span class="line">p1.val = p1.val^p2.val;</span><br></pre></td></tr></table></figure><p>发现在刚开始头指针指向同个对象时，对<code>p1.val</code>和<code>p2.val</code>做异或操作得出的值为0，再将0复制给<code>p1.val</code>，这样使得<code>p2.val</code>同时变为了0，因为<code>p1.val</code>和<code>p2.val</code>指向的是相同的值。</p><h2 id="LCCI-02-05-Sum-Lists"><a href="#LCCI-02-05-Sum-Lists" class="headerlink" title="LCCI.02.05 Sum Lists"></a>LCCI.02.05 Sum Lists</h2><p>题目：</p><blockquote><p>You have two numbers represented by a linked list, where each node contains a single digit. The digits are stored in reverse order, such that the 1’s digit is at the head of the list. Write a function that adds the two numbers and returns the sum as a linked list.</p></blockquote><p>这题一开始我的思路是将链表给合并成整数，再相加，然后再拆成链表。后来看了提示里说尝试用递归，才想到可以用递归来解决这个问题。刚开始的时候，递归写出来了，但是有几个用例总是执行不过，原因是我用的整型变量结果相加之后溢出了，改为了long之后发现还是会溢出。然后想到了不应该用中累加再拆成链表的方式。应该每一个节点算出对应的结果里的节点。递归时直接将节点拼接在一起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum(l1,l2,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">sum</span><span class="params">(ListNode s1, ListNode s2, <span class="keyword">int</span> buy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentLevelSum = s1.val + s2.val + buy;</span><br><span class="line">    ListNode currentNode = <span class="keyword">new</span> ListNode(currentLevelSum % <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (s1.next == <span class="keyword">null</span> &amp;&amp; s2.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentLevelSum / <span class="number">10</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            currentLevelSum = currentLevelSum/<span class="number">10</span>;</span><br><span class="line">            currentNode.next = <span class="keyword">new</span> ListNode(currentLevelSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode;</span><br><span class="line">    &#125;</span><br><span class="line">    s1 = s1.next != <span class="keyword">null</span> ? s1.next : <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    s2 = s2.next != <span class="keyword">null</span> ? s2.next : <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    currentNode.next = sum(s1, s2, currentLevelSum / <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> currentNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看题解中也有没有用递归的，不过也是类似的思想，不能将链表所有的数据都加起来再拆成链表， 那样会导致数据溢出。对于递归的题目我还是不太熟悉，做出来有点难度。</p><h2 id="LCCI-02-06-Palindrome-Linked-List"><a href="#LCCI-02-06-Palindrome-Linked-List" class="headerlink" title="LCCI.02.06  Palindrome Linked List"></a>LCCI.02.06  Palindrome Linked List</h2><p>题目：</p><blockquote><p>Implement a function to check if a linked list is a palindrome.</p></blockquote><p>这题我的思路是采用双指针或者反转整个链表再对比的方式。双指针我没有想到采用快慢指针这种方式，所以用了反转链表，但是没能实现follow up中的O(n)时间和O(1)空间的复杂度。贴上我的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     ListNode p1 = head;</span><br><span class="line">     ListNode a = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">         ListNode b = <span class="keyword">new</span> ListNode(p1.val);</span><br><span class="line">         p1 = p1.next;</span><br><span class="line">         b.next = a;</span><br><span class="line">         a = b;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (a.val != head.val) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         head = head.next;</span><br><span class="line">         a = a.next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-07-Intersection-of-Two-Linked-Lists"><a href="#LCCI-02-07-Intersection-of-Two-Linked-Lists" class="headerlink" title="LCCI.02.07 Intersection of Two Linked Lists"></a>LCCI.02.07 Intersection of Two Linked Lists</h2><p>题目:</p><blockquote><p>Given two (singly) linked lists, determine if the two lists intersect. Return the inter­ secting node. Note that the intersection is defined based on reference, not value. That is, if the kth node of the first linked list is the exact same node (by reference) as the jth node of the second linked list, then they are intersecting.</p></blockquote><p>这题我刚开始没什么好的思路，只有个暴力的算法思想，找不到能在O(n)时间和O(1)空间内解决的办法。看到了提示才想起来先将长度对齐再用双指针同时往后遍历找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p1 = headA;</span><br><span class="line">    ListNode p2 = headB;</span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len1++;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        len2++;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = len1 &gt; len2 ? headA : headB;</span><br><span class="line">    ListNode lag = len1 &gt; len2 ? headB : headA;</span><br><span class="line">    <span class="keyword">int</span> dis = len1 &gt; len2 ? len1 - len2 : len2 - len1;</span><br><span class="line">    <span class="keyword">while</span> (dis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        dis--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast != lag) &#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        lag=lag.next;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-02-08-Linked-List-Cycle"><a href="#LCCI-02-08-Linked-List-Cycle" class="headerlink" title="LCCI.02.08 Linked List Cycle"></a>LCCI.02.08 Linked List Cycle</h2><p>题目：</p><blockquote><p>Given a circular linked list, implement an algorithm that returns the node at the beginning of the loop.</p><p>Circular linked list: A (corrupt) linked list in which a node’s next pointer points to an earlier node, so as to make a loop in the linked list.</p></blockquote><p>这题我一开始没什么好的思路，后来只好用额外的空间将这题解出来了。使用set存储已经遍历过的节点，然后不停的往后将next 节点添加进set中，当发现添加失败时，即为循环的开始点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.add(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看题解和书本上有种解法用的是快慢指针，先用快慢指针判断是否会碰撞，若不会碰撞则不会有循环。再判断快慢指针碰撞的位置。当慢指针到达loop点时，快指针为距离loop点的loopsize-k的位置，k为head距离loop点的距离。因此，当碰撞后，碰撞点距离loop点的距离为k。此时只需将慢指针指向head，快指针从碰撞点开始，二者以不断的next，当再次相等时，即为loop点。</p><h2 id="LCCI-03-01-Three-in-One"><a href="#LCCI-03-01-Three-in-One" class="headerlink" title="LCCI.03.01 Three in One"></a>LCCI.03.01 Three in One</h2><p>题目：</p><blockquote><p>Describe how you could use a single array to implement three stacks.</p><p>Yout should implement push(stackNum, value)、pop(stackNum)、isEmpty(stackNum)、peek(stackNum) methods. stackNum is the index of the stack. value is the value that pushed to the stack.</p><p>The constructor requires a stackSize parameter, which represents the size of each stack.</p></blockquote><p>该题我一开始理解错了题意，并没有找出很好的解决办法。第一反应是将数组拆分为三份。但是我没有理解到构造器传进来的会是每个栈的长度。看了提示里有说使用环形数组来动态构建栈。这个我没有实现出来，感觉难度有点高，劝退了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TripleInOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] stackArray;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> eachStackSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] points = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TripleInOne</span><span class="params">(<span class="keyword">int</span> stackSize)</span> </span>&#123;</span><br><span class="line">            stackArray = <span class="keyword">new</span> <span class="keyword">int</span>[stackSize*<span class="number">3</span>];</span><br><span class="line">            eachStackSize = stackSize ;</span><br><span class="line">            points[<span class="number">0</span>] = eachStackSize;</span><br><span class="line">            points[<span class="number">1</span>] = eachStackSize * <span class="number">2</span>;</span><br><span class="line">            points[<span class="number">2</span>] = eachStackSize * <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isfull</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (points[stackNum] == eachStackSize * stackNum) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isfull(stackNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            points[stackNum] = points[stackNum] - <span class="number">1</span>;</span><br><span class="line">            stackArray[points[stackNum]] = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(stackNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            points[stackNum] = points[stackNum] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> stackArray[points[stackNum] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty(stackNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stackArray[points[stackNum]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (points[stackNum] == eachStackSize * (stackNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-03-02-Min-Stack"><a href="#LCCI-03-02-Min-Stack" class="headerlink" title="LCCI.03.02 Min Stack"></a>LCCI.03.02 Min Stack</h2><p>题目：</p><blockquote><p>How would you design a stack which, in addition to push and pop, has a function min which returns the minimum element? Push, pop and min should all operate in 0(1) time.</p></blockquote><p>这题我的思路是通过数组实现一个堆栈，要求在O(1)时间内返回pop和min，那么就只有用一个指针来记录栈顶和栈中最小值得位置。这么实现的后果是导致这个指针的维护比较复杂，从而在提交的时候报了好几次错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> topPoint = array.length;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> minPoint = array.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * initialize your data structure here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (topPoint == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length * <span class="number">2</span>];</span><br><span class="line">                System.arraycopy(array, <span class="number">0</span>, temp, temp.length - array.length, array.length);</span><br><span class="line">                topPoint = temp.length - array.length;</span><br><span class="line">                minPoint = minPoint + temp.length - array.length;</span><br><span class="line">                array = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            topPoint = topPoint - <span class="number">1</span>;</span><br><span class="line">            array[topPoint] = x;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; array[minPoint]) &#123;</span><br><span class="line">                minPoint = topPoint;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (minPoint == topPoint &amp;&amp; minPoint &lt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">                minPoint = minPoint + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = minPoint ; i &lt; array.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (array[i] &lt; array[minPoint]) &#123;</span><br><span class="line">                        minPoint=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            topPoint = topPoint + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array[topPoint];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array[minPoint];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看书本上这题用的是java本身的Stack类来实现的。再用额外的栈来保存最小值。这样实现起来会简单很多。</p><h2 id="LCCI-03-03-Stack-of-Plates"><a href="#LCCI-03-03-Stack-of-Plates" class="headerlink" title="LCCI.03.03 Stack of Plates"></a>LCCI.03.03 Stack of Plates</h2><p>题目：</p><blockquote><p>Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure SetOfStacks that mimics this. SetOfStacks should be composed of several stacks and should create a new stack once the previous one exceeds capacity. SetOfStacks.push() and SetOfStacks.pop() should behave identically to a single stack (that is, pop() should return the same values as it would if there were just a single stack). Follow Up: Implement a function popAt(int index) which performs a pop operation on a specific sub-stack.</p><p>You should delete the sub-stack when it becomes empty. pop, popAt should return -1 when there’s no element to pop.</p></blockquote><p>这题的思想比较简单，但是代码实现较为复杂。我写了很久没能够通过所有的测试用例。最后参考题解里的答案才写了出来。基本思路跟我的是类似的，但是我在代码实现的时候没能够处理好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackOfPlates</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cap;</span><br><span class="line">        <span class="keyword">private</span> List&lt;Stack&gt; stack = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StackOfPlates</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">            stack.add(<span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">            <span class="keyword">this</span>.cap = cap;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (cap &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()||stack.get(stack.size()-<span class="number">1</span>).size() == cap) &#123;</span><br><span class="line">                stack.add(<span class="keyword">new</span> Stack&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            stack.get(stack.size()-<span class="number">1</span>).push(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> popAt(stack.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">popAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index&lt;<span class="number">0</span> || index &gt;= stack.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Stack&lt;Integer&gt; indexStack = stack.get(index);</span><br><span class="line">            <span class="keyword">if</span> (indexStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> val = indexStack.pop();</span><br><span class="line">            <span class="keyword">if</span> (indexStack.isEmpty()) &#123;</span><br><span class="line">                stack.remove(indexStack);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-03-04-Implement-Queue-using-Stacks"><a href="#LCCI-03-04-Implement-Queue-using-Stacks" class="headerlink" title="LCCI.03.04 Implement Queue using Stacks"></a>LCCI.03.04 Implement Queue using Stacks</h2><p>题目：</p><blockquote><p>Implement a MyQueue class which implements a queue using two stacks.</p></blockquote><p>这题的关键在于队列是先入先出的顺序，而堆栈是后入先出的顺序。因此使用两个堆栈，一个堆栈用于队列的pop和peek，另个队列用于队列的push。这样在需要出队时，只需要将用于push的堆栈出栈再入栈到另个堆栈中。最后使用另个堆栈完成pop和peek即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> Stack&lt;Integer&gt; oldStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">private</span> Stack&lt;Integer&gt; newStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Push element x to the back of queue.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">           newStack.push(x);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (oldStack.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">while</span> (!newStack.isEmpty()) &#123;</span><br><span class="line">                   oldStack.push(newStack.pop());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldStack.pop();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Get the front element.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (oldStack.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">while</span> (!newStack.isEmpty()) &#123;</span><br><span class="line">                   oldStack.push(newStack.pop());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldStack.peek();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Returns whether the queue is empty.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> oldStack.isEmpty() &amp;&amp; newStack.isEmpty();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-03-05-Sort-of-Stacks"><a href="#LCCI-03-05-Sort-of-Stacks" class="headerlink" title="LCCI.03.05 Sort of Stacks"></a>LCCI.03.05 Sort of Stacks</h2><p>题目：</p><blockquote><p>Write a program to sort a stack such that the smallest items are on the top. You can use an additional temporary stack, but you may not copy the elements into any other data structure (such as an array). The stack supports the following operations: push, pop, peek, and isEmpty. When the stack is empty, peek should return -1.</p></blockquote><p>这题跟上面题目类似，采用额外的一个堆栈来存储一部分数据。因为排序的堆栈栈顶是最小的，因此可以用另外个堆栈存小于push的值得数据。然后再把小于的那部分值pop出来，加入到排序堆栈中。一开始我在每次push完后都会将小于当前push值得数据都放回到排序堆栈中，后来看了题解，可以采用懒加载的方式。只在需要pop和peek的时候才做这些工作。这样使得我的运行时间得到了很大的优化，从205ms降到了27ms。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SortedStack</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Stack&lt;Integer&gt; sortedStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> Stack&lt;Integer&gt; tempStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SortedStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sortedStack.isEmpty() &amp;&amp; tempStack.isEmpty()) &#123;</span><br><span class="line">                sortedStack.push(val);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (sortedStack.peek() &lt; val) &#123;</span><br><span class="line">                tempStack.push(sortedStack.pop());</span><br><span class="line">                <span class="keyword">if</span> (sortedStack.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!sortedStack.isEmpty() &amp;&amp; !tempStack.isEmpty() &amp;&amp; sortedStack.peek() &gt; val &amp;&amp;</span><br><span class="line">                    tempStack.peek() &gt; val) &#123;</span><br><span class="line">                sortedStack.push(tempStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            sortedStack.push(val);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!tempStack.isEmpty()) &#123;</span><br><span class="line">                sortedStack.push(tempStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sortedStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sortedStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!tempStack.isEmpty()) &#123;</span><br><span class="line">                sortedStack.push(tempStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sortedStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sortedStack.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sortedStack.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-03-06-Animal-Shelter"><a href="#LCCI-03-06-Animal-Shelter" class="headerlink" title="LCCI.03.06 Animal Shelter"></a>LCCI.03.06 Animal Shelter</h2><p>题目：</p><blockquote><p>An animal shelter, which holds only dogs and cats, operates on a strictly”first in, first out” basis. People must adopt either the”oldest” (based on arrival time) of all animals at the shelter, or they can select whether they would prefer a dog or a cat (and will receive the oldest animal of that type). They cannot select which specific animal they would like. Create the data structures to maintain this system and implement operations such as enqueue, dequeueAny, dequeueDog, and dequeueCat. You may use the built-in Linked list data structure.</p><p>enqueue method has a animal parameter, animal[0] represents the number of the animal, animal[1] represents the type of the animal, 0 for cat and 1 for dog.</p><p>dequeue* method returns [animal number, animal type], if there’s no animal that can be adopted, return [-1, -1].</p></blockquote><p>这题比较简单，思路就是使用LinkedList来将保存数组。然后在取出的时候，遍历链表判断是猫是狗，再将取出的节点删除即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalShelf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> LinkedList&lt;<span class="keyword">int</span>[]&gt; shelter = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] negative = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AnimalShelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span>[] animal)</span> </span>&#123;</span><br><span class="line">            shelter.add(animal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueAny() &#123;</span><br><span class="line">            <span class="keyword">if</span> (shelter.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> negative;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> shelter.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueDog() &#123;</span><br><span class="line">            <span class="keyword">if</span> (shelter.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> negative;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shelter.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shelter.get(i)[<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> shelter.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> negative;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] dequeueCat() &#123;</span><br><span class="line">            <span class="keyword">if</span> (shelter.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> negative;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shelter.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (shelter.get(i)[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> shelter.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> negative;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个需要注意的点就是，LinkedList是可以用来保存数组的，而且不需要是包装类型<code>Integer</code>，直接是原始类型数组即可<code>int[]</code>。</p><h2 id="LCCI-04-01-Route-Between-Nodes"><a href="#LCCI-04-01-Route-Between-Nodes" class="headerlink" title="LCCI.04.01 Route Between Nodes"></a>LCCI.04.01 Route Between Nodes</h2><p>题目：</p><blockquote><p>Given a directed graph, design an algorithm to find out whether there is a route between two nodes.</p></blockquote><p>这题是典型的图的搜索应用场景，可以使用BFS和DFS。使用BFS可以尽快的搜索到需要的目标，因此这题我采用的是BFS。BFS有着典型的实现方式模板，这题我就是套用了模板。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findWhetherExistsPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] graph, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; breathList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer, Set&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : graph) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = ints[<span class="number">0</span>];</span><br><span class="line">            Set&lt;Integer&gt; valueList = temp.computeIfAbsent(key,r-&gt;<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            valueList.add(ints[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; nodeSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        nodeSet.add(start);</span><br><span class="line">        breathList.add(start);</span><br><span class="line">        <span class="keyword">while</span> (!breathList.isEmpty()) &#123;</span><br><span class="line">            Integer first = breathList.removeFirst();</span><br><span class="line">            <span class="keyword">if</span> (first == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从图中获取该节点的所有相关点</span></span><br><span class="line">            Set&lt;Integer&gt; adjacent = temp.get(first);</span><br><span class="line">            <span class="keyword">if</span> (adjacent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : adjacent) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!nodeSet.contains(i)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == target) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        nodeSet.add(i);</span><br><span class="line">                        breathList.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nodeSet.add(first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-02-Minimum-Height-Tree"><a href="#LCCI-04-02-Minimum-Height-Tree" class="headerlink" title="LCCI.04.02 Minimum Height Tree"></a>LCCI.04.02 Minimum Height Tree</h2><p>题目：</p><blockquote><p>Given a sorted (increasing order) array with unique integer elements, write an algo­rithm to create a binary search tree with minimal height.</p></blockquote><p>这题我参考了书本上的解答，才发现可以这么用递归来解决。有点类似与二分法的解答：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTreeNode(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">createTreeNode</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> midIndex = (start + end) / <span class="number">2</span>;</span><br><span class="line">        TreeNode mid = <span class="keyword">new</span> TreeNode(nums[midIndex]);</span><br><span class="line">        mid.left = createTreeNode(nums, start, midIndex - <span class="number">1</span>);</span><br><span class="line">        mid.right = createTreeNode(nums, midIndex + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-03-List-of-Depth"><a href="#LCCI-04-03-List-of-Depth" class="headerlink" title="LCCI.04.03 List of Depth"></a>LCCI.04.03 List of Depth</h2><p>题目：</p><blockquote><p>Given a binary tree, design an algorithm which creates a linked list of all the nodes at each depth (e.g., if you have a tree with depth D, you’ll have D linked lists). Return a array containing all the linked lists.</p></blockquote><p>我的思路是按照广度优先的算法进行遍历，然后将每一层的数据放入到list中。实现起来比我想象的要难一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] listOfDepth(TreeNode tree) &#123;</span><br><span class="line">        List&lt;ListNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ListNode depthPoint = <span class="keyword">new</span> ListNode(tree.val);</span><br><span class="line">        TreeNode head = tree;</span><br><span class="line">        Queue&lt;TreeNode&gt; nextDepList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; tempnextDepList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        nextDepList.add(head);</span><br><span class="line">        <span class="keyword">while</span> (!nextDepList.isEmpty()) &#123;</span><br><span class="line">            tempnextDepList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            TreeNode poll = nextDepList.poll();</span><br><span class="line">            <span class="keyword">if</span> (poll.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                tempnextDepList.add(poll.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (poll.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                tempnextDepList.add(poll.right);</span><br><span class="line">            &#125;</span><br><span class="line">            depthPoint = <span class="keyword">new</span> ListNode(poll.val);</span><br><span class="line">            ListNode a = depthPoint;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode treeNode : nextDepList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    tempnextDepList.add(treeNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    tempnextDepList.add(treeNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">                a.next = <span class="keyword">new</span> ListNode(treeNode.val);</span><br><span class="line">                a = a.next;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(depthPoint);</span><br><span class="line">            nextDepList = tempnextDepList;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode[] resArray = <span class="keyword">new</span> ListNode[res.size()];</span><br><span class="line">        res.toArray(resArray);</span><br><span class="line">        <span class="keyword">return</span> resArray ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-04-Check-Balance"><a href="#LCCI-04-04-Check-Balance" class="headerlink" title="LCCI.04.04 Check Balance"></a>LCCI.04.04 Check Balance</h2><p>题目：</p><blockquote><p>Implement a function to check if a binary tree is balanced. For the purposes of this question, a balanced tree is defined to be a tree such that the heights of the two subtrees of any node never differ by more than one.</p></blockquote><p>一开始想的是用DFS做，看了提示后觉得可以用递归来实现。但是一直没有完成将结果返回出来的处理。参考书本后写出了传递结果的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = checkHeight(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> i != Integer.MIN_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkHeight</span><span class="params">(TreeNode node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">int</span> left = checkHeight(node.left, k);</span><br><span class="line">    <span class="keyword">if</span> (left == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = checkHeight(node.right, k);</span><br><span class="line">    <span class="keyword">if</span> (right == Integer.MIN_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> highAbs = Math.abs(left - right);</span><br><span class="line">    <span class="keyword">if</span> (highAbs &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-05-Legal-Binary-Search-Tree"><a href="#LCCI-04-05-Legal-Binary-Search-Tree" class="headerlink" title="LCCI.04.05 Legal Binary Search Tree"></a>LCCI.04.05 Legal Binary Search Tree</h2><p>题目：</p><blockquote><p>Implement a function to check if a binary tree is a binary search tree.</p></blockquote><p>这题有两个关键点，第一点是要理解清楚二叉搜索树的定义。二叉搜索树要求：<strong>所有</strong>左边的节点小于或等于当前节点，而当前节点必须小于<strong>所有</strong>右边的节点。</p><p>有了这个条件，我们就可以写出满足二叉搜索树的条件：<code>currentNode.left.max&lt;=currentNode&lt;currentNode.right.min</code></p><p>我先参考了书本上的题解，是一种自顶而下的方法。我自己写了个自底向上的解法，需要将返回数据都封装在一个类里，进行结果返回给上一层处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//测试用例中根节点为null时返回true</span></span><br><span class="line">       &#125;</span><br><span class="line">       PacValue res = isBST(root, <span class="keyword">null</span>, root.val);</span><br><span class="line">       <span class="keyword">return</span> res.isRes();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于封装返回结果数据的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">PacValue</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> max;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMax</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.max = max;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> min;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMin</span><span class="params">(<span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.min = min;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRes</span><span class="params">(<span class="keyword">boolean</span> res)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.res = res;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">PacValue <span class="title">isBST</span><span class="params">(TreeNode node, Boolean isMax, Integer preNodeVal)</span> </span>&#123;</span><br><span class="line">       PacValue value = <span class="keyword">new</span> PacValue();</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//递归返回条件</span></span><br><span class="line">       &#125;</span><br><span class="line">       PacValue left = isBST(node.left, <span class="keyword">true</span>, node.val);</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; !left.isRes()) &#123;</span><br><span class="line">           value.setRes(<span class="keyword">false</span>);<span class="comment">//左子树已不满足二叉搜索树时，直接向上传递结果</span></span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">       &#125;</span><br><span class="line">       PacValue right = isBST(node.right, <span class="keyword">false</span>, node.val);</span><br><span class="line">       <span class="keyword">if</span> (right != <span class="keyword">null</span> &amp;&amp; !right.isRes()) &#123;</span><br><span class="line">           value.setRes(<span class="keyword">false</span>);<span class="comment">//右子树已不满足二叉搜索树时，直接向上传递结果</span></span><br><span class="line">           <span class="keyword">return</span> value;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//&lt;editor-fold desc="对于基线条件的处理"&gt;</span></span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">           value.setMax(node.val);<span class="comment">//左右子树都为空，则最大最小值为当前节点的值</span></span><br><span class="line">           value.setMin(node.val);</span><br><span class="line">           value.setRes(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 左子树为空，右子树不为空，若满足当前node小于右子树的最小值，则仍满足二叉搜索树的属性</span></span><br><span class="line"><span class="comment">            * 此时则最大值为右子树的最大值，最小值为当前节点值</span></span><br><span class="line"><span class="comment">            * 注意：此时若不满足属性，则最大值填了右子树最大值是错的，</span></span><br><span class="line"><span class="comment">            * 但是这样没有关系，因为一旦不满足属性递归不会再做处理直接层层向上传递false的结果</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           value.setMax(right.getMax());</span><br><span class="line">           value.setMin(node.val);</span><br><span class="line">           value.setRes(node.val &lt; right.getMin());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;<span class="comment">//类似上一种情况</span></span><br><span class="line">           value.setMax(node.val);</span><br><span class="line">           value.setMin(left.getMin());</span><br><span class="line">           value.setRes(node.val &gt; left.getMax());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 左右子树都不为空，则按照当前节点小于右子树的最小值，并大于左子树的最大值来进行判断是否</span></span><br><span class="line"><span class="comment">            * 满足二叉搜索树的属性</span></span><br><span class="line"><span class="comment">            * 此时，若满足属性则最小值为左子树的最小值，最大值为右子树的最大值。</span></span><br><span class="line"><span class="comment">            * 若不满足属性，此时的最大最小值设置是错的，但是没有关系，不满足属性的结果会直接向上传递。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           value.setRes(node.val &gt; left.getMax() &amp;&amp; node.val &lt; right.getMin());</span><br><span class="line">           value.setMin(left.getMin());</span><br><span class="line">           value.setMax(right.getMax());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//&lt;/editor-fold&gt;</span></span><br><span class="line">       <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-06-Successor-LCCI"><a href="#LCCI-04-06-Successor-LCCI" class="headerlink" title="LCCI.04.06 Successor LCCI"></a>LCCI.04.06 Successor LCCI</h2><p>题目：</p><blockquote><p>Write an algorithm to find the “next” node (i.e., in-order successor) of a given node in a binary search tree.</p><p>Return null if there’s no “next” node for the given node.</p></blockquote><p>这题我第一遍没有做出来，递归写的太复杂。看了书本上的答案也只是给出了伪代码，参考题解后发现有大神给出了很厉害的解法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> searchInorder(root, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode <span class="title">searchInorder</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val &lt;= p.val) &#123;</span><br><span class="line">        TreeNode right = searchInorder(root.right, p);</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode left = searchInorder(root.left, p);</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? root : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我觉得这题的关键在于依赖了完全搜索二叉树的性质，按照中序遍历完全搜索二叉树得出的是一个有序数组。因此访问中序遍历的下个节点，即可理解为访问大于当前节点值得下一个节点。</p><h2 id="LCCI-04-08-First-Common-Ancestor"><a href="#LCCI-04-08-First-Common-Ancestor" class="headerlink" title="LCCI.04.08 First Common Ancestor"></a>LCCI.04.08 First Common Ancestor</h2><p>题目：</p><blockquote><p>Design an algorithm and write code to find the first common ancestor of two nodes in a binary tree. Avoid storing additional nodes in a data structure. NOTE: This is not necessarily a binary search tree</p></blockquote><p>这题我看了题解之后有了思路，其实二叉树搜索的解法与遍历递归的思想是一样的，要么自顶而下，要么自底而上。这一题要找公共祖先，则自顶而下的方法相对容易。于是先开始在根节点的左子树查找，找不到的话再从右子树查找，左右子树都没有则只有返回当前节点了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (containpq(root.left, p, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (containpq(root.right, p, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containpq</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> root != <span class="keyword">null</span> &amp;&amp; forwardFind(root, p, q, <span class="number">0</span>)&gt;=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">forwardFind</span><span class="params">(TreeNode root, TreeNode p, TreeNode q, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    k = forwardFind(root.left, p, q, k);</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">    k = forwardFind(root.right, p, q, k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的实现方法多了一个判断是否存在于子树的递归方法，使得我的解法耗时较长。参考题解，有个大神的解法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这题的思想与我的基本类似，只是作者没有用判断是否存在于子树来作为递归的条件。直接当前节点与p或q相等时返回当前节点。这里不用再继续往下遍历的原因是，若q或p在当前节点的子节点，那么当前节点就是第一个公共父节点。因此可以直接返回。若既不在左子树又不在右子树则直接返回null，通过返回结果是否为null来判断是否在子树中，这样就可以把我的containpq方法的逻辑给合并了。</p><h2 id="LCCI-04-10-Check-SubTree"><a href="#LCCI-04-10-Check-SubTree" class="headerlink" title="LCCI.04.10 Check SubTree"></a>LCCI.04.10 Check SubTree</h2><p>题目：</p><blockquote><p>T1 and T2 are two very large binary trees, with T1 much bigger than T2. Create an algorithm to determine if T2 is a subtree of T1.</p><p>A tree T2 is a subtree of T1 if there exists a node n in T1 such that the subtree of n is identical to T2. That is, if you cut off the tree at node n, the two trees would be identical.</p></blockquote><p>这题主要的要点在于如何理解两个树是相等的，可以采用前序遍历后的结果转换为字符串进行对比。要注意一下：中序遍历即使是不同的结构，也有可能产生相同的结果。但是前序遍历时，只要将为null的节点标识出来即可确定只有相同的树结构才能产生相同的结果。因为前序遍历的第一个节点一定是根节点，可以确定根节点，再确定左右节点，即可保证树的结构相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    StringBuilder a = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    forwardTree(t1, a);</span><br><span class="line">    forwardTree(t2, b);</span><br><span class="line">    <span class="keyword">return</span> a.indexOf(b.toString())!=-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forwardTree</span><span class="params">(TreeNode root, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        stringBuilder.append(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stringBuilder.append(root.val);</span><br><span class="line">    forwardTree(root.left,stringBuilder);</span><br><span class="line">    forwardTree(root.right,stringBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-04-12-Paths-with-Sum"><a href="#LCCI-04-12-Paths-with-Sum" class="headerlink" title="LCCI.04.12 Paths with Sum"></a>LCCI.04.12 Paths with Sum</h2><p>题目：</p><blockquote><p>You are given a binary tree in which each node contains an integer value (which might be positive or negative). Design an algorithm to count the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p></blockquote><p>此题可以参考书本上的解法，先从暴力求解的思路来想，需要将每个节点作为根节点，遍历其至底部节点的路径和。在这个过程中，我们不断重复计算了同个路径下的不同子路径的路径和。将其看成数组，即为求解数组中和为targetSum的区间有几个。我们可以采取类似时间轴的方式，累积每个节点路径和。将其放入到Map中，再用类似twosum的思想，遍历数组的每个节点，能得出距其targetsum的节点数。详细的可以看下书本上的解答。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> countPaths(root, <span class="keyword">new</span> HashMap&lt;&gt;(), sum, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">countPaths</span><span class="params">(TreeNode root, HashMap&lt;Integer, Integer&gt; pathSumValueCount, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> pathSum)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     pathSum = pathSum + root.val;</span><br><span class="line">     <span class="keyword">int</span> totalPath = pathSumValueCount.getOrDefault(pathSum - targetSum, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">if</span> (pathSum == targetSum) &#123;</span><br><span class="line">         totalPath++;</span><br><span class="line">     &#125;</span><br><span class="line">     handlePathSumMap(pathSumValueCount, pathSum, <span class="number">1</span>);</span><br><span class="line">     totalPath += countPaths(root.left, pathSumValueCount, targetSum, pathSum);</span><br><span class="line">     totalPath += countPaths(root.right, pathSumValueCount, targetSum, pathSum);</span><br><span class="line">     handlePathSumMap(pathSumValueCount, pathSum, -<span class="number">1</span>);</span><br><span class="line">     <span class="keyword">return</span> totalPath;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">handlePathSumMap</span><span class="params">(HashMap&lt;Integer, Integer&gt; pathSumValueCount, <span class="keyword">int</span> pathSum, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">     Integer paths = pathSumValueCount.computeIfAbsent(pathSum, s -&gt; <span class="number">0</span>);</span><br><span class="line">     pathSumValueCount.put(pathSum, paths + delta);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-01-Insert-Into-Bits"><a href="#LCCI-05-01-Insert-Into-Bits" class="headerlink" title="LCCI.05.01 Insert Into Bits"></a>LCCI.05.01 Insert Into Bits</h2><p>题目：</p><blockquote><p>You are given two 32-bit numbers, N and M, and two bit positions, i and j. Write a method to insert M into N such that M starts at bit j and ends at bit i. You can assume that the bits j through i have enough space to fit all of M. That is, if M = 10011, you can assume that there are at least 5 bits between j and i. You would not, for example, have j = 3 and i = 2, because M could not fully fit between bit 3 and bit 2.</p></blockquote><p>这题主要考察的是如何通过位运算更新值，取出值。一开始按照书本上的解答做出来发现无法通过一个测试案例，查看评论才发现是当左移位数超过31时，符号位并没有改变。因此需要做一个特殊处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertBits</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> M, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= <span class="number">31</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; j - <span class="number">31</span>; b++) &#123;</span><br><span class="line">            left = left | <span class="number">1</span> &lt;&lt; b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left = ~<span class="number">0</span> &lt;&lt; (j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> right = (<span class="number">1</span> &lt;&lt; (i)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mask = left | right;</span><br><span class="line">    N = N &amp; mask;</span><br><span class="line">    <span class="keyword">return</span> N | (M &lt;&lt; i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-02-Binary-Number-to-String"><a href="#LCCI-05-02-Binary-Number-to-String" class="headerlink" title="LCCI.05.02 Binary Number to String"></a>LCCI.05.02 Binary Number to String</h2><p>题目：</p><blockquote><p>Given a real number between O and 1 (e.g., 0.72) that is passed in as a double, print the binary representation. If the number cannot be represented accurately in binary with at most 32 characters, print “ERROR”.</p></blockquote><p>这题的重点在于怎么理解小数的二进制表达。小数的二进制表达用的是逼近的方式：$$0.625=二进制的0.101=1\times1/2^{1}+0\times1/2^{2}+1\times1/2^{3}=1\times0.5+0\times0.25+1\times0.125$$.因此我们可以使用乘以2的方式来将小数点后的二进制往左移位。因为double类型的数据不支持直接移位运算符<code>&lt;&lt;</code>，所以必须采用乘以2的方式来完成左移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public String printBin(double num) &#123;</span><br><span class="line">    if (num &gt;= 1 || num &lt;= 0) &#123;</span><br><span class="line">        return &quot;ERROR&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = new StringBuilder();</span><br><span class="line">    sb.append(&quot;0.&quot;);</span><br><span class="line">    while (num &gt; 0) &#123;</span><br><span class="line">        if (sb.length() &gt; 32) &#123;</span><br><span class="line">            return &quot;ERROR&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * 2;</span><br><span class="line">        if (num &gt;= 1) &#123;</span><br><span class="line">            sb.append(&quot;1&quot;);</span><br><span class="line">            num = num - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            sb.append(&quot;0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-03-Reverse-Bits"><a href="#LCCI-05-03-Reverse-Bits" class="headerlink" title="LCCI.05.03 Reverse Bits"></a>LCCI.05.03 Reverse Bits</h2><p>题目：</p><blockquote><p>You have an integer and you can flip exactly one bit from a 0 to a 1. Write code to find the length of the longest sequence of 1s you could create.</p></blockquote><p>此题的关键在于如何找出将一位0翻转为1后，连续的1最长的方法。参考书本答案后，给出如下解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (~num == <span class="number">0</span>) <span class="keyword">return</span> Integer.BYTES * <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">int</span> currentCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> prveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            currentCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                prveCount = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prveCount = currentCount;</span><br><span class="line">            &#125;</span><br><span class="line">            currentCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxCount = Math.max(prveCount + currentCount + <span class="number">1</span>, maxCount);</span><br><span class="line">        num = num &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-04-Closed-Number"><a href="#LCCI-05-04-Closed-Number" class="headerlink" title="LCCI.05.04 Closed Number"></a>LCCI.05.04 Closed Number</h2><p>题目:</p><blockquote><p>Given a positive integer, print the next smallest and the next largest number that have the same number of 1 bits in their binary representation.</p></blockquote><p>此题的重点是要知道怎么分析问题，题目要求取出最相近的两个数。那么大的那个数应该是最右边非尾部的0变为1（假设为第i位），再在i的右边，从右往左插入n-1个1（n为i右边的1的个数）。</p><p>小的那个数应该是最右边非尾部的1变为0（假设为第j位），再在j的右边，从左往右插入m+1个1（m为j右边的1的个数）。</p><p>题目分析清楚后就是代码实现，代码实现的时候又很多细节需要注意，都写在注释里了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findClosedNumbers(<span class="keyword">int</span> num) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">      <span class="keyword">if</span> (num == <span class="number">0</span> || num == (~<span class="number">0</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">      &#125;</span><br><span class="line">      res[<span class="number">0</span>] = getNext(num);</span><br><span class="line">      res[<span class="number">1</span>] = getPrev(num);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPrev</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">boolean</span> find0 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.BYTES * <span class="number">8</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>) &#123;</span><br><span class="line">              find0 = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (((num &amp; (<span class="number">1</span> &lt;&lt; i)) == (<span class="number">1</span> &lt;&lt; i))) &#123;</span><br><span class="line">              count++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (((num &amp; (<span class="number">1</span> &lt;&lt; i)) == (<span class="number">1</span> &lt;&lt; i)) &amp;&amp; find0) &#123;</span><br><span class="line">              <span class="comment">//将i位变为0  将i位右边全置为0 再添加count+1位的1</span></span><br><span class="line">              res = num &amp; (~(<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                  res = res &amp; (~(<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">//由于count计数的时候将当前的1包含进去了，所以往右边添加1时不需要再将count+1了</span></span><br><span class="line">                  res = res | (<span class="number">1</span> &lt;&lt; (i - j));</span><br><span class="line">                  j++;</span><br><span class="line">                  count--;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">boolean</span> find1 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> findFirstNotTail0 = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.BYTES * <span class="number">8</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((num &amp; (<span class="number">1</span> &lt;&lt; i)) == (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">              count++;</span><br><span class="line">              find1 = <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//出现1之后的第一个0置为1，将该位右边全置为0，再从右往左放入count-1个1</span></span><br><span class="line">              <span class="keyword">if</span> (find1) &#123;</span><br><span class="line">                  res = num | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> k = i-<span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                      res = res &amp; (~(<span class="number">1</span> &lt;&lt; k));</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">while</span> ((count-<span class="number">1</span> ) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      res = res | (<span class="number">1</span> &lt;&lt;  j);</span><br><span class="line">                      count--;</span><br><span class="line">                      j++;</span><br><span class="line">                  &#125;</span><br><span class="line">                  findFirstNotTail0 = <span class="keyword">true</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!findFirstNotTail0) &#123;</span><br><span class="line">          res = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-06-Convert-Interger"><a href="#LCCI-05-06-Convert-Interger" class="headerlink" title="LCCI.05.06 Convert Interger"></a>LCCI.05.06 Convert Interger</h2><p>题目：</p><blockquote><p>Write a function to determine the number of bits you would need to flip to convert integer A to integer B.</p></blockquote><p>这题很容易就可以想到用异或来做，两个数相异或后，再取出异或后的数字中1的个数作为结果返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">convertInteger</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> C = A ^ B;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (C != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((C &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        C &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-07-Exchange"><a href="#LCCI-05-07-Exchange" class="headerlink" title="LCCI.05.07 Exchange"></a>LCCI.05.07 Exchange</h2><p>题目：</p><blockquote><p>Write a program to swap odd and even bits in an integer with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on).</p></blockquote><p>这题主要的思想在于需要取出奇数位和偶数位，再将奇数位逻辑右移1位，将偶数位左移1位。然后再二者相或即可得出交换后的值。此处需要注意的是用于取奇数位和偶数位的掩码怎么运算的。二进制的1010代表的是十进制的10，在十六进制中则是0xA。因此用于取奇数位的掩码则是0xAAAAAAAA，则取偶数位的掩码为0x55555555，或者用<code>~0xAAAAAAAA</code>也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oddMask = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">    <span class="keyword">int</span> oddNumber = num &amp; oddMask;</span><br><span class="line">    <span class="keyword">int</span> evenMask = ~<span class="number">0xAAAAAAAA</span>;</span><br><span class="line">    <span class="keyword">int</span> evenNumber = num &amp; evenMask;</span><br><span class="line">    <span class="keyword">return</span> (oddNumber &gt;&gt;&gt; <span class="number">1</span>) | (evenNumber &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-05-08-Draw-Line"><a href="#LCCI-05-08-Draw-Line" class="headerlink" title="LCCI.05.08 Draw Line"></a>LCCI.05.08 Draw Line</h2><p>题目：</p><blockquote><p>A monochrome screen is stored as a single array of int, allowing 32 consecutive pixels to be stored in one int. The screen has width w, where w is divisible by 32 (that is, no byte will be split across rows). The height of the screen, of course, can be derived from the length of the array and the width. Implement a function that draws a horizontal line from (x1, y) to (x2, y).</p><p>Given the length of the array, the width of the array (in bit), start position x1 (in bit) of the line, end position x2 (in bit) of the line and the row number y of the line, return the array after drawing.</p></blockquote><p>这题的重点在于需要理解清楚题目的意思。我采用了简单的将x1至x2区间内的0置为1的方法。这种解法实现起来较为简单，但是效率不高。使用掩码将x1和x2之间的整数1的位置整个置为1的效率更高。当然要考虑x1和x2处于同一区间中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] drawLine(<span class="keyword">int</span> length, <span class="keyword">int</span> w, <span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] screen = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> startIndex = (y * w + x1) / <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> startBitIndex = (y * w + x1) % <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">int</span> total = x2 - x1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startBitIndex; i &lt; <span class="number">32</span> &amp;&amp; total &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            current = current | (<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - i));</span><br><span class="line">            total--;</span><br><span class="line">        &#125;</span><br><span class="line">        screen[startIndex++] = current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        startBitIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> screen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-01-Three-Steps-Problem"><a href="#LCCI-08-01-Three-Steps-Problem" class="headerlink" title="LCCI.08.01 Three Steps Problem"></a>LCCI.08.01 Three Steps Problem</h2><p>题目：</p><blockquote><p>A child is running up a staircase with n steps and can hop either 1 step, 2 steps, or 3 steps at a time. Implement a method to count how many possible ways the child can run up the stairs. The result may be large, so return it modulo 1000000007.</p></blockquote><p>做题最重要的果然还是看清楚题目，然后再写出解法。这题我一开始想的过于简单，以为是需要用乘法，实则不然。只需要<code>f(n)=f(n-1)+f(n-2)+f(n-3)</code>这个基线条件即可写出递归。但是由于测试案例中的数据量很大，因此需要处理数据溢出和递归深度的问题。后来改为了动态规划的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToStep</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        d = ((a + b)%mod + c)%mod;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c=d;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-02-Robot-in-a-Grid"><a href="#LCCI-08-02-Robot-in-a-Grid" class="headerlink" title="LCCI.08.02  Robot in a Grid"></a>LCCI.08.02  Robot in a Grid</h2><p>题目：</p><blockquote><p>Imagine a robot sitting on the upper left corner of grid with r rows and c columns. The robot can only move in two directions, right and down, but certain cells are “off limits” such that the robot cannot step on them. Design an algorithm to find a path for the robot from the top left to the bottom right.</p></blockquote><p>这题的关键在于如何理解基线条件。需要自底向上的思考，找到最后一个需要一步步的往前找到倒数第二个，倒数第三个。然后遇到1的时候则返回失败。再对其失败的路线进行缓存，即是动态规划。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathWithObstacles(<span class="keyword">int</span>[][] obstacleGrid) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid == <span class="keyword">null</span> || obstacleGrid.length == <span class="number">0</span>|| obstacleGrid[<span class="number">0</span>]==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    HashSet&lt;List&lt;Integer&gt;&gt; failed = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (getPath(res, failed, obstacleGrid, obstacleGrid.length - <span class="number">1</span>, obstacleGrid[<span class="number">0</span>].length - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getPath</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, HashSet&lt;List&lt;Integer&gt;&gt; failed, <span class="keyword">int</span>[][] obstacleGrid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || (obstacleGrid[r][c] ==<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    List point = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    point.add(r);</span><br><span class="line">    point.add(c);</span><br><span class="line">    <span class="keyword">if</span> (failed.contains(point)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> isAtSourse = (r == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (isAtSourse || getPath(res, failed, obstacleGrid, r - <span class="number">1</span>, c) || getPath(res, failed, obstacleGrid, r, c - <span class="number">1</span>)) &#123;</span><br><span class="line">        res.add(point);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    failed.add(point);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LCCI-08-03-Magic-Index"><a href="#LCCI-08-03-Magic-Index" class="headerlink" title="LCCI.08.03 Magic Index"></a>LCCI.08.03 Magic Index</h2><p>题目：</p><blockquote><p>A magic index in an array A[0…n-1] is defined to be an index such that A[i] = i. Given a sorted array of distinct integers, write a method to find a magic index, if one exists, in array A. If not, return -1. If there are more than one magic index, return the smallest one.</p></blockquote><p>此题最简单的解法当然是用数组遍历，但是因为题目给出的条件是有序数组，因此可以利用排序来做。此题可以用递归实现二分法来解决。测试用例中存在重复的元素，因此需要处理下重复的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMagicIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> binaryFind(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">binaryFind</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">         <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">         <span class="keyword">return</span> mid;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> leftres = binaryFind(nums, start, mid - <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (leftres != -<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> leftres;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> binaryFind(nums, mid + <span class="number">1</span>, end);;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意：当题目中给出了有序的条件时，一般来说这个条件是可以加以利用的。</p><h2 id="LCCI-08-04-Power-Set"><a href="#LCCI-08-04-Power-Set" class="headerlink" title="LCCI.08.04 Power Set"></a>LCCI.08.04 Power Set</h2><p>题目：</p><blockquote><p>Write a method to return all subsets of a set. The elements in a set are pairwise distinct.</p><p>Note: The result set should not contain duplicated subsets.</p></blockquote><p>此题类似与之前的三步问题，关键点在于找到基线条件：数组nums的子集为数组nums[n-1]的子集，将其复制一份然后每个加上nums[n]的元素即可。代码实现较为简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        getSubSets(nums, nums.length-<span class="number">1</span>, sets);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(sets);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSubSets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, Set&lt;List&lt;Integer&gt;&gt; sets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            sets.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getSubSets(nums, --i, sets);</span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; integerList : sets) &#123;</span><br><span class="line">            List&lt;Integer&gt; inn = <span class="keyword">new</span> ArrayList&lt;&gt;(integerList);</span><br><span class="line">            inn.add(nums[i+<span class="number">1</span>]);</span><br><span class="line">            temp.add(inn);</span><br><span class="line">        &#125;</span><br><span class="line">        sets.addAll(temp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看了题解中还有种解法是通过位来表示数组中的数字，这种思路很巧妙，不需要使用递归，直接将每个组合都打印出来即可。贴出题解：</p><blockquote><p>例如 [1, 2, 3] 有三位可以从 0 遍历到 7 也就是 2 ^ 3 - 1 用二进制表示就是 000, 001, 010, 011, 100, 101, 110, 111 正好代表了全部子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">&gt;         List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&gt;         <span class="keyword">int</span> bmp = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, nums.length);</span><br><span class="line">&gt;         <span class="comment">// 从 nums.length 个 0 遍历到 nums.length 个 1</span></span><br><span class="line">&gt;         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bmp; i++) &#123;</span><br><span class="line">&gt;             List&lt;Integer&gt; subset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&gt;             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)</span><br><span class="line">&gt;                 <span class="comment">// 将每一位右移最低位，检测其是否为1</span></span><br><span class="line">&gt;                 <span class="keyword">if</span> ((i &gt;&gt;&gt; j &amp; <span class="number">1</span>) == <span class="number">1</span>) subset.add(nums[j]);</span><br><span class="line">&gt;             subsets.add(subset);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> subsets;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="LCCI-08-05-Recursive-Multiply"><a href="#LCCI-08-05-Recursive-Multiply" class="headerlink" title="LCCI.08.05 Recursive Multiply"></a>LCCI.08.05 Recursive Multiply</h2><p>题目：</p><blockquote><p>Write a recursive function to multiply two positive integers without using the * operator. You can use addition, subtraction, and bit shifting, but you should minimize the number of those operations.</p></blockquote><p>这题有多种解法，我看了提示之后，写出了提示的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> C = B &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> multiply(A, C) + multiply(A, B - C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><ul><li>最重要的是要理解清楚题目的意思！！！</li><li>字符串的调换位置、去重、判断奇偶操作这种类型的题目可以考虑将采取哈希映射为数组，或者bit位。用位操作来完成最后的识别判断。注意，当有顺序要求，不能去重统计时则不适用于哈希映射法。</li><li>双指针类问题，需要仔细分清不同 代码分支情况，一条条的梳理清楚。</li><li>对字符数组遍历，边界问题的测试需要考虑到字符长度为1，为0，遍历到尾部最后一个字符的处理逻辑；可以尝试通过在字符的最后补了一位来规避遍历时处理最后一个字符的特殊情况。</li><li>链表的删除可以考虑使用后续节点代替当前节点</li><li>在两个引用指向相同对象的，若想对两个对象内的数值进行互换不能采用异或操作。否则会导致结果为0。</li><li>遇到栈相关的问题，一般可以考虑使用临时的另一个栈来完成题目对于栈的顺序要求。</li><li>ArrayList和LinkedList的toArray方法并不能直接转换为数组，否则会报错。可以新建个数组，在使用<code>toArray(新数组)</code>的方法来实现转换为数组。</li><li>递归可以通过返回特定值来向上传递某种结果退出递归。</li><li><strong>递归题目，首要条件是要找到基准条件。找到之后可以分为自底向上和自顶而下两种写法，自底向上是将每一层的处理结果返回给上一层处理，每层在调用完递归后处理自己本层逻辑再返回。自顶而下则是先对自己本层的逻辑进行处理，然后再将数据封装到参数中递交给下一层处理。不管是自底向上还是自顶而下，都需要对返回条件进行特殊处理！</strong></li><li><strong>树的查找类问题，思考方向与递归遍历类似，应该是自顶而下或者自底而上。做优化时可以考虑如何将重复的递归逻辑给进行合并</strong></li><li>中等难度的问题基本都是将题目分析出来，再将思路编码出来。分析可以由暴力逐步优化，编码能力需要不断刷题实践。</li><li>当题目给出有序的条件时，这个条件利用好一般会有很好的效果。</li><li>在递归时，若发现可以缓存的数据，可以想办法通过数组或hash表来进行缓存，当然在缓存的时候也需要考虑内存是否会过大超出限制，这也是实现动态规划的一种方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode记录总结&quot;&gt;&lt;a href=&quot;#LeetCode记录总结&quot; class=&quot;headerlink&quot; title=&quot;LeetCode记录总结&quot;&gt;&lt;/a&gt;LeetCode记录总结&lt;/h1&gt;&lt;p&gt;本文章主要记录LeetCode刷题学到的知识&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search</title>
    <link href="http://yoursite.com/2019/08/03/Binary%20Search/"/>
    <id>http://yoursite.com/2019/08/03/Binary Search/</id>
    <published>2019-08-03T08:28:39.000Z</published>
    <updated>2020-03-30T15:09:43.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h1><p>This is a summary of binary search algorithm.</p><a id="more"></a><h2 id="Item-1-need-find-a-number-is-exactly-equal-to-the-target"><a href="#Item-1-need-find-a-number-is-exactly-equal-to-the-target" class="headerlink" title="Item 1: need find a number is exactly equal to the target"></a>Item 1: need find a number is exactly equal to the target</h2><p>This circumstances we can use this schema:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s &lt;= e) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (num[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[mid] &gt; target) &#123;</span><br><span class="line">                e = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num[mid] &lt; target) &#123;</span><br><span class="line">                s = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>the recusive schema:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">recusiveBinarySearch</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (s &gt; e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (num[mid] == target) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[mid] &gt; target) &#123;</span><br><span class="line">           <span class="keyword">return</span> recusiveBinarySearch(num, s, mid - <span class="number">1</span>, target);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> recusiveBinarySearch(num, mid + <span class="number">1</span>, e, target);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>the break condition is <code>s&gt;e</code>,the expression is <code>f(s-e)=f(s-mid)||f(s-e)=f(mid-e)</code>.</p><h2 id="Item-2-find-first-no-less-than-target"><a href="#Item-2-find-first-no-less-than-target" class="headerlink" title="Item 2: find first no less than target"></a>Item 2: find first no less than target</h2><p>To find no less than target value , we should use following schema:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">               s = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//end point is no less than target(&gt;=target)</span></span><br><span class="line">               e = mid;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> e;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>this shcema need the end point equal to array’s length , when <code>e==length</code> , it indicate the target value is greater than the array’s biggest element. when <code>e==0</code>, it means that the target value is less than the array’s smallest one.</p><p>Besides, this Item have a variant, which is  <strong>find last less than target value</strong>. we can solve this proble by return <code>e-1</code>.Note that </p><h2 id="Item-3-find-first-greater-than-target"><a href="#Item-3-find-first-greater-than-target" class="headerlink" title="Item 3: find first greater than target"></a>Item 3: find first greater than target</h2><p>when you want to find first greater than target value , just change the condition is ok.use <code>nums[mid]&lt;=target</code> ,you can solve this problem.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s &lt; e) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (s + e) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                s = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//end point is greater than target(&gt;target)</span></span><br><span class="line">                e = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>now, the end point is greater than the target value.if  <code>e == length</code> , then array doesn’t exist a element greater than target.</p><h2 id="Item-4-Use-subfunction-as-the-conditions"><a href="#Item-4-Use-subfunction-as-the-conditions" class="headerlink" title="Item 4: Use subfunction as the conditions"></a>Item 4: Use subfunction as the conditions</h2><h2 id="Citations"><a href="#Citations" class="headerlink" title="Citations"></a>Citations</h2><p><a href="https://www.cnblogs.com/grandyang/p/6854825.html" target="_blank" rel="noopener">LeetCode Binary Search Summary 二分搜索法小结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Binary-Search&quot;&gt;&lt;a href=&quot;#Binary-Search&quot; class=&quot;headerlink&quot; title=&quot;Binary Search&quot;&gt;&lt;/a&gt;Binary Search&lt;/h1&gt;&lt;p&gt;This is a summary of binary search algorithm.&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第十二周</title>
    <link href="http://yoursite.com/2019/07/21/ARTS-12/"/>
    <id>http://yoursite.com/2019/07/21/ARTS-12/</id>
    <published>2019-07-21T12:28:39.000Z</published>
    <updated>2020-03-30T15:09:43.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第十二周"><a href="#ARTS第十二周" class="headerlink" title="ARTS第十二周"></a>ARTS第十二周</h1><p>本次ARTS主要包括：853题（car fleet）算法题；《effective java》中关于接口应该只被用来定义类型和通过继承来实现标志类，以及关于内部类的使用和类的命名；关于DDIA的部分阅读后真理的脑图。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="524"><li>car fleet</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">carFleet</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] position, <span class="keyword">int</span>[] speed)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> cars = position.length;</span><br><span class="line">        <span class="keyword">if</span> (cars &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cars;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Double&gt; posiSpeedMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cars; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> distence = target - position[i];</span><br><span class="line">            <span class="keyword">double</span> time =(<span class="keyword">double</span>) distence / (<span class="keyword">double</span>) speed[i] ;</span><br><span class="line">            posiSpeedMap.put(position[i], time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//from farest to earliest car</span></span><br><span class="line">        Arrays.sort(position);</span><br><span class="line">        <span class="keyword">int</span> res = cars;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cars - <span class="number">1</span>; i &gt;<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (posiSpeedMap.get(position[i]) &gt;= posiSpeedMap.get(position[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                position[i - <span class="number">1</span>] = position[i];</span><br><span class="line">                res--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个问题换个角度思考，按照起始位置排列的汽车，远的那辆到达终点的时间比近的那辆到达终点的时间要短的话，那么必然会在途中产生一个fleet。有个需要注意的地方是，在追上前面那辆车之后，车速会被限制跟前车相同，此时则需考虑后车若快于被限制之后的情况。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 22: Use interfaces only to define types</p><blockquote><ul><li>When a class implements an interface, the interface serves as a <em>type</em> that can be used to refer to instances of the class. </li><li>The constant interface pattern is a poor use of interfaces.It is of no consequence to the users of a class that the class implements a constant interface. In fact, it may even confuse them. Worse, it represents a commitment: if in a future release the class is modified so that it no longer needs to use the constants, it still must implement the interface to ensure binary compatibility. If a nonfinal class implements a constant interface, all of its subclasses will have their namespaces polluted by the constants in the interface.</li><li>If you want to export constants, there are several reasonable choices. If the constants are strongly tied to an existing class or interface, you should add them to the class or interface.</li></ul></blockquote></li><li><p>Item 23: Prefer class hierarchies to tagged classes</p><blockquote><ul><li>Tagged classes are verbose, error-prone, and ineficient.</li><li>In summary, tagged classes are seldom appropriate. If you’re tempted to write a class with an explicit tag field, think about whether the tag could be eliminated and the class replaced by a hierarchy. When you encounter an existing class with a tag field, consider refactoring it into a hierarchy.</li></ul></blockquote></li><li><p>Item 24: Favor static member classes over nonstatic</p><blockquote><ul><li>If you declare a member class that does not require access to an enclosing instance, always put the static modifier in its declaration.If you omit this modifier, each instance will have a hidden extraneous reference to its enclosing instance.</li><li>To recap , there are four different kinds of nested classes, and each has its place. If a nested class needs to be visible outside of a single method or is too long to fit comfortably inside a method, use a member class.If each instance of a member class needs a referenece to its enclosing instance, make it nonstatic; otherwise, make it static. Assuming the class belongs inside a method, if you need to create instances from only one location and there is a preexisting type that characterizes the class, make if an anonymous class;otherwise, make it a local class.</li></ul></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>无</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><img src="/2019/07/21/ARTS-12/微信截图_20190721231103.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第十二周&quot;&gt;&lt;a href=&quot;#ARTS第十二周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第十二周&quot;&gt;&lt;/a&gt;ARTS第十二周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：853题（car fleet）算法题；《effective java》中关于接口应该只被用来定义类型和通过继承来实现标志类，以及关于内部类的使用和类的命名；关于DDIA的部分阅读后真理的脑图。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第十一周</title>
    <link href="http://yoursite.com/2019/06/30/ARTS-11/"/>
    <id>http://yoursite.com/2019/06/30/ARTS-11/</id>
    <published>2019-06-30T12:28:39.000Z</published>
    <updated>2020-03-30T15:09:43.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第十一周"><a href="#ARTS第十一周" class="headerlink" title="ARTS第十一周"></a>ARTS第十一周</h1><p>本次ARTS主要包括：564题（通过删除匹配到字典里最长的单词）和767题（重构字符串）算法题；《effective java》中关于类的最小可修改和接口优于继承的内容。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="524"><li>Longest word in Dictionary through Deleting</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length()&lt;=<span class="number">0</span>||d.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(d, <span class="keyword">new</span> compareSpecial());</span><br><span class="line">        <span class="keyword">for</span> (String word : d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSubStr(s,word)) &#123;</span><br><span class="line">                <span class="keyword">return</span> word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubStr</span><span class="params">(String s, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word==<span class="string">""</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=s.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!(s.charAt(j) == word.charAt(i))) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= s.length()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">compareSpecial</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.length() &gt; o2.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.length() == o2.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体的思想是，通过自定义的Comparator实现由大到小先按照字符的长度，再按照字典顺序排序。将整个数组里的字符串都排序好，再遍历给定的字符串s和数组里的单个单词进行字符匹配。</p><blockquote><ol start="767"><li>Reorganize String </li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reorganizeString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = S.length();</span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: S.toCharArray()) counts[c-<span class="string">'a'</span>] += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) counts[i] += i;</span><br><span class="line">    <span class="comment">//Encoded counts[i] = 100*(actual count) + (i)</span></span><br><span class="line">        Arrays.sort(counts);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] ans = <span class="keyword">new</span> <span class="keyword">char</span>[N];</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> code: counts) &#123;</span><br><span class="line">        <span class="keyword">int</span> ct = code / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = (<span class="keyword">char</span>) (<span class="string">'a'</span> + (code % <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">if</span> (ct &gt; (N+<span class="number">1</span>) / <span class="number">2</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ct; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t &gt;= N) t = <span class="number">0</span>;</span><br><span class="line">            ans[t] = ch;</span><br><span class="line">            t += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一题没做出来，采用的是讨论区一位前辈的思想。大体上运用了计数排序的思想，不过这个解法有两个点很厉害：一是采用乘100，再加上数组下标的方式，来保存排序前每个数组下标的值，方便排序后转换为字符。另一个是采用循环数组的方法将每个字符放到字符串对应的位置上。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 19: Design and document for inheritance or else prohibit it</p><blockquote><ul><li>First, the class must document its self-use of override methods;</li><li>a class may have to provide hooks into its internal working in the form of judiciously chosen protected methods;</li><li>The onlt way to test a class designed for inheritance is to write subclasses;</li><li>Constructors must not invoke overridable methods, directly or indirectly;</li><li>Prohibit subclassing in classes that are not designed and documented to be safety subclassed. One way to prohibit subclassing is declare the class final. The Second is make all constructors private or package-private and to add public static factories in place of the constructors.</li></ul></blockquote></li><li><p>Item 20: Prefer interfaces to abstract classes</p><blockquote><ul><li>Existing classes can easily be retrofitted to implement a new interface.</li><li>To summarize, an interface is generally the best way to define a type that permits multiple implementations. If you export a nontrivial interface, you should strongly consider providing a skeletal implementation to go with it. To the extent possible, you should provide the skeletal implementation via default methods on the interface so that all implementors of the interface can make use of it. That said, restrictions on interfaces typically mandate that a skeletal implementation take the form of an abstract class.</li></ul></blockquote></li><li><p>Item 21: Design interface for posterity</p><blockquote><ul><li>Java 8 provide <em>default</em> to allow the addition of  method to  existing interfaces.But it is <strong><em>fraught</em></strong> !</li><li>The declaration for a default method includes a default implementation that is used by all classes that implement the interface but not implement the default method.</li><li>In the presence of default methods, existing implementations of an interface  may compile without error or warning but fail at runtime.</li><li>Using default methods to add new methods should be avoided unless the need is critical, in which case you should think long and hard about whether an existing interface implementation might be broken by your default method implementation.</li><li>It may be possible to correct some interface flaws after an interface is released , But you cannot count on it.</li></ul></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>无</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第十一周&quot;&gt;&lt;a href=&quot;#ARTS第十一周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第十一周&quot;&gt;&lt;/a&gt;ARTS第十一周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：564题（通过删除匹配到字典里最长的单词）和767题（重构字符串）算法题；《effective java》中关于类的最小可修改和接口优于继承的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第十周</title>
    <link href="http://yoursite.com/2019/06/19/ARTS-10/"/>
    <id>http://yoursite.com/2019/06/19/ARTS-10/</id>
    <published>2019-06-19T14:28:39.000Z</published>
    <updated>2020-03-30T15:09:43.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第十周"><a href="#ARTS第十周" class="headerlink" title="ARTS第十周"></a>ARTS第十周</h1><p>本次ARTS主要包括：78题（颜色分类）和179题（最大数）算法题；《effective java》中关于类的最小可修改和接口优于继承的内容；《vim编程技巧》中关于在插入模式即时更正错误操作。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="78"><li>颜色分类</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        recurisionFastOrder(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurisionFastOrder</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pivot =  nums[end];</span><br><span class="line">        <span class="keyword">int</span> i=start;</span><br><span class="line">        <span class="comment">// int j =start;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start;j&lt;end;j++)&#123;</span><br><span class="line">            <span class="comment">//j指向的数字小于中枢点时 则需要与i交换，同时i往后移，保证从i到j都是大于中枢点的值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;pivot)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = pivot;</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        recurisionFastOrder(nums,start,i-<span class="number">1</span>);</span><br><span class="line">        recurisionFastOrder(nums,i+<span class="number">1</span>,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我得解法与题解给的不同，用的是快排的算法，快排的递推公式为：<code>f(p,r)=f(p,q-1)+f(q+1,r)</code>.其中的q为中枢点。将整个排序的数据分为两部分，[p,q-1]为小于q的部分，[q+1,r]为大于q的部分。剩下的就是确定中枢点的位置了。快排算法是使用两个指针i和j，一个从头开始遍历，当遇到比尾部的值小的时候，则将两个指针的值交换，并将两个指针都往后移一步。这样保持从i到j之间的区间一直都是大于尾部的值的。一次遍历完成后，将i指针的值与尾部的值交换，i点则为中枢点。</p><blockquote><ol start="179"><li>最大数</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(nums[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span>[] res = sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder re = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;res.length;i++)&#123;</span><br><span class="line">            re.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并排序的递推公式为：A[p,r] = merge(A[p,q],A[q+1,r]);</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> p , <span class="keyword">int</span> r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&gt;=r)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] temp = &#123;nums[r]&#125;;</span><br><span class="line">            <span class="keyword">return</span> temp ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q = (p+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] a = sort(nums,p,q);</span><br><span class="line">        <span class="keyword">int</span>[] b = sort(nums,q+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">int</span>[] res = merge(a,a.length,b,b.length);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并a，b两个有序数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] a ,<span class="keyword">int</span> m, <span class="keyword">int</span>[] b,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m &amp;&amp; j&lt;n)&#123;</span><br><span class="line">            res[k]=compare(a[i],b[j])?a[i++]:b[j++];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;m)&#123;</span><br><span class="line">          System.arraycopy(a,i,res,k,m-i);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;n)&#123;</span><br><span class="line">            System.arraycopy(b,j,res,k,n-j);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义比较大小的规则 x&gt;y return true</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">              StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb.append(x).append(y);</span><br><span class="line">        Long a = Long.valueOf(sb.toString());</span><br><span class="line">        </span><br><span class="line">                     StringBuilder sb2 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb2.append(y).append(x);</span><br><span class="line">         Long b = Long.valueOf(sb2.toString());</span><br><span class="line">        <span class="keyword">return</span> a&gt;=b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题的核心思想在于自定义排序规则，一开始没想想到，看了题解才知道的。我是故意想着用合并排序的方法来做，练习下写合并排序的代码。合并排序的主要点在于两个：递推公式和合并有序数组；递推公式为：<code>f(p,r)=merge(f(p,q),f(q+1,r))</code>;合并有序数组就比较简单了，类似leetcode第88题的解法。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 17：Minimize mutability</p><blockquote><ol><li>To make a class immutable, follow these rules:<ul><li>Don’t provide methods that modify the object’s state .</li><li>Ensure that the class can’t be extended.</li><li>Make all fields private and final.</li><li>Ensure exclusive access to any mutable components.</li></ul></li><li>Immutable objects are inherently thread-safe; they required no synchronization. Besides, they can be shared freely, you never have to make <em>defensive copies</em> of them.</li><li>The major disadvantage of immutable classes is that they require a separate object for each distinct value , even if they are diffrent at one bit.</li><li>To guarantee immutability, instaed of making the class final , you can make all of its constructors private or package-private and  add pbulic static factorices in place of the public constructor.</li><li>To summarize, classes should be immutable unless there’s a compelling reason to make them mutable.<strong><em>Combining this item with item 15, your natural inclination should be to declare every field private final unless there are compelling reson to do otherwise.</em></strong></li></ol></blockquote></li><li><p>Item 18 : Favor composition over inheritance</p><blockquote><ol><li>Inheritance used inappropriately, it leads to fragile software.<strong>Unlike method invocation, inheritance violates encapsulation.</strong> A subclass depends on the implementation detail of its superclass for its proper function. The superclass’s implementation may change from release to release.</li><li>Instead of extending an existing class, give your new class a private field that references an instance of the existing class, give your new class a private field that references an instance of the existing class. This design is called <strong>composition</strong>. This is known as forwarding, and the methods in the new class are known as forwarding methods. This is also known as the <strong><em>Decorator</em></strong> pattern.</li><li>Inheritance is appropriate only in circumstances where the subclass really is a subtype of the superclass.In the other words, a class B should extend a class A only if an “is-a” relationship exists between the two classes.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol><li>在插入模式中，使用如下操作更正错误：</li></ol><p><img src="/2019/06/19/ARTS-10/微信截图_20190623160456.png" alt=""></p><ol start="2"><li>在插入模式下，使用<code>ctrl+0</code>，可以将寄存器0中的内容粘贴到文本中。</li><li>使用<code>xp</code>命令可调换光标之后的两个字符；使用<code>ddp</code>命令可调换当前行和它的下一行；</li></ol><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第十周&quot;&gt;&lt;a href=&quot;#ARTS第十周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第十周&quot;&gt;&lt;/a&gt;ARTS第十周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：78题（颜色分类）和179题（最大数）算法题；《effective java》中关于类的最小可修改和接口优于继承的内容；《vim编程技巧》中关于在插入模式即时更正错误操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第九周</title>
    <link href="http://yoursite.com/2019/06/16/ARTS-9/"/>
    <id>http://yoursite.com/2019/06/16/ARTS-9/</id>
    <published>2019-06-16T08:28:39.000Z</published>
    <updated>2020-03-30T15:09:43.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第九周"><a href="#ARTS第九周" class="headerlink" title="ARTS第九周"></a>ARTS第九周</h1><p>本次ARTS主要包括：合并两个有序数组算法题；《effective java》 中关于类的访问权限设置；vim中标记跳转的用法；分享关于java中锁的底层实现机制。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="88"><li>合并两个有序数组</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>&amp;&amp;n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m+n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">               a= nums1[m-<span class="number">1</span>]; </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               nums1[i]=nums2[n-<span class="number">1</span>];</span><br><span class="line">               n--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">               <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                 b= nums2[n-<span class="number">1</span>];  </span><br><span class="line">               &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                  nums1[i]=nums1[m-<span class="number">1</span>];</span><br><span class="line">                   m--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">               nums1[i] = a;</span><br><span class="line">               m--;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               nums1[i] = b;</span><br><span class="line">               n--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题我是看了题解的思想后，再自己写的代码出来的。刚开始一直想着用类似合并有序链表的方式，用递归来做。但是一直没有弄出来递推表达式，后来看了题解，都没有用递归的。于是采用了从后往前遍历的方式来做。先将最大的数放在第m+n-1的位置，往前遍历，然后当其中一个数组遍历完成了之后，再把另个数组剩余的值全部搬到结果中来即可。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 15 : Minimize the accessibility of the classes and members</p><blockquote><ol><li>The single most important factor that distinguishes a well-designed component from a poorly designed ont is the degree to which the component hides its internal data and other implementation details, clearnly separating its API from its implementation.</li><li>The rule of thumb is simple : <strong><em>make each class or member as inaccessible as possible.</em></strong></li><li>To summarize, <strong><em>you should reduce accessibility of program elements as much as possible(within reason).</em></strong> After carefully designing a minimal public API, you should prevent any stray classes, interfaces, or members from becoming part of the API. <strong>With the exception of public static final fields, which serve as constants, public class should have no public fields .</strong> Ensure that objects referenced by public static final fields are immutable.</li></ol></blockquote></li><li><p>Item 16: In public classes, use accessor methods, not public fields</p><blockquote><ol><li>If a classis accessible outside its package, provide accessor methods to preserve the flexibility to change the class’s internal representation</li><li>If a class is package-private or is a private nested class, there is nothing inherently wrong with exposing its data fields</li><li>In summary, public classes should never expose mutable fields.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>使用<code>m{a-zA-Z}</code>表示在当前光标所在位置设标记，小写字母标记只在缓冲区局部可见，大写字母则全局可见。</li><li><code>mm</code>和<code></code>m`是一对便于使用的命令，分别用于设置标记位m和跳转到编辑位m上。同时vim还会自动编辑一些位置：</li></ul><p><img src="/2019/06/16/ARTS-9/微信截图_20190616213221.png" alt=""></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>跟朋友做了个关于Java锁的实现机制的分享，ppt内容就不截图了，链接贴在这：</p><p><a href="https://github.com/Banana1995/PersonRepo/tree/master/Document/ShareDoc" target="_blank" rel="noopener">锁的实现机制</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第九周&quot;&gt;&lt;a href=&quot;#ARTS第九周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第九周&quot;&gt;&lt;/a&gt;ARTS第九周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：合并两个有序数组算法题；《effective java》 中关于类的访问权限设置；vim中标记跳转的用法；分享关于java中锁的底层实现机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第八周</title>
    <link href="http://yoursite.com/2019/06/04/ARTS-8/"/>
    <id>http://yoursite.com/2019/06/04/ARTS-8/</id>
    <published>2019-06-04T14:41:39.000Z</published>
    <updated>2020-03-30T15:09:43.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第八周"><a href="#ARTS第八周" class="headerlink" title="ARTS第八周"></a>ARTS第八周</h1><p>本次ARTS主要包括：合并两个有序链表算法题；《effective java》 关于建议实现comparable接口；工作中学到的mysql中关于插入重复记录的几种处理方式。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="783"><li>Merge Two sorted list</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&gt;=l2.val)&#123;</span><br><span class="line">            res = l2;</span><br><span class="line">            res.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res = l1;</span><br><span class="line">            res.next =  mergeTwoLists(l1.next,l2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题一开始使用暴力解法没有解出来，采用了题解的一个递归方法。也学习到了递归的一些思想，可以用一个变量来保存需要返回的结果，然后再缩小范围继续递归。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p> continue reading 《effective java》</p><ul><li><p>Item 14 : consider implement comparable</p><blockquote><ol><li><p>By implement comparable, you allow you class to interoperate with all of many generic algorithms and collection implementations that depends on this interface.</p></li><li><p>If  a field does not implement comparable or you need a nonstandard ordering , use a Comparator instead.</p></li><li><p>Use of the relational operators &lt; and &gt; in compareTo methods is<br>verbose and error-prone and no longer recommended</p></li><li><p>In Java8, the Comparator interface was outfitted with a set of comparator construction methods, which enable fluent construction of comparators.These comparators can then be used to implement a compareTo method, as required by the Comparable interface.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="comment">// Comparable with comparator construction methods</span></span><br><span class="line">&gt;    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR =</span><br><span class="line">&gt;    comparingInt((PhoneNumber pn) -&gt; pn.areaCode)</span><br><span class="line">&gt;    .thenComparingInt(pn -&gt; pn.prefix)</span><br><span class="line">&gt;    .thenComparingInt(pn -&gt; pn.lineNum);</span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line">&gt;    <span class="keyword">return</span> COMPARATOR.compare(<span class="keyword">this</span>, pn);</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><blockquote><ol start="5"><li><strong>In summary, whenever you implement a value class that has a sensible ordering, you should have the class implement the Comparable interface so that its instances can be easily sorted , searched, and user in comparison-based collections. When comparing field values in the implementations of the compareTo methods, avoid the use of &lt; and &gt; operators. Instead, user the static compare methods inthe boxed primitive classes or the comparator construction methods in the Comparator interface.</strong></li></ol></blockquote></li></ul><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>处理mysql插入记录重复的几种方式</p><ul><li>使用<code>insert ignore</code></li></ul><blockquote><p>Use the <strong>INSERT IGNORE</strong> command rather than the <strong>INSERT</strong> command. If a record doesn’t duplicate an existing record, then MySQL inserts it as usual. If the record is a duplicate, then the <strong>IGNORE</strong> keyword tells MySQL to discard it silently without generating an error.</p><p>当记录不存在是，mysql会正常插入；当记录已经存在时，<code>ignore</code>关键字会告诉mysql静默的将数据丢掉而不报出错误。下面的sql语句将不会报错：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name)</span><br><span class="line">&gt;    -&gt; VALUES( 'Jay', 'Thomas');</span><br><span class="line">&gt; Query OK, 1 row affected (0.00 sec)</span><br><span class="line">&gt; </span><br><span class="line">&gt; mysql&gt; INSERT IGNORE INTO person_tbl (last_name, first_name)</span><br><span class="line">&gt;    -&gt; VALUES( 'Jay', 'Thomas');</span><br><span class="line">&gt; Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li>使用<code>replace</code> </li></ul><blockquote><p>Use the <strong>REPLACE</strong> command rather than the INSERT command. If the record is new, it is inserted just as with INSERT. If it is a duplicate, the new record replaces the old one.</p><p>使用<code>replace</code>命令来插入时，当记录不存在，则会正常插入。若已经存在，则会用新的记录代替原先的记录（先删再插）。示例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql&gt; REPLACE INTO person_tbl (last_name, first_name)</span><br><span class="line">&gt;    -&gt; VALUES( 'Ajay', 'Kumar');</span><br><span class="line">&gt; Query OK, 1 row affected (0.00 sec)</span><br><span class="line">&gt; </span><br><span class="line">&gt; mysql&gt; REPLACE INTO person_tbl (last_name, first_name)</span><br><span class="line">&gt;    -&gt; VALUES( 'Ajay', 'Kumar');</span><br><span class="line">&gt; Query OK, 2 rows affected (0.00 sec)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><ul><li><strong><em>当处理重复插入记录时，应该在<code>insert ignore</code>和<code>replace</code>中选择一个，<code>insert ignore</code>会保留第一次插入的记录，而<code>replace</code>则保留的是最后的一条记录。</em></strong> </li><li>使用<code>insert into...on duplicate key update id=id</code></li></ul><blockquote><p>这里使用<code>id=id</code>来在更新时做无用操作来完成在key重复时什么都不做。</p></blockquote><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第八周&quot;&gt;&lt;a href=&quot;#ARTS第八周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第八周&quot;&gt;&lt;/a&gt;ARTS第八周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：合并两个有序链表算法题；《effective java》 关于建议实现comparable接口；工作中学到的mysql中关于插入重复记录的几种处理方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第七周</title>
    <link href="http://yoursite.com/2019/05/26/ARTS-7/"/>
    <id>http://yoursite.com/2019/05/26/ARTS-7/</id>
    <published>2019-05-26T15:46:39.000Z</published>
    <updated>2020-03-30T15:09:43.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第七周"><a href="#ARTS第七周" class="headerlink" title="ARTS第七周"></a>ARTS第七周</h1><p>本次ARTS主要包括：最大同值路径问题算法；读完《Java并发编程艺术》整书的思维导图；VIM编程技巧关于上下移动一行和向上或向下查询当前游标下的单词等操作；</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p>168.Longest Univalue Path</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Integer res =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        recurisionMethod(root);</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">recurisionMethod</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = recurisionMethod(root.left) ;</span><br><span class="line">        <span class="keyword">int</span> right = recurisionMethod(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root.left !=<span class="keyword">null</span> &amp;&amp; root.left.val == root.val)&#123;</span><br><span class="line">            left = left +<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left =<span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.right !=<span class="keyword">null</span> &amp;&amp; root.right.val == root.val)&#123;</span><br><span class="line">            right= right+<span class="number">1</span>;</span><br><span class="line">        &#125;   <span class="keyword">else</span>&#123;</span><br><span class="line">            right=<span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        res = Math.max(res,left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最长同值路径问题。自己没有做出来，看了题解的思路。对于递归的问题，我解起来还是比较费劲的。另外就是犯了一个java方法传递值得问题。此处的结果需要定义成全局变量，不能使用一个int类型作为参数传递。因为java是值传递而不是引用传递。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p> continue reading 《effective java》</p><ul><li><p>Item 12 : Always override toString</p><blockquote><ol><li>Providing  a good toString implementation makes your class much more pleasant to use and makes systems using the class easier to debug.</li><li>When practical, the toString method should return all insteresting information contained in the  object.</li><li>Whether or not you decide to specify the format , you should clearly document you intentions.</li><li>Whether or not you specify the format, provide programmatic access to the information contained in the value returned by toString.</li></ol></blockquote></li><li><p>Item 13 : Override clone judiciously</p><blockquote><ol><li>Though the specification doesn’t say it , in practice , a class implementing Cloneable is expected to provide a properly functioning public clone method. And the class and all of its superclass should obey a complex , unenforceable,thinly docemented protocol to achieve that.</li><li>You can use <code>throw new CloneNotSupportedException();</code> for degenerate clone implementation.</li><li>To recap, all classes that implement Cloneable should override clone with a public method whose return type is the class itself. This method should first call <code>super.clone</code>, then fix any fields tha need fixing. Typically, this means copying any mutable objects that comprise the internal “deep structure” of the object and replacing the clone’s references to these objects with references to their copies.</li><li>A better approach to object copying is to provide a <strong><em>copy constructor</em></strong> or <strong><em>copy factory</em></strong>. A notable exception to this rule is arrays, which are best copied with the clone method.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>vim编程技巧：</p><p>使用<code>#</code>可以自动向上查询当前游标下的单词；</p><p>使用<code>*</code>可以自动向下查询当前游标下的单词；</p><p>使用<code>ctrl</code>+<code>e</code>可以向上翻滚一行；</p><p>使用<code>ctrl</code>+<code>y</code>可以自动向下翻滚一行；</p><p>使用<code>zz</code>可以将当前行移动到屏幕中央。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周阅读完了《Java并发编程艺术》这本书，将其全部的思维导图贴出：</p><p><img src="/2019/05/26/ARTS-7/Java并发编程的艺术.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第七周&quot;&gt;&lt;a href=&quot;#ARTS第七周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第七周&quot;&gt;&lt;/a&gt;ARTS第七周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：最大同值路径问题算法；读完《Java并发编程艺术》整书的思维导图；VIM编程技巧关于上下移动一行和向上或向下查询当前游标下的单词等操作；&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第六周</title>
    <link href="http://yoursite.com/2019/05/09/ARTS-6/"/>
    <id>http://yoursite.com/2019/05/09/ARTS-6/</id>
    <published>2019-05-09T15:05:39.000Z</published>
    <updated>2020-03-30T15:09:43.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第六周"><a href="#ARTS第六周" class="headerlink" title="ARTS第六周"></a>ARTS第六周</h1><p>本次ARTS主要包括：Excel列名称算法题；《Java并发编程艺术》内存模型的思维导图；《effective java》中关于重写hashcode方法的章节。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p>168.Excel表列名称</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String contanier = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line">        <span class="keyword">int</span> temp =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">26</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(contanier.charAt(n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb =  <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        List&lt;String&gt; te = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            temp = (n-<span class="number">1</span>)%<span class="number">26</span>;</span><br><span class="line">            n=(n-<span class="number">1</span>)/<span class="number">26</span>;</span><br><span class="line">            te.add(String.valueOf(contanier.charAt(temp)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j= (te.size()-<span class="number">1</span>);j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            sb.append(te.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的思路是对26取余，从低到高位，一位一位的取。其中的<code>n-1</code>将整除26的数取不到Z字母的问题解决了。</p><p>见到题解中有同学使用<code>&#39;A&#39;+数字</code>来取值，引发了我对char类型数据的思考：char占有2个字节，用16位表示Unicode编码。可以使用’A’加上一个整数来表示其编码的字符，如’A’+1则表示’B’这个字符。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p> continue reading 《effective java》</p><ul><li><p>Item 11 : Always override hashCode when you override equals</p><blockquote><ol><li>You must override hashCode method in every class that overrides equals.Here are the contract,adapted from the Object specification:<ul><li>when the hashCode method is invoked on an object repeatedly during an execution of an application, it must consistently return the same value.</li><li>if two objects are equal according to the equals method , then calling hashCode on the two  objects should return the same integer result.</li><li>if two objects are unequal according to the equals method , it is <strong>not required</strong> that calling hashCode method return distinct value.However, the programmer should be aware that producing distinct results for unequal objects may improve the performance of hash tables.(cause the same hashCode value can make the hashtable degenerate to linked list).</li></ul></li><li>A good hash function tends to produce unequal hash codes for unequal instances.</li><li>When you compute the hash codes , you <strong>must exclude</strong> any fields that are not used in equals comparisons, or you risk violating the second provision of the hashCode contract.</li><li>If you have a bona fide need for hash functions less likely to produce collisions , see Guava’s <code>com.google.common.hash.Hashing</code></li><li>if a class if immutable and the cost of computing the hash code is significant, you might consider caching the hash code in the object rather than recalculating it each time it is requested.</li><li>Do not be tempted to exclude significant fields from the hash code computation to improve perfoemance.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>无</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周新增了《并发编程的艺术》第三章内存模型相关内容的思维导图</p><p><img src="/2019/05/09/ARTS-6/Java并发编程的艺术.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第六周&quot;&gt;&lt;a href=&quot;#ARTS第六周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第六周&quot;&gt;&lt;/a&gt;ARTS第六周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：Excel列名称算法题；《Java并发编程艺术》内存模型的思维导图；《effective java》中关于重写hashcode方法的章节。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第五周</title>
    <link href="http://yoursite.com/2019/05/05/ARTS-5/"/>
    <id>http://yoursite.com/2019/05/05/ARTS-5/</id>
    <published>2019-05-05T15:15:09.000Z</published>
    <updated>2020-03-30T15:09:43.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第五周"><a href="#ARTS第五周" class="headerlink" title="ARTS第五周"></a>ARTS第五周</h1><p>本次ARTS主要包括：回文数、最长公共前缀算法、《effective java》关于复写equals方法的Item、VIM使用文本对象选择选区操作、《Java并发编程艺术》前两章的思维导图。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="9"><li>回文数</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rightToLeft =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> te =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = x;</span><br><span class="line">        <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">            te = y%<span class="number">10</span>;</span><br><span class="line">            rightToLeft = rightToLeft*<span class="number">10</span>+te;</span><br><span class="line">            y=y/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==rightToLeft)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚好昨晚刷题刷到了整数反转的题目，这里顺手一上来就想到了使用整数反转的方式来做。果然效果很不错。对于整数溢出的问题其实可以不用担心，因为回文数字肯定不会溢出。</p><blockquote><ol start="14"><li>最长公共前缀</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;;j++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag =<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span> publicChar = <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">if</span>(strs[<span class="number">0</span>]!=<span class="keyword">null</span> &amp;&amp; strs[<span class="number">0</span>].length()&gt;=j+<span class="number">1</span>)&#123;</span><br><span class="line">                publicChar = strs[<span class="number">0</span>].charAt(j);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">                String te = strs[i];</span><br><span class="line">                <span class="keyword">if</span>(te!=<span class="keyword">null</span> &amp;&amp;  te.length()&gt;=j+<span class="number">1</span> &amp;&amp; publicChar==te.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag )&#123;</span><br><span class="line">                res.append(publicChar);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始写的时候没有考虑到String获取长度的是length()方法与数组的length调用方式是不同的，导致编译未通过。后来测试案例又未通过<code>&quot;&quot;</code>的校验。测试了一番之后才知道<code>&quot;&quot;</code>的长度为0，在调用length()方法后，应该判断的条件是字符串的长度大于数组下标+1的值。</p><p>我的这个算法的最坏的时间复杂度为O(m*n)，m为数组的长度，n为公共前缀的字符数。查看了题解后发现与题解中的算法二思路相同，但是代码实现没有它的简单。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java 》</p><ul><li><p>Item 10 Obey the general contract when overriding equals</p><blockquote><ul><li>Each instance of the class is inherently unique.</li><li><strong>There is no need for the class to privide a “logical equality” test.</strong> For example,<em>java.util.regex.Pattern</em> could have overridden equals to check whether two Pattern instances represented exactly the same regular expression.But the client user doesn’t need this function.</li><li>A superclass has already overriden equals, and the superclass behavior is approriate for this class.For example, most Set implementations inherit their equals implementation from AbstractSet, List implementations from AbstractList, and Map implementations from AbstractMap.</li><li><strong>It’s  appropriate for you to overriden equal method when a class has a notion of <em>logical equality</em> that differ from mere object identity and a superclass has not already overridden equals.</strong> This is generally the case for value classes. A value class is simply a class that represents a value, such as Integer or String. A clent user need invoke equals method to find out whether they are logically equivalent or they refer to same object.</li><li>Here are some contract for overriden the <em>equals method</em>. <ul><li>Reflexive: For any non-null reference value x, x.equals(x) must return true.</li><li>Symmetric: For any non-null reference values x and y, x.equals(y) must return true if and only if y.equals(x) returns true.</li><li>Transitive: For any non-null reference values x, y, z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) must return true.</li><li>Consistent: For any non-null reference values x and y, multiple invocations of x.equals(y) must consistently return true or consistently return false, provided no information used in equals comparisons is modified.</li><li>For any non-null reference value x, x.equals(null) must return false.</li></ul></li></ul></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在使用vim编辑时，可以使用文本对象来进行选择。如：</p><p><img src="/2019/05/05/ARTS-5/微信截图_20190505222619.png" alt=""></p><p>同时还可以使用<code>ci}</code>或<code>da&quot;</code>、<code>ya&quot;</code>这种操作来将选中的部分替换、删除、复制。其中的<code>i</code>和<code>a</code>可以理解为<code>inside</code>和<code>arround</code>;<code>a&quot;</code>会选中由双引号括起来的字,<code>i}</code>会选中在一对大括号里面的内容。</p><p>除此之外，还可以使用<code>daw</code>、<code>ciw</code>、<code>yaw</code>这种操作来对一个单词进行删除、替换、复制等。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>放假期间在读《Java并发编程艺术》这本书。在读完了《Java并发编程实战》再来读这本书，发现很多东西，理解起来更容易了。同时这本书也对底层的指令实现原理讲解的更透彻，推荐阅读。</p><p><img src="/2019/05/05/ARTS-5/Java并发编程的艺术.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第五周&quot;&gt;&lt;a href=&quot;#ARTS第五周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第五周&quot;&gt;&lt;/a&gt;ARTS第五周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：回文数、最长公共前缀算法、《effective java》关于复写equals方法的Item、VIM使用文本对象选择选区操作、《Java并发编程艺术》前两章的思维导图。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第四周</title>
    <link href="http://yoursite.com/2019/04/27/ARTS-4/"/>
    <id>http://yoursite.com/2019/04/27/ARTS-4/</id>
    <published>2019-04-27T15:05:39.000Z</published>
    <updated>2020-03-30T15:09:43.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第四周"><a href="#ARTS第四周" class="headerlink" title="ARTS第四周"></a>ARTS第四周</h1><p>快五一了，最近这段时间都是在看并发相关的知识。刚看完《Java并发编程实战》，基础部分还是需要恶补呀。加油，一步步来。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="7"><li>整数反转</li></ol></blockquote><p>标准答案的解法是通过使用取余法不断地取出整数的每一位，再用乘法加到新数的后面去，再判断一下整数是否溢出了即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> te = x%<span class="number">10</span>;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(rev&gt;Integer.MAX_VALUE/<span class="number">10</span> || (rev ==  Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; te&gt;<span class="number">7</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rev&lt;Integer.MIN_VALUE/<span class="number">10</span> || (rev == Integer.MIN_VALUE/<span class="number">10</span> &amp;&amp; te &lt;-<span class="number">8</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            rev = rev*<span class="number">10</span>+te;</span><br><span class="line">              x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 7 Eliminate obsolete object references</p><blockquote><ol><li><strong>Nulling out object references should be the exception rather than the norm </strong></li><li>when a class manager its own memory , the programmer should be alert for memory leaks.</li><li>caches is common source of memory leaks</li></ol></blockquote></li><li><p>Item 8  Avoid Finalizers and cleaners</p><blockquote><ol><li>Finalizers are unpredictable , often dangerous, and generally unneccessary.Cleaners are less dangerous than finalizers,but still unpredicatable,slow,and generally unnecessary.</li><li>There is a severe performance penatly for using finalizer and cleaners.</li><li>They have two legitimate uses. One is to act as a safety net in case the owner of a resource neglects to call its close method .Another is native peers</li></ol></blockquote></li><li><p>Item 9 Perfer try-with-resources to try-finally</p></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在工作中遇到了需要用sql处理字符串的问题，使用到了substring_index这个函数，具体用法如下：</p><blockquote><p> <strong>substring_index(“待截取字符”，”分隔符”，截取第n个字符)</strong></p></blockquote><p>当最后的数字n为负数时，代表倒着数第n个字符。</p><p>将从<code>1010a2|192b23|33c23|12383d|12312f</code>这段字符中取出竖线分割的倒数第一个字符的用法为：<code>substring_index(&quot;1010a2|192b23|33c23|12383d|12312f&quot;,&quot;|&quot;,-1)</code>,取出第三个用法为<code>substring_index(&quot;1010a2|192b23|33c23|12383d|12312f&quot;,&quot;1&quot;,3)</code></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>最近几周都在死磕并发编程这本书，终于读完，收获颇丰，贴上自己整理的思维导图</p><p><img src="/2019/04/27/ARTS-4/Java 并发编程实战.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第四周&quot;&gt;&lt;a href=&quot;#ARTS第四周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第四周&quot;&gt;&lt;/a&gt;ARTS第四周&lt;/h1&gt;&lt;p&gt;快五一了，最近这段时间都是在看并发相关的知识。刚看完《Java并发编程实战》，基础部分还是需要恶补呀。加油，一步步来。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS补卡第三周</title>
    <link href="http://yoursite.com/2019/04/16/ARTS-3/"/>
    <id>http://yoursite.com/2019/04/16/ARTS-3/</id>
    <published>2019-04-16T13:20:29.000Z</published>
    <updated>2020-03-30T15:09:43.513Z</updated>
    
    <content type="html"><![CDATA[<p>上周工作任务很重，周日没来得及打卡，今天补上。真心希望忙完这一阵可以轻松点，不然真的撑不下去了。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p>237.删除链表中的结点</p></blockquote><p>本来是一道很简单的题，没有理解清楚变量<code>x</code>的含义，结果导致使用了递归还是没有做出来，很可惜；</p><p>贴上最后的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode nextNode =node.next;</span><br><span class="line">        node.val = nextNode.val;</span><br><span class="line">        node.next = nextNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》.</p><ul><li><p>Item 5 : Prefer Dependency injection to hardwiring resources.</p><blockquote><ol><li>static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource.</li><li>a simple pattern that satisfies that requirement is to pass the resource into the constructor when creating instance. This is one form of Dependency injection .</li><li>Do not use a singleton or static utility class to implements a class that depends on one or more   underlying resource whose  behavior affects that of class. And do not have the class create these resource.Instead, pass the resources,or factories to create them, into the constructor.</li></ol></blockquote></li><li><p>Item 6 : Avoid creating unnecessary object.</p><blockquote><ol><li>you can often avoid creating unnecessary object by using <code>static factory method</code> in preference to constructor on immutable classes that provide both.like use <code>String a= &quot;banana&quot;</code> ,not <code>String a = new String(&quot;banana&quot;)</code>. Besides,<code>Boolean(String)</code> is deprecated in Java 9,cause it must create the instance each time it’s invoked.The factory method <code>Boolean.valueOf(String)</code> is preferable to the constructor. </li><li>you can also reuse the <strong>mutable </strong>object if you know it won’t be modified. Some object creations are so expensive , cache it for reuse will provides significant performance gains if they are invoked frequently. if the object is immutable , it is obvious it can be reused safely.</li><li>Another way to create unnecessary object is <strong>autoboxing</strong> .we should prefer primitives to boxed primitives , and watch out unintentional autoboxing.</li><li>Conversely,avoid object creation by maintaining you own object pool is a bad idea,unless the object is extremely heavyweight.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>这周在工作中遇到一个问题，当我试图把一个很大的文件通过流转换为<code>String</code>存储时，这个转换有时候会出错，报出<code>OutOfMemoryError:null</code>的错误。随即我开始调整内存大小，但是无论我怎么调整都没有用。</p><p>当我观察后发现，错误信息的后面是<code>null</code>而不是通常的堆栈溢出等。于是我开始跟踪源码，发现当我用流读进来后，用<code>StringBuilder</code>去拼接成字符串。然而<code>String</code>的字符数组的最大长度为：$$2^{31}=2^{10}\times2^{10}\times2^{10}\times2^{1}=1024\times1024\times1024\times2$$，即2GB。而我的文件刚好大于2GB。所以之前我在转其他文件的时候没有报错是由于文件小于2GB。此处的<code>OOM</code>错误是<code>StringBuilder</code>抛出的，而不是由于堆内存 不够导致的内存溢出。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周工作任务很重，周日没来得及打卡，今天补上。真心希望忙完这一阵可以轻松点，不然真的撑不下去了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第二周</title>
    <link href="http://yoursite.com/2019/04/03/ARTS-2/"/>
    <id>http://yoursite.com/2019/04/03/ARTS-2/</id>
    <published>2019-04-03T15:28:39.000Z</published>
    <updated>2020-03-30T15:09:43.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第二周"><a href="#ARTS第二周" class="headerlink" title="ARTS第二周"></a>ARTS第二周</h1><p>第二周赶上清明假期，察觉自己欠缺诸多，还是踏踏实实的一步一步来。所谓慢就是快，时常想尽力追赶前面的东西，没把基础打好，后面搞得自己很狼狈，实则是得不偿失。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>本周做的题目是最长回文子串，第一遍做的时候没有理解清楚什么是回文。第二次提交的时候未能通过测试用例。看了题解才做出来的。</p><p>思路是用中心点方法，从中心点开始往两侧推移。</p><p>贴出大佬的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] range = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            i = findLongest(str, i, range);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(range[<span class="number">0</span>], range[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> low, <span class="keyword">int</span>[] range)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> high = low;</span><br><span class="line">        <span class="keyword">while</span> (high &lt; str.length - <span class="number">1</span> &amp;&amp; str[high + <span class="number">1</span>] == str[low]) &#123;</span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = high;</span><br><span class="line">        <span class="keyword">while</span> (low &gt; <span class="number">0</span> &amp;&amp; high &lt; str.length - <span class="number">1</span> &amp;&amp; str[low - <span class="number">1</span>] == str[high + <span class="number">1</span>]) &#123;</span><br><span class="line">            low--;</span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (high - low &gt; range[<span class="number">1</span>] - range[<span class="number">0</span>]) &#123;</span><br><span class="line">            range[<span class="number">0</span>] = low;</span><br><span class="line">            range[<span class="number">1</span>] = high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于动态规划、字符串查找等算法还是很迷糊，还是需要加强训练和看书啊。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周继续阅读英文版《effective java》。</p><ul><li>Item2 consider a builder pattern when face many constructor parameters.</li></ul><blockquote><ol><li><p>The Builder pattern is a good choice when designing classes whose construct or static factories would have more than a handful parameters.</p></li><li><p>builder pattern is provide a public method which return ‘Builder’ type Object.And,The instant of Builder type Object would provide a build() method,which return the instant of outclass Object.</p></li></ol></blockquote><ul><li>Item 3 Enforce the singleton property with a private constructor or an enum type</li></ul><blockquote><ol><li>the normal approach to implement singletons are base on keeping the construstor private and export a public static member to provide access to the sole instance.but serialized instantce will create a new instance,unless you declare all instance fields <code>transient</code> and provide <code>readResolve</code> method.</li><li>a single-element enum type is often the best way to implement singleton.</li></ol></blockquote><ul><li>Item 4 Enforce nonistantiablity with a private contructor</li></ul><blockquote><ol><li>some utility classes is not designed for instantied. but the default construct would make it can be instantiated.we could make the constructor private to avoid user instantiated it.</li><li>private construct can make the subclass could’t instantiated too.cause the all constructors must invoke superclass contructor,explicitly or implicitly. and the private constructor is inaccessible from outside class.</li><li>The AccessError is not strictly required,but it provides insurance in case the constructor is invoked from inside class.</li></ol></blockquote><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>学习《VIM使用技巧》，工作中使用vim一直不会快速移动，在此记录下，最近学到的快速移动技巧</p><ol><li>区分屏幕行和实际行。例如在工作中编辑baseInfo文件时，其实就是一个实际行，但是这一行的内容非常多，导致在做查找、跳转等动作时很不方便，但是vim可以在移动命令前加上<code>g</code>表示移动屏幕行。如<code>gk</code>表示向上移动一个屏幕行。</li></ol><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center"><code>g0</code></td><td style="text-align:center">移动到屏幕行的行首</td></tr><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center">移动到实际行的行首</td></tr><tr><td style="text-align:center"><code>gk</code></td><td style="text-align:center">向上移动一个屏幕行</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">移动到实际行的第一个非空白字符</td></tr><tr><td style="text-align:center"><code>g^</code></td><td style="text-align:center">移动到屏幕行的第一个非空白字符</td></tr><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center">移动到实际行的行尾</td></tr><tr><td style="text-align:center"><code>g$</code></td><td style="text-align:center">移动到屏幕行的行尾</td></tr></tbody></table><ol start="2"><li><p>基于单词的移动，下面这张截图即可了解清楚各个命令的操作：</p><p><img src="/2019/04/03/ARTS-2/moveBaseWord.png" alt=""></p></li></ol><ol start="3"><li><p>区分单词和字符串：对于vim来说，单词是以各种逗号，括号，空格等符号分割的，而字符串则是单纯的以空格分割开来。基于这个认知，我们在做移动命令的时候，便可使用<code>W</code>/<code>E</code>/<code>B</code>等命令基于字符串移动。这样会比基于单词移动快很多，如果希望以细粒·度来移动则可以使用基于单词的方式。</p></li><li><p>使用<code>f{char}</code>+<code>;</code>命令可以在同一行中，根据查找的字母快速移动到自己希望的位置上去。若不小心跳过头了，还可以使用<code>,</code>命令往回跳。</p><blockquote><p>可以把 <code>t{char}</code> 及 <code>T{char}</code>命令当成“直到查找到指定的字符为止”（search till<br>the specified character）的命令，它们使光标停留在 {char} 前面的那个字符上，而<br><code>f{char}</code> 和 <code>F{char}</code>命令则把光标移动到指定字符上。</p></blockquote></li></ol><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>和同学一起做了个分享会，把提纲内容贴在这里，这个内容还没做完，后续还会在这里更新。</p><p><img src="/2019/04/03/ARTS-2/Java-concurrency-in-practice.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第二周&quot;&gt;&lt;a href=&quot;#ARTS第二周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第二周&quot;&gt;&lt;/a&gt;ARTS第二周&lt;/h1&gt;&lt;p&gt;第二周赶上清明假期，察觉自己欠缺诸多，还是踏踏实实的一步一步来。所谓慢就是快，时常想尽力追赶前面的东西，没把基础打好，后面搞得自己很狼狈，实则是得不偿失。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第一周</title>
    <link href="http://yoursite.com/2019/03/31/ARTS-1/"/>
    <id>http://yoursite.com/2019/03/31/ARTS-1/</id>
    <published>2019-03-31T15:28:39.000Z</published>
    <updated>2020-03-30T15:09:43.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第一周"><a href="#ARTS第一周" class="headerlink" title="ARTS第一周"></a>ARTS第一周</h1><p>第一周参加ARTS打卡，将本周的总结都记录在个人的blog里。刚开始第二天，由于周末加班准备的很仓促，质量感觉一般，最后的share没有做，下周补上。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>先是LeetCode上简单的算法题，两数之和。上次刷算法题应该是大四秋招前，那会儿什么也不懂，也没坚持下去，甚至当时都没觉得以后可以成为一个程序猿。直到阴差阳错，真的成为了程序猿后，发现基础太薄弱，需要补的东西太多了。索性一步一步来，花两年时间把改补的尽量都补上。下面是我的答案，做的很不好，只想到了暴力解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i]+nums[j] == target)&#123;</span><br><span class="line">                result[<span class="number">0</span>]=i;</span><br><span class="line">                result[<span class="number">1</span>]=j;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了题解后发现可以用<code>map</code>来做，而让我没能转过弯的是可以把两数之和转换成<code>x</code> 和 <code>target-x</code> 来从数组中查找。我只想到了单纯的相加。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>读了中英对照版的《effective java》Chapter 2 Item 1，英语不太好，对于其中的很多点理解的有些不到位，所以 需要对照着中文版才能看懂一些。模仿github上的总结，将自己的总结写在下面：</p><blockquote><ol><li><p>static factory methods have names,but constructors not;</p></li><li><p>not required to create new object when they’re invoked;</p></li><li>they can return any subtype of return type;</li><li>return type can vary from call to call as a function of the input parameters;</li><li>the return type can not exist when the static factory method is written;</li></ol></blockquote><p>there are two main limitation of static factory method :</p><blockquote><ol><li>the class without public or protected contructors can not be subclassed;</li><li>documentation is not frendly for programmers;</li></ol></blockquote><p><a href="https://jiapengcai.gitbooks.io/effective-java/content/chapter1/di-1-tiao-ff1a-kao-lv-yong-jing-tai-fang-fa-er-bu-shi-gou-zao-qi.html" target="_blank" rel="noopener">gitbook中英对照版</a></p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>最近在练习使用<code>vim</code>插件编辑代码，想到上次在客户现场，<code>json</code>文件是一行数据，很长很长。我用<code>vim</code>编辑不知道如何使用<code>replace</code>功能在同一行中选中部分进行替换。后来问了同学，他抛给我一个链接，是英文搜索出来的，而且讲解很详细。这次让我认识到学习英语对于查找问题很重要，很多信息确实在中文里搜索很难找到解答。在此记录下<code>vim</code>在<code>visual</code>模式下的替换技巧：可以使用<code>\%V</code>来指定在<code>visual</code>模式中替换选中部分的查找对象。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">music amuse fuse refuse</span><br></pre></td></tr></table></figure><p>In normal mode, type <code>^wvee</code> to visually select “amuse fuse” (<code>^</code> goes to first nonblank character, <code>w</code> moves forward a word, <code>v</code> enters visual mode, <code>e</code> moves forward to end of next word). Then press Escape and enter the following command to change all “us” to “az” in the last-selected area within the current line:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&apos;&lt;,&apos;&gt;s/\%Vus/az/g</span><br></pre></td></tr></table></figure><p>the result is :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">music amaze faze refaze</span><br></pre></td></tr></table></figure><p>注意V是大写，不是小写。</p><p><a href="https://vim.fandom.com/wiki/Search_and_replace_in_a_visual_selection" target="_blank" rel="noopener">原文地址链接</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第一周&quot;&gt;&lt;a href=&quot;#ARTS第一周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第一周&quot;&gt;&lt;/a&gt;ARTS第一周&lt;/h1&gt;&lt;p&gt;第一周参加ARTS打卡，将本周的总结都记录在个人的blog里。刚开始第二天，由于周末加班准备的很仓促，质量感觉一般，最后的share没有做，下周补上。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>RPS曲线制作与使用</title>
    <link href="http://yoursite.com/2018/10/28/RPS%E6%9B%B2%E7%BA%BF%E5%88%B6%E4%BD%9C%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/28/RPS曲线制作与使用/</id>
    <published>2018-10-28T04:11:23.000Z</published>
    <updated>2020-03-30T15:09:43.561Z</updated>
    
    <content type="html"><![CDATA[<p>此文章内容结合公众号“陶博士2006”的RPS曲线的编制方法，记录自己使用时的注意事项。</p><a id="more"></a><h2 id="RPS曲线编制"><a href="#RPS曲线编制" class="headerlink" title="RPS曲线编制"></a>RPS曲线编制</h2><h3 id="1-建立”上市一年以上”自定义板块并将股票选入板块"><a href="#1-建立”上市一年以上”自定义板块并将股票选入板块" class="headerlink" title="1.建立”上市一年以上”自定义板块并将股票选入板块"></a>1.建立”上市一年以上”自定义板块并将股票选入板块</h3><blockquote><p> 在通达信软件中，工具—自定义板块设置—新建板块。</p><p>功能（菜单）–选股器-定制选股–其它条件–上市天数–加入条件–上市天数大于360天–选股入板块（上市一年以上）。</p></blockquote><ul><li>注意：此处若想复现博士另一篇文章中的排序结果，则需要将上市天数设置为2016年6月1日至当前时间的天数。再通过.401进行rps排序可得出与博士另一篇文章相似的排序结果。我是以此来验证公式设置是否准确的。</li><li>此板块中的股票博士建议<strong>一个月更新一次</strong></li></ul><h3 id="2-设置公式"><a href="#2-设置公式" class="headerlink" title="2.设置公式"></a>2.设置公式</h3><p><strong>公式的本质是按照股票的涨幅排序来计算出相对股价强度</strong></p><blockquote><p>建立一个小公式，命名为“EXTRS”，用来计算股票涨跌幅</p><p>EXTRS:(C-REF(C,N))/REF(C,N);</p><p>N缺省值为250。</p><p>通达信软件，Control+F，技术指标公式—其他类型</p></blockquote><p>建立涨跌幅公式后，需要将股票按照涨跌幅排序，这里需要设置扩展数据：</p><blockquote><p>输入：.902，进入扩展数据管理器。 选中第1条扩展数据，点击修改。</p><p>技术指标公式选择新建的“EXTRS”指标</p><p>计算参数为120（对应半年期的RPS）</p><p>计算时段为本地所有数据</p><p>计算品种为“自定义板块”下面的“上市一年以上”这个板块</p><p>勾选“精确复权”及“生成横向排名数据”</p><p>排名方法为“0-1000归一化顺序”</p></blockquote><p>这是按照股价120天的涨幅对全市场所有股票数据进行排序，再按照同样的方式对扩展数据2进行设置，将参数设置为250天，计算的是股价一年的涨幅排序。</p><p>接下来，新建一个RPS公式指标：</p><blockquote><p>通达信软件，Control+F，技术指标公式—其他类型—新建：</p><p>股价相对强度RPS, 出两条彩线的代码如下：</p><p>X:=EXTDATA_USER(1,0);{120天的}</p><p>RPS120:X/10,LINETHICK2,COLORGREEN;</p><p>IF(RPS120&gt;=M,RPS120,DRAWNULL),LINETHICK2,COLORRED;</p><p>;</p><p>Y:=EXTDATA_USER(2,0);{250天的}</p><p>RPS250:Y/10,LINETHICK2,COLORWHITE;</p><p>IF(RPS250&gt;=M,RPS250,DRAWNULL),LINETHICK2,COLORRED;</p></blockquote><h3 id="3-下载历史数据"><a href="#3-下载历史数据" class="headerlink" title="3.下载历史数据"></a>3.下载历史数据</h3><p>软件计算需要使用全部的历史数据：</p><blockquote><p>通达信软件的菜单—系统—盘后数据下载：请自行修改下载的开始时间</p></blockquote><ul><li>博士建议这里需要每天存盘下载当天日线数据，并全部刷新两条扩展数据（即重新计算排名），这样才能显示最新的RPS曲线。</li></ul><h3 id="4-使用RPS排序"><a href="#4-使用RPS排序" class="headerlink" title="4.使用RPS排序"></a>4.使用RPS排序</h3><p>在“上市一年以上”的板块中采用RPS指标对该板块进行排序即可：</p><blockquote><p>通达信可以对RPS进行排序：.401（401前面有个点），进入历史行情指标排序，然后右键添加RPS指标，或者右键更改排序指标为RPS，就可以排序了。</p></blockquote><p>从公式里可以看到RPS的值其实是股价涨跌的排序值，股价涨幅最高的为100分，在板块中过滤后剩下的RPS大于90分的大概只有三四百只股票。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文章内容结合公众号“陶博士2006”的RPS曲线的编制方法，记录自己使用时的注意事项。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="陶博士2006" scheme="http://yoursite.com/tags/%E9%99%B6%E5%8D%9A%E5%A3%AB2006/"/>
    
  </entry>
  
  <entry>
    <title>指数基金投资指南</title>
    <link href="http://yoursite.com/2018/09/22/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/09/22/指数基金投资指南/</id>
    <published>2018-09-22T10:28:40.000Z</published>
    <updated>2020-03-30T15:09:43.621Z</updated>
    
    <content type="html"><![CDATA[<p>一本从价值投资逻辑介绍指数基金投资的好书。</p><a id="more"></a><h2 id="为什么选择指数基金"><a href="#为什么选择指数基金" class="headerlink" title="为什么选择指数基金"></a>为什么选择指数基金</h2><p>投资指数基金的好处，自然无需多言，无论是巴菲特还是国内的投资大师们，都推荐普通人去投资指数基金。然而指数基金在国内并没有受到普通投资者的青睐。在这本书里，作者银行螺丝钉介绍了他投资指数基金的逻辑。因为国内A股市场的特殊性，所以我们不能采用无脑定投的方式投资指数基金。而是应该采用在低估的时候买入，在高估的时候卖出这种投资策略。</p><p>根据作者的数据和预测，即使采用无脑定投的方式投资指数基金，在A股过去的几十年里也可以获得10%以上的收益率。如果配合了<strong>低估买入，高估卖出</strong>的策略，则可以达到将近30%的收益率。这一切是基于改革开放40年以来的国内经济高速增长，然而目前国内经济增长速度有所减缓，但是采用低估买入，高估卖出的策略，在未来15%以上的收益率还是可以期待的。</p><p>与此同时，指数基金还具有“不会死”的特点，投资指数基金不像投资股票那样具有很高的风险，同时也可以带来长期较高的回报率。</p><h2 id="指数基金的估值"><a href="#指数基金的估值" class="headerlink" title="指数基金的估值"></a>指数基金的估值</h2><p>作者在书中介绍了两种挑选低估指数基金的方法，分别是盈利收益率法和博格公式法。盈利收益率法指的是采用盈利收益率来判断指数的估值。盈利收益率指的是市盈率的倒数。所以<strong>它只适用于流动性较好并且盈利稳定的品种。</strong>我们一般认为盈利收益率大于10%时，是处于低谷的区域。</p><p><strong>博格公式：指数基金未来的年复合收益率等于指数基金的投资初期股息率，加上指数基金每年的市盈率变化率，再加上指数基金每年的盈利变化率。</strong></p><p>这里的<strong>股息率等于分红率乘以盈利收益率</strong>，而分红率长期保持不变，所以一般当盈利收益率较高，是股息率也较高。所以根据博格公式，指数基金收益率的增长来源于三个部分分别是盈利，PE和股息。所以当我们在低估时买入指数基金时，相当于处于一个PE较低、盈利收益率和股息率较高的时间。当国家经济正常发展，企业盈利提升，我们就可以获得“股息带来的收益”还有“市盈率上涨带来的收益”。  </p><p>当某些<strong>周期性行业不适宜采用市盈率来判断估值</strong>时，可以采用博格公式的市净率版本来估值：</p><p><strong>指数基金未来的年复合率等于指数基金每年市净率的变化率，加上指数基金每年净资产的变化率。</strong></p><p>采用博格公式来判断是否低谷，则需要借助于历史数据。一般我们看当前的PB或PE处于历史的数据的百分位来判断是否处于低估区域。</p><p>根据指数背后公司的盈利状态，我们可以把指数分为四个类别，分别采用不同的估值方法来判断它们的估值：</p><ul><li>盈利稳定的指数。可采用盈利收益率法来估值，</li><li>盈利成高速增长态势的指数。可采用博格公式法来判断估值。</li><li>盈利处于不稳定状态，或呈周期性变化，<strong>但行业没有长期亏损纪录的指数。</strong>可采用博格公式的市净率来判断估值。</li><li>长期亏损的指数。直接放弃吧。</li></ul><table><thead><tr><th style="text-align:center">估值方法</th><th style="text-align:center">适用的指数</th></tr></thead><tbody><tr><td style="text-align:center">盈利收益率法</td><td style="text-align:center">上证50指数、上证红利指数、中证红利指数、基本面50指数、央视50指数、上证50AH优选指数、恒生指数、h股指数</td></tr><tr><td style="text-align:center">博格公式法（市盈率）</td><td style="text-align:center">沪深300指数、中证500指数、创业板指数、红利机会指数、必须消费行业指数、医药行业指数、可选消费行业指数、养老产业指数</td></tr><tr><td style="text-align:center">博格公式法（市净率）</td><td style="text-align:center">证券行业指数、金融行业指数、非银金融行业指数、地产行业指数</td></tr></tbody></table><p>也可以通过微信小程序且慢指数估值来查看。</p><h2 id="指数基金的买卖策略"><a href="#指数基金的买卖策略" class="headerlink" title="指数基金的买卖策略"></a>指数基金的买卖策略</h2><p>指数基金的投资策略，大体上是在低估时买入，高估时卖出，同时再辅以<strong>定期不定额定投</strong>方法来提高收益率。</p><p><strong>盈利收益率法+定投：</strong> </p><ul><li><strong>当盈利收益率大于10%时，开始定投。</strong></li><li><strong>当盈利收益率小于6.4%时，分批卖出。（这里采用6.4%是参考长期国债的收益率。如果指数的盈利收益率还不足6.4%的话，就可以将指数基金卖出换成债券。）</strong></li></ul><p><strong>博格公式法+定投：</strong></p><ul><li><strong>在市盈率或市净率处于历史底部区域时，坚持定投。</strong></li><li><strong>市盈率或市净率进入正常估值区域时暂停定投，继续持有，可以定投其他处于底部区域的品种。</strong></li><li><strong>市盈率或市净率进入历史较高区域时分批卖出。</strong></li></ul><h2 id="提升收益的投资技巧"><a href="#提升收益的投资技巧" class="headerlink" title="提升收益的投资技巧"></a>提升收益的投资技巧</h2><ul><li><p><strong>降低交易基金的费用。</strong></p></li><li><p><strong>正确处理基金分红。</strong>基金分红和资本利得是投资指数基金的两个主要收益来源。所以我们可以根据指数的估值对基金分红进行再投入或者取出。</p></li><li><p><strong>定期不定额。</strong> 其中采用盈利收益率估值的指数可采取下列公式来计算定投金额：<br>$$<br>首次低估时的定投资金\times(\frac{当月的盈利收益率}{首次的盈利收益率})^n<br>$$</p></li></ul><p>采用博格公式估值的指数可采取下列公式来计算定投金额：<br>$$<br>首次低估时的定投资金\times(\frac{首次的市盈率}{当月的市盈率})^n<br>$$</p><p>$$<br>首次低估时的定投资金\times(\frac{首次的市净率}{当月的市净率})^n<br>$$</p><p>上面的公式中的<code>n</code>为定投金额的放大器，一般来说<code>n</code>取1即可，资金足够的情况下可以取2。</p><h2 id="资产配置"><a href="#资产配置" class="headerlink" title="资产配置"></a>资产配置</h2><ul><li>拿出每月除去生活开销所剩余的钱的一半用于投资指数基金，因为这部分钱需要长期用来投资。</li><li>剩下的一般可以用来生活应急，投资货币基金。</li><li>家庭资产配置需要有30%以上的资金投资证券资产才会对家庭资产有较为明显的提升作用。</li><li>没有低估指数基金可供投资时可选取债券基金。同时也可作为资产配置的一项来降低资产组合的波动。</li><li>选择债券基金的方法：利率低位选短期，利率高位选长期。同时它可以随时投资，出现浮亏可以补仓拉低成本。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一本从价值投资逻辑介绍指数基金投资的好书。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="银行螺丝钉" scheme="http://yoursite.com/tags/%E9%93%B6%E8%A1%8C%E8%9E%BA%E4%B8%9D%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>Objectives and Key Results</title>
    <link href="http://yoursite.com/2018/09/02/2018%E7%A7%8B%E5%AD%A3OKR/"/>
    <id>http://yoursite.com/2018/09/02/2018秋季OKR/</id>
    <published>2018-09-02T12:02:12.000Z</published>
    <updated>2020-03-30T15:09:43.505Z</updated>
    
    <content type="html"><![CDATA[<p>​                                          <strong>2018秋季目标管理表格</strong> </p><p><img src="/2018/09/02/2018秋季OKR/图片1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​                                          &lt;strong&gt;2018秋季目标管理表格&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/09/02/2018秋季OKR/图片1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="谷歌目标管理法" scheme="http://yoursite.com/categories/%E8%B0%B7%E6%AD%8C%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86%E6%B3%95/"/>
    
    
      <category term="OKR" scheme="http://yoursite.com/tags/OKR/"/>
    
  </entry>
  
  <entry>
    <title>Java基本类型与类加载、方法调用</title>
    <link href="http://yoursite.com/2018/08/15/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E3%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/15/Java基本类型与类加载、方法调用/</id>
    <published>2018-08-15T12:02:12.000Z</published>
    <updated>2020-03-30T15:09:43.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-Java代码的运行方式"><a href="#一、-Java代码的运行方式" class="headerlink" title="一、 Java代码的运行方式"></a>一、 Java代码的运行方式</h2><h3 id="1-Java程序需要运行在虚拟机中"><a href="#1-Java程序需要运行在虚拟机中" class="headerlink" title="1. Java程序需要运行在虚拟机中"></a>1. Java程序需要运行在虚拟机中</h3><p>Java虚拟机为java程序的运行提供了一个软件环境，这样做的好处是，可以使Java程序在不同的硬件平台上运行。Java程序被编译成为字节码文件后，只要在不同的平台上安装好Java虚拟机就可以运行了。</p><p>同时，Java虚拟机还为Java程序提供了一种托管环境，这个环境可以给Java程序提供一些很便捷的功能，如垃圾回收和自动内存管理等</p><a id="more"></a><h3 id="2-Java虚拟机如何运行字节码"><a href="#2-Java虚拟机如何运行字节码" class="headerlink" title="2. Java虚拟机如何运行字节码"></a>2. Java虚拟机如何运行字节码</h3><p>JVM运行Java程序，首先需要将它的class文件加载至内存的方法区中。在运行时，会执行方法区内的代码。Java的对象存在堆内存中，在栈内存中又分为面向本地方法的本地方法栈和面向Java方法的Java方法栈，以及记录每个线程执行位置的PC寄存器，JVM会在当前线程的Java方法栈中生成一个栈帧。每次执行一个方法，相当于栈帧的进栈和出栈。</p><p><img src="/2018/08/15/Java基本类型与类加载、方法调用/微信截图_20180811161053.png" alt=""></p><p>从硬件的角度来讲，机器是不能直接执行java字节码的。因此，jvm需要交java字节码翻译成机器码。在HotSpot里面，翻译成机器码的过程有两种方式，一种是解释执行，即逐条将字节码翻译成机器码。一种是即时编译（JIT），教一个方法中所有的字节码，全部编译成机器码之后再执行。解释执行的优势在于无需等待编译，而即时编译方式的优势在于，实际执行速度更快。</p><p><img src="/2018/08/15/Java基本类型与类加载、方法调用/微信截图_20180827220520.png" alt=""></p><p>在HotSpot中，将需要多次执行的热点代码，使用即时编译的方式执行。将执行次数小于15次定义为非热点代码，这一部分代码是通过解释执行的方式执行。</p><h2 id="二、基本类型"><a href="#二、基本类型" class="headerlink" title="二、基本类型"></a>二、基本类型</h2><p>在JVM中，变量存储的数据是可以超出它定义的范围的。boolean类型的数据在JVM中被翻译为1和0，但是我们可以通过修改字节码的方式，将2存储为boolean数据。</p><p><img src="/2018/08/15/Java基本类型与类加载、方法调用/微信截图_20180827221654.png" alt=""></p><ul><li>值域小的数据类型向值域大的类型转换时，是不需要进行数据强转的。</li><li><strong>基本类型的包装类型之间是无法进行强制转换。</strong> </li><li>java中的正无穷和负无穷，都是有明确的数值的。在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000。超出了正无穷和负无穷之间的其他数字对应的浮点数是<code>NaN</code>。</li><li><code>NaN</code>和任何一个浮点数（不管是0还是NaN）比较时，除了<code>!=</code>返回<code>true</code>以外，其他均返回<code>false</code>。</li></ul><h3 id="1-存储"><a href="#1-存储" class="headerlink" title="1.存储"></a>1.存储</h3><p>在java的方法栈帧中分为局部变量区和字节码的操作数栈。局部变量就相当于一个数组，除了long和double占两个数组单元以外，其他基本数据类型都只占用一个数组单元（32位是4个字节，64位是8个字节），也就是说，其他数据类型都和int型一样，在栈帧中占4个字节（64位的HotSpot占8个字节）。注意：<strong>这里是指在栈里面，而在堆中的字段或数据里面byte、char、short分别占有一个字节，两个字节，两个字节。 也就是说跟它们的值域是相吻合的。</strong></p><p>一个int型的数据存储进字段或数组中时，是会进行隐式的的掩码操作。举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位字节会被截掉。同样，对于boolean类型来说，在存储时会显示的进行掩码操作，只取最后一位存入字段或数组中。</p><h3 id="2-加载"><a href="#2-加载" class="headerlink" title="2.加载"></a>2.加载</h3><p>我们需要将堆中全部数据加载到栈中计算，也就是说我们需要将boolean、byte、char、short加载到操作数栈中，而后将栈中的数值当成int型来计算。对于char和byte来说，无符号型数据加载伴随着0扩展。char占有两字节，会被复制到栈中的低两字节，高两字节则用0补充。</p><p>同理，对于有符号类型的数据加载则进行符号扩展，高两字节用符号位填充。</p><h2 id="三、类加载"><a href="#三、类加载" class="headerlink" title="三、类加载"></a>三、类加载</h2><p>类的加载过程主要是三大步骤。分别为加载、链接和初始化。</p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>加载的过程就是查找字节流，并且创建这个类。加载需要借助类加载器。在JVM中，类加载器使用双亲委派模式，收到一个类加载请求之后，需要先转派给父类加载器，父类加载器没有找到所请求的类的情况下，子类加载器才会尝试去加载。</p><p>最基础的类加载器是启动类加载器（boot classLoader），它是由C++实现的，没有对应的Java对象，因此只能用null来代表它。除了启动类加载器以外，其他的类加载器都是java.lang.ClassLoader的子类，这些类加载器都需要启动类加载器加载进JVM中才能使用。</p><p>除了启动类加载器以外，还有一些较为重要的加载器如扩展类加载器和应用类加载器。<strong>扩展类加载器的父类是启动类加载器，应用类加载器的父类是扩展类加载器。</strong> 默认情况下，应用程序中的类是由应用类加载器加载的。我们可以自己实现类加载器来完成自定义的一些功能，如class文件的加密解密等。</p><p>JVM中，类的唯一性是由类加载器实例以及类的全名一同确认的。所以同一段字节码，被两个类加载器加载之后也会得到两个不同的类。</p><p>相当于造房子的时候，找到一个老师傅来在一个地址上开始创建过程。</p><h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h3><p>链接又分为验证，准备和解析三个阶段。</p><p>验证是为了确保被加载的类能够符合JVM的约束条件。相当于上报监管部门审批造房。</p><p>准备是为了给被加载类的静态字段分配内存。相当于盖好了毛坯房。</p><p>解析是为了将被加载类的类成员、字段等符号引用解析成实际引用。如果符号引用指向的是一个未被加载的类，那么解析会出发那个类的加载，但不一定出发类的链接和初始化。这里的符号引用是指，编译器在编译的时候将被引用的字段、类、方法生成一个符号引用来代替它本身。而将符号引用解析未实际引用就是将在字节码中的符号引用替换位在JVM中的实际内存地址。</p><p>如果将这段话放在盖房子的语境下，那么符号引用就好比，“张三的房子”这种说法。不管他存不存在，我们都可以用这种说法来指代张三的房子，实际应用则好比是实际的通讯地址，如果我们想要与张三通信，那么必须要将“张三的房子”变成实际的通讯地址。如果这个实际的通讯地址不存在，则需要启动张三的盖房子过程的第一步，即选择好师傅在一个地址上开始创建。</p><h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h3><p>静态代码块中的代码和直接赋值操作被编译器放置在同一个方法中，叫做<clinit>。</clinit></p><p>类的初始化便是为常量值字段赋值以及执行<clinit>方法。</clinit></p><h2 id="四、方法调用"><a href="#四、方法调用" class="headerlink" title="四、方法调用"></a>四、方法调用</h2><h3 id="1-重载、重写、动态绑定与静态绑定"><a href="#1-重载、重写、动态绑定与静态绑定" class="headerlink" title="1. 重载、重写、动态绑定与静态绑定"></a>1. 重载、重写、动态绑定与静态绑定</h3><ul><li><strong>不建议重载可变长参数的方法。</strong>因为这可能会导致java编译器无法确定应该调用哪个目标方法。</li><li>java编译器在编译的时候已经区分了重载，所以我们可以认为在jvm里面不存在重载这个概念。</li><li>jvm中的动态绑定指的是需要在运行过程中，根据<strong>调用者的动态类型</strong>来识别目标方法。而静态绑定指的是在解析时便能够直接识别目标方法的情况。</li></ul><p>java字节码中调用相关的指令共有五种:</p><ul><li><code>invokestatic</code>:用于调用静态方法。</li><li><code>invokespecial</code>:用于调用私有实例方法，构造器，以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法。</li><li><code>invokevirtual</code>:用于调用非私有实例方法。</li><li><code>invokeinterface</code>:用于调用接口方法。</li><li><code>invokedynamic</code>:用于调用动态方法。</li></ul><p>对于<code>invokevirtual</code> 和<code>invokedynamic</code> 虚拟机需要在执行过程中，根据调用的动态类型来确定具体的目标方法。也就是说这两个编译指令，需要使用动态绑定。</p><p>对于静态绑定而已，符号引用被解析成实际引用时，这个实际引用是一个指向方法的指针。对于动态绑定而言，实际引用则是一个方法表的索引。</p><h3 id="2-动态绑定"><a href="#2-动态绑定" class="headerlink" title="2. 动态绑定"></a>2. 动态绑定</h3><p>在JVM中，静态绑定包括用于调用静态方法的<code>invokestatic</code>指令和用于调用构造器，私有实例方法以及父类非私有实例方法的<code>invokespecial</code> 指令。如果虚方法调用指向一个标记为final的方法，那么JVM也可以静态绑定该虚方法调用的目标方法。</p><ol><li>方法表</li></ol><p>在类加载的时候，除了为静态字段分配内存以外，还会构造与该类相关的方法表。</p><p>方法表的本质是一个数组，每个数组元素指向一个当前类以及其父类中非私有实例方法。对于动态绑定而言，实际引用则是方法表的索引值。</p><p>在执行过程中，JVM将获取调用者的实际类型，并在实际类型的虚方法表中，根据索引值获得目标方法，这个过程便是动态绑定。</p><ol start="2"><li>内联缓存</li></ol><p>内联缓存，本质上是一种加快动态绑定的技术。它能够缓存虚方法的调用者动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果已经到缓存过的类型，内联缓存便会直接调用该类型所对应的目标方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、-Java代码的运行方式&quot;&gt;&lt;a href=&quot;#一、-Java代码的运行方式&quot; class=&quot;headerlink&quot; title=&quot;一、 Java代码的运行方式&quot;&gt;&lt;/a&gt;一、 Java代码的运行方式&lt;/h2&gt;&lt;h3 id=&quot;1-Java程序需要运行在虚拟机中&quot;&gt;&lt;a href=&quot;#1-Java程序需要运行在虚拟机中&quot; class=&quot;headerlink&quot; title=&quot;1. Java程序需要运行在虚拟机中&quot;&gt;&lt;/a&gt;1. Java程序需要运行在虚拟机中&lt;/h3&gt;&lt;p&gt;Java虚拟机为java程序的运行提供了一个软件环境，这样做的好处是，可以使Java程序在不同的硬件平台上运行。Java程序被编译成为字节码文件后，只要在不同的平台上安装好Java虚拟机就可以运行了。&lt;/p&gt;
&lt;p&gt;同时，Java虚拟机还为Java程序提供了一种托管环境，这个环境可以给Java程序提供一些很便捷的功能，如垃圾回收和自动内存管理等&lt;/p&gt;
    
    </summary>
    
      <category term="JVM基础" scheme="http://yoursite.com/categories/JVM%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>见识</title>
    <link href="http://yoursite.com/2018/08/12/%E8%A7%81%E8%AF%86/"/>
    <id>http://yoursite.com/2018/08/12/见识/</id>
    <published>2018-08-12T11:13:40.000Z</published>
    <updated>2020-03-30T15:09:43.789Z</updated>
    
    <content type="html"><![CDATA[<p>《见识》这本书是偶然从一个公众号的文章推送里面得知的。后来得知是吴军写的便直接买回来看看。写这篇文章是为了记录下读了这本书之后所收获到的几点。</p><p>从整体上来说，这本书阐述了吴军老师对人生、对职业、对投资的思考和建议。</p><a id="more"></a><h2 id="一、关于人生"><a href="#一、关于人生" class="headerlink" title="一、关于人生"></a>一、关于人生</h2><p>从这个角度来说，我喜欢这本书的第一章标题，叫做<strong>幸福是目的，成功是手段。</strong>这章里面作者说，一个人需要相信自己的命运。而关于命，每个人是有不同的理解。</p><blockquote><p>命运取决于两个因素，一个是环境因素，是由我们的出身和环境来决定的。而另一个是我们自己对未来走向的规划，这一点是我们自己努力博弈出来的。所谓的命，我们能掌握的就是一个人看问题和做事情的方法，仅此而已，但是他们决定了一个人的一生。</p></blockquote><p>一个人的出生、生活环境和他受到的教育都会对他整个人生的命运产生非常大的影响。而我们常说”命运是掌握在自己的手里“指的是我们可以规划自己的未来方向，通过自己的努力获得想要的人生。对于一个普通人来说，想要逆袭是非常难，非常难的一件事情。作者在书中举了个例子说你可能需要花半辈子时间，来弥补自己的不足。然后再花半辈子的时间来追赶别人。因为别人的先天条件比你好的话，那么可能他只要付出三分的努力，就可以达到你付出十分努力所带来的效果。因此你必须要花很长的时间来弥补自己的不足，然后再努力的去追赶人家的脚步。</p><h3 id="1-对男生女生的建议"><a href="#1-对男生女生的建议" class="headerlink" title="1.对男生女生的建议"></a>1.对男生女生的建议</h3><p>人生最重要的投资其实是投资自己。对男生来说，选择好一个配偶十分重要。一个女生，她所表现出来的气质涵养，实际上跟她的家庭有很大的关系。选择一个聪明的跟你价值观完全相符合的女生，这对于你自己人生的未来会大有裨益。同时，男生需要有足够的独立性，承担自己未来对家庭的义务。在一段婚姻中，双方都需要明白关系的亲密程度和重要性依次是<strong>“夫妻优先于子女，更优先于双方的父母。”</strong></p><p>有很多人觉得结婚是两个家庭的事情。然而在这本书里面，作者说，婚姻它并不一定是两个家庭的事情，而是两个人要分得清楚大家和小家。两个人在婚姻中需要分清大家和小家之间的边界。</p><blockquote><p>一个人，特别是年轻的时候，可塑性非常重要。两个人在一起时间一长，肯定会遇到矛盾，能够有一些柔韧，彼此妥协的解决问题，相互适应，才能更好、更长远的走下去。</p></blockquote><p>对于女生来说，需要分清楚婚姻与恋爱的不同。恋爱是激情，是化学物质分泌所带来的愉悦；而婚姻则是两个人共同构造一个舒适体。在这个舒适体中，双方都会受益，彼此成长。不要总觉得老实的男人才能靠的住，或者找一个自己可以控制的人。因为你会发现很多身边看似老实的男人，会做出一些让你们大跌眼镜的事情。其实这些东西它本质上并没有什么意外的，因为人性就摆在那里。女生应该靠自己的能力去辨别一个，对自己好的男生。而对自己好，不应该靠男生怎么说来评判，要去发现他是怎么做。需要判断这个人的价值观和爱情观是否与自己相符，是否认可夫妻间的关系的重要性高于其他关系的重要性。只要仔细观察就可以发现他对你们之间关系的在乎程度。</p><blockquote><p>当然，一个男生最终能否对你好，还要看他有没有这个能力。因为大部分男生都会描绘一个美好的未来，但是很多人根本无力去实现它。</p></blockquote><h3 id="2-做人和作诗"><a href="#2-做人和作诗" class="headerlink" title="2.做人和作诗"></a>2.做人和作诗</h3><p>最近我在办公室中，跟一些同事玩得越来越熟。有些同事会说我是一个很会说话的人。当我听到他们这样评价我的时候，其实我的内心对自己多少是有点失望的。因为我知道自己不是个情商很高的人，我只是会偶尔抖个机灵，然后不向别人吝啬我的赞美。可能这些东西在别人的眼中，会有拍马屁的倾向。在这本书里面，作者把这些东西称之为会做人。在这个社会中并不缺会做人的人，但是缺会做诗的人。</p><p>这里的作诗指的是，他们有一种理想主义式的叛逆精神。在我的理解里，这大概是一种纯粹的理想主义。有一些了解我的朋友，可能因为觉得我喜欢老罗而认为我是个很理想主义的人。但是我其实更倾向于把自己归结为是一个现实理想主义者。我非常的认同和赞美理想主义精，但是我觉得脱离了现实的理想主义行为，是一种非常不理智的，甚至会给自己和家人带来生活上的窘境的行为。当然我更不喜欢那些把自己利益看得很重的精致利己主义者。我喜欢的是像鲁迅那样，一边拿着国民政府的钱，一边去骂国民政府。大概我的信条是应该在很多事情上有着理想主义的原则，但是不能脱离现实而活着。守住自己的底线，照顾好自己的家人，而不是用一种很幼稚的理想主义行为去跟这个丑恶世界进行搏斗。</p><h3 id="3-非线性增长"><a href="#3-非线性增长" class="headerlink" title="3.非线性增长"></a>3.非线性增长</h3><p>这本书的第四章叫做大家智慧。作者写了一些名人的故事，他告诉我们，<strong>做事情要认清成本并且看透本质。</strong>关于看透本质这件事情，我有另外个理解，叫做非线性增长。这是我从投资理念中学来的，不管是人生还是投资，在很多的时候都不是一个线性增长的过程。它是一个缓慢的由量变累积产生质变的非线性增长过程。它需要前期不断的进行投入累积，达到了临界点之后，发生一个突变带来很多的回报。所以我们需要看透这个增长过程的本质是非线性的，并不是投入多少就会得到多少回报。而是需要找到那个临界点，不断的积累，之后就会产生质变获得很大的收益。</p><p>就拿工作这件事情来说，工资的增长并不是线性的，它是一个人内在价值的外在定价。所以说，作者给毕业生的建议是，在工作的前三年不要太去关注工资多少，而需要关注的是自己内在价值的提升。你自己的内在价值才是工资的本质。等过了几年工作上有了很好的工作经验的累积和技能的提升。这些内在价值的积累产生质变就会体现在你的工资的大幅增长上，会很容易的翻倍增长。这一点跟延迟满足感也是同样的道理。就是说我们需要放弃前期短暂的满足感，而不断的积累，坚持到未来产生更大的收益。</p><h3 id="3-做好最后的1"><a href="#3-做好最后的1" class="headerlink" title="3.做好最后的1%"></a>3.做好最后的1%</h3><p>在做事情的时候，需要做好最后的1%。因为其实很多时候人与人之间的能力差距并没有那么大，但是正是这最后的1%却会拉开很大的差距。这一点是我需要始终铭记的，我在很多方面的最后1%都做的不够好。</p><h2 id="二、关于职业"><a href="#二、关于职业" class="headerlink" title="二、关于职业"></a>二、关于职业</h2><h3 id="1-职业误区"><a href="#1-职业误区" class="headerlink" title="1. 职业误区"></a>1. 职业误区</h3><p>在职业方面，作者给我最大的启发是：<strong>不要走入一个工作和职业分不清的误区。</strong></p><p>工作是谋生的手段，你去单位上班然后单位给了你一份工资就两清了。然而，职业却是需要从事一辈子的事情。为了这个一辈子的发展，应该选择性的做一些对职业有利的事情，不论是否有报酬或者报酬的高低。</p><p>对待自己的职业需要专业的工作态度。所谓的专业，就是一切以工作目标达成为中心，所有的会议、沟通都是以此为核心。不管在任何情况下，能够把事情做好才能够体现出你的职业素质。成为一个专业人士，也是我入职以后，邹总在给我们的新人培训中所提出的一点希望。希望我们能够专业人士的态度，把属于自己的每件事情做好，而不去考虑当前的一些短暂利益。</p><p>另外一个启发是：<strong>不要把自己当成一个单位的过客，而是将自己当成主人。</strong>对比我之前在恒生的工作经验来说，我其实从一开始入职恒生的时候，就想把恒生作为一个不错的跳板。其实这样的想法对我来说是非常不利的。在整个工作过程中，我并没有去做一个专业人士应该做的事情。所以我希望在以后我所经历的每一家公司，都有一种主人翁的意识。不仅仅需要把这当成是一份工作，而是当成我的职业来做。成为一个专业的人士，对我来说很重要。</p><p>为了避免陷入这些误区，作者给我们提出了几个解决办法：</p><ul><li>第一，任何时候都要为人谦卑，只有谦卑才能更有效的沟通。</li><li>第二，要用正确的方法对待语言暴力和其他故意伤害。</li><li>第三，永远要明确工作不是为了公司或者他人，而是为了自己的职业发展这个既定的大方向。想要成为领导者，要平实的学习做一个领导。走出自己的一亩三分地，主动的多做事情，多跟人打交道，去帮助他人，支持自己的老板和团队。</li><li>第四，注重长期效益，把一件事情放到2到3年的时间周期来看，这时候我们对它的态度就会完全的不同。永远在一家公司不要有过客心态，要抱着学本事的心态去专心的干事情。</li><li>第五，作为一个基层员工，需要有大局观。你不仅需要看到你工作中所专注的一些细节，你需要看到整个项目，整个团队是如何运行的。</li></ul><h3 id="2-伪工作者"><a href="#2-伪工作者" class="headerlink" title="2. 伪工作者"></a>2. 伪工作者</h3><p>作为一个程序员，我自然的想要在工作的时候追求效率减少加班。在这本书中，作者提出了我们要拒绝做一个伪工作者。</p><ul><li>我们首先需要确定，<strong>愿景-目标-道路。</strong>愿景就是说我们要确定一个明确的方向，然后在这个明确的方向上，我们需要设置一些阶段性的目标，战略的核心就是达到这些既定的目标，进而实现我们的愿景。</li><li>第二点是，即使听到了不中听的话也一定要虚心找出其中的合理之处。每次遇到别人和自己意见相左时，一定要开启寻找对方合理性的开关，这样会对你自己有很大的提升。</li><li>第三点时，凡事要做记录。做记录的过程其实是，有思考了一遍，这样会使得你进步更快。</li></ul><p>同时作者还分享了自己谷歌目标工作管理方法。将自己的年度目标，列成一个表格。然后再制作一个消耗跟踪曲线来跟踪自己的目标完成情况。</p><p><img src="/2018/08/12/见识/微信图片_20180812224407.jpg" alt=""></p><p><img src="/2018/08/12/见识/微信图片_20180812224419.jpg" alt=""></p><p><img src="/2018/08/12/见识/微信图片_20180812224424.jpg" alt=""></p><h2 id="三、关于投资"><a href="#三、关于投资" class="headerlink" title="三、关于投资"></a>三、关于投资</h2><h3 id="1-金钱观"><a href="#1-金钱观" class="headerlink" title="1.金钱观"></a>1.金钱观</h3><p>这本书的最后一部分作者关于投资的一些看法。每个人都需要有一个正确的金钱观和理性的投资观。首先是金钱观，在现实生活中，要有那种没有钱是万万不能的思想。如果太过理想的去抛弃了很多东西的话，只会让你的生活变得很糟糕，并且没有能力照顾你的家人。鲁迅先生自己曾讲，饭碗可以跟理想分开。每个人都需要在这个现实的世界中很好的生活下去，所以你需要努力的保住你的饭碗。这一点是非常重要的。</p><p>另外一点是：<strong>钱只有花出去了，才是你的。</strong>在很多时候，我们不应该吝啬自己。就我自己来说，凡是我觉得会提高自己生活品质的东西就肯定会买。但是我会根据自己的收入，来分配投资和消费的比例。因为有些东西，它并不是很紧急的。比如我最近一直想买的键盘和音箱，但是我这个月已经买了手机，而这些东西又不是非常紧急。所以，我可以把剩下的钱部分用作生活费，另一部分用作投资理财。等下个月的工资发下来之后，再去买键盘和音响。</p><h3 id="2-投资观"><a href="#2-投资观" class="headerlink" title="2.投资观"></a>2.投资观</h3><p>再来说说投资观。因为我的工作跟金融有关，同时我也很爱钱。所以很自然的对投资理财感兴趣。之前我读过一本书，它说你在投资的时候，首先需要确定的一点就是<strong>风险意识。</strong>我一开始并不知道怎么看待这个风险意识。但是关注了这个行业一段时间之后，就发现那些很著名的理财投资人，他们都会给自己和自己的家庭买上各种各样的保险。其实保险它的本质上就是转移你的生活风险。大家都知道，在现实生活中，一场疾病很可能会把一个家庭的财务状况给带入低估。但是如果我们提前配置了保险的话可能情况就会好很多，这就是风险意识的一种体现。</p><p>其实不仅是理财，在生活中的任何事情都有风险，如果我们提前有了风险意识，并且对可能发生的这些风险的情况，作出应对策略的话，那么我们就可以很好的应对生活中的那些未知情况。</p><p>这本书里作者提出的投资些思想和投资观点，跟我以前对于投资的认识是很相似的，比如专业人士并不一定会比我们自己投资做的好。</p><p>对于投资来说，最好的投资品种还是权益类产品。这里的权益类产品指的是债券、股票、指数基金等。从历史数据来看，不论是哪个国家，投资股市都是回报率最高的一种方式。而单个股票的投资风险是很高的，因为它存在于价值归零的可能。但是如果你投资指数基金的话，情况就完全不一样。你只要在指数低估的区间买入，然后长期持有或者定期投入的话，就可以获得一个相对不错的收益。所以对于普通的上班族来说，努力工作扩大每月的现金流，然后将每月的闲钱去投资到指数基金中，会给我们带来相对不错的受益。同时我们需要有足够的风险意识，给自己配置上保险来应对可能发生的亏损情况。</p><p><img src="/2018/08/12/见识/微信图片_20180812224340.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《见识》这本书是偶然从一个公众号的文章推送里面得知的。后来得知是吴军写的便直接买回来看看。写这篇文章是为了记录下读了这本书之后所收获到的几点。&lt;/p&gt;
&lt;p&gt;从整体上来说，这本书阐述了吴军老师对人生、对职业、对投资的思考和建议。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="吴军" scheme="http://yoursite.com/tags/%E5%90%B4%E5%86%9B/"/>
    
  </entry>
  
  <entry>
    <title>自私的基因</title>
    <link href="http://yoursite.com/2018/07/30/%E8%87%AA%E7%A7%81%E7%9A%84%E5%9F%BA%E5%9B%A0/"/>
    <id>http://yoursite.com/2018/07/30/自私的基因/</id>
    <published>2018-07-30T15:13:40.000Z</published>
    <updated>2020-03-30T15:09:43.769Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/07/30/自私的基因/s11214645.jpg" alt=""></p><p>这本书开始的时候，作者提出了达尔文进化论的物竞天择，适者生存中的“适者”到底是什么？是种群，个体，还是物种？都不是，在作者看来，基因是自然选择的单位。而所有的动物，植物，个体，都是基因控制的生存机器而已。基因的目的只有一个，那就是复制自己。所以，从这个角度出发，就有了这本书的名称——自私的基因。</p><a id="more"></a><p>基因的目的是为了让自己复制下去。所以他们选择了各种各样的策略，让自己尽可能的复制下去。那些会控制蛋白质给自己制造生存机器的基因则更大概率能在自然选择的情况下生存下去。所以自然选择使得制造生存机器的基因可以不断地复制，生存下来。于是，基因通过控制蛋白质合成的方式，来控制着生存机器。而基因无法知道，动物会在生存过程中遇到什么样的情况。所以它们会给这些动物，预先制定好策略。比如它们不知道北极熊出生后，会面临哪些遭遇。但是基因会给北极熊准备好厚厚的毛发，来帮助他们御寒。这就是基因的预测行为，它其实就像程序员写的代码一样。只是指定了固定模式下的蛋白质合成方式，而不去关心实际代码所处理的数据。</p><p>作者在这本书中又提到了进化稳定性策略（ESS），这种策略是一种自然选择上稳定性的策略，一旦一种稳定性策略确立起来之后，任何偏离这种策略的行为都会受到自然选择的惩罚。而这种策略的稳定性，并不在于它有利于这个群体中的个体，而是因为它的内部没有背叛行为。一个生物种群理论上可以达到多种稳定性策略，但是最终会以一种稳定性策略方式生存下去，这将取决于他们优先达到了哪一种稳定性策略。从基因的角度来说，基因库是由一组进化上稳定的基因形成的，这组基因成为一个不受任何新基因侵犯的基因库。而大部分因为基因突变、重新组合而产生的新基因，将会偏离这种稳定性策略，必然会受到自然选择的惩罚。但是新基因侵入一组稳定性基因库，偶尔也会获得成功。一旦成功，就会立马在基因库中散布开来，最终形成一组新的稳定性策略。按照这种进犯策略类推，一个种群可以从一个稳定性进化策略跳向另外一个稳定性进化策略。这就是进化的过程。</p><p>把个体动物视为独立的生存机器，便于理解进犯行为。但是如果有关个体是近亲的话，这一模式也许会失去效用，因为近亲体内存在着很大一部分共同的基因，而每一个基因同时需要忠于不同的个体。从基因的角度，也可以解释我们的近亲利他主义。如果一个个体为了拯救十个近亲而牺牲，操作个体对亲属表现利他行为的基因，就有可能因此失去一个拷贝，但同时，一个基因的大量拷贝却得以保存。从这个角度来说，父母之爱和兄弟姐妹的利他行为的形成，都可以用完全相同的原因来解释，在收益者体内存在这个利他性基因的可能性更大。</p><p>同时从自私的基因角度来看，很多生物界的动物会选择自发的计划生育。而他们这种行为的目的，其实是为了让自己后代的成活率更高，以保证自己的基因可以复制延续下去。</p><p>在父母与子女之间也存在着欺骗和自私行为，而这种行为正是自私基因的延伸。幼儿欺骗父母，为了获取更多的食物和理想的生存条件，是为了使基因可以复制下去。而父母防止幼儿欺骗，是为了使自己的基因，可以更好的复制到下一代身上去。因为父母能够能够给的资源是有限，而他们为了使自己的基因可以复制下去，必须选择性的将更多的资源给活下去可能性更大的子女。这些只是从基因的角度来说，不牵涉到任何有意识的行为。</p><blockquote><p>如果说我们从中有什么可以借鉴的话，那么就是我们必须把利他主义的美德，灌输到我们子女的头脑中去，因为我们不能指望他们的本性中有利他主义的成分。</p></blockquote><p>在自然界中，雌性的卵子比较珍贵，而雄性的精子相对廉价。所以雌雄两性为了使自己的基因有更大的可能性复制下去，他们分别进化出不同的策略来对抗对方。在书中，作者提到雌性可以选择大丈夫策略或者家庭幸福策略来选择自己的配偶。而雄性则会有不同的策略来对抗。</p><p>作者在书中还提出了一种新的复制基因。叫做meme(觅母)。作者认为，文化的传播和遗传相类似，即它能导致某种形式的进化。遗传的进化能以存在于一种稳定状态，向另一种稳定状态转变而取得进展。而觅母，从广义上说可以称为模仿过程，从一个大脑转向另一个大脑的过程。以这样的方式在觅母库中进行繁殖。觅母和基因一样，也是自私的。</p><blockquote><p>然而，即使我们着眼于阴暗面，假定人基本上是自私的。我们自觉的预见能力，能够防止自己纵容盲目的复制基因，干出那些最坏的、过分的自私行为。在必要时，我们也可以抗拒那些灌输到我们头脑里的自私觅母，我们甚至可以讨论如何审慎的培植纯粹的，无私的利他主义，这种利他主义在自然界里是没有立足之地的。在整个世界历史上也是前所未有的，我们是作为基因机器而被建造的，是作为觅母机器而被培养的，但我们具备足够的力量去反对我们的缔造者，在这个世界上只有我们，我们人类，能够反抗自私的复制基因的暴政。</p></blockquote><p>关于自然界中的互惠利他行为，作者也通过自私基因的角度来给出了解释。这里作者提出了，一个经典的，博弈论概念。叫做囚徒困境。在简单的囚徒困境中。无论怎么算，最好的策略是永远背叛，因为这是个零和博弈。然而所幸，在自然界中，我们并不是处于简单的囚徒困境中，而是充满了囚徒困境的重复博弈，这是一个非零和博弈。在有记忆的生物中，对于这种囚徒困境的重复博弈，我们最好的策略是：<strong>合作与互助 </strong>。也就是说，<strong>好人终有好报。</strong> </p><p><img src="/2018/07/30/自私的基因/微信图片_20180731232134.jpg" alt=""></p><p>一想到人一生下来就有太多的东西是受基因控制的，就不免感到有点悲哀。我们的一切行为，所有的本能和心理因素都受着基因的影响，不过所幸，我们是可以反抗的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/07/30/自私的基因/s11214645.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这本书开始的时候，作者提出了达尔文进化论的物竞天择，适者生存中的“适者”到底是什么？是种群，个体，还是物种？都不是，在作者看来，基因是自然选择的单位。而所有的动物，植物，个体，都是基因控制的生存机器而已。基因的目的只有一个，那就是复制自己。所以，从这个角度出发，就有了这本书的名称——自私的基因。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="理查德道金斯" scheme="http://yoursite.com/tags/%E7%90%86%E6%9F%A5%E5%BE%B7%E9%81%93%E9%87%91%E6%96%AF/"/>
    
  </entry>
  
</feed>
