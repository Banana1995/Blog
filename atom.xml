<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小蚂蚁爱吃香蕉</title>
  
  <subtitle>It&#39;s what you do in the dark puts you in the light</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-04T14:30:20.668Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小蚂蚁爱吃香蕉</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARTS打卡第七周</title>
    <link href="http://yoursite.com/2019/05/26/ARTS-7/"/>
    <id>http://yoursite.com/2019/05/26/ARTS-7/</id>
    <published>2019-05-26T15:46:39.000Z</published>
    <updated>2019-06-04T14:30:20.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第七周"><a href="#ARTS第七周" class="headerlink" title="ARTS第七周"></a>ARTS第七周</h1><p>本次ARTS主要包括：最大同值路径问题算法；读完《Java并发编程艺术》整书的思维导图；VIM编程技巧关于上下移动一行和向上或向下查询当前游标下的单词等操作；</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p>168.Longest Univalue Path</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Integer res =<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestUnivaluePath</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        recurisionMethod(root);</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">recurisionMethod</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = recurisionMethod(root.left) ;</span><br><span class="line">        <span class="keyword">int</span> right = recurisionMethod(root.right);</span><br><span class="line">        <span class="keyword">if</span>(root.left !=<span class="keyword">null</span> &amp;&amp; root.left.val == root.val)&#123;</span><br><span class="line">            left = left +<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left =<span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.right !=<span class="keyword">null</span> &amp;&amp; root.right.val == root.val)&#123;</span><br><span class="line">            right= right+<span class="number">1</span>;</span><br><span class="line">        &#125;   <span class="keyword">else</span>&#123;</span><br><span class="line">            right=<span class="number">0</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        res = Math.max(res,left+right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最长同值路径问题。自己没有做出来，看了题解的思路。对于递归的问题，我解起来还是比较费劲的。另外就是犯了一个java方法传递值得问题。此处的结果需要定义成全局变量，不能使用一个int类型作为参数传递。因为java是值传递而不是引用传递。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p> continue reading 《effective java》</p><ul><li><p>Item 12 : Always override toString</p><blockquote><ol><li>Providing  a good toString implementation makes your class much more pleasant to use and makes systems using the class easier to debug.</li><li>When practical, the toString method should return all insteresting information contained in the  object.</li><li>Whether or not you decide to specify the format , you should clearly document you intentions.</li><li>Whether or not you specify the format, provide programmatic access to the information contained in the value returned by toString.</li></ol></blockquote></li><li><p>Item 13 : Override clone judiciously</p><blockquote><ol><li>Though the specification doesn’t say it , in practice , a class implementing Cloneable is expected to provide a properly functioning public clone method. And the class and all of its superclass should obey a complex , unenforceable,thinly docemented protocol to achieve that.</li><li>You can use <code>throw new CloneNotSupportedException();</code> for degenerate clone implementation.</li><li>To recap, all classes that implement Cloneable should override clone with a public method whose return type is the class itself. This method should first call <code>super.clone</code>, then fix any fields tha need fixing. Typically, this means copying any mutable objects that comprise the internal “deep structure” of the object and replacing the clone’s references to these objects with references to their copies.</li><li>A better approach to object copying is to provide a <strong><em>copy constructor</em></strong> or <strong><em>copy factory</em></strong>. A notable exception to this rule is arrays, which are best copied with the clone method.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>vim编程技巧：</p><p>使用<code>#</code>可以自动向上查询当前游标下的单词；</p><p>使用<code>*</code>可以自动向下查询当前游标下的单词；</p><p>使用<code>ctrl</code>+<code>e</code>可以向上翻滚一行；</p><p>使用<code>ctrl</code>+<code>y</code>可以自动向下翻滚一行；</p><p>使用<code>zz</code>可以将当前行移动到屏幕中央。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周阅读完了《Java并发编程艺术》这本书，将其全部的思维导图贴出：</p><p><img src="/2019/05/26/ARTS-7/Java并发编程的艺术.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第七周&quot;&gt;&lt;a href=&quot;#ARTS第七周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第七周&quot;&gt;&lt;/a&gt;ARTS第七周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：最大同值路径问题算法；读完《Java并发编程艺术》整书的思维导图；VIM编程技巧关于上下移动一行和向上或向下查询当前游标下的单词等操作；&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第六周</title>
    <link href="http://yoursite.com/2019/05/09/ARTS-6/"/>
    <id>http://yoursite.com/2019/05/09/ARTS-6/</id>
    <published>2019-05-09T15:05:39.000Z</published>
    <updated>2019-06-04T14:30:20.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第五周"><a href="#ARTS第五周" class="headerlink" title="ARTS第五周"></a>ARTS第五周</h1><p>本次ARTS主要包括：Excel列名称算法题；《Java并发编程艺术》内存模型的思维导图；《effective java》中关于重写hashcode方法的章节。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p>168.Excel表列名称</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String contanier = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line">        <span class="keyword">int</span> temp =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">26</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(contanier.charAt(n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb =  <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        List&lt;String&gt; te = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            temp = (n-<span class="number">1</span>)%<span class="number">26</span>;</span><br><span class="line">            n=(n-<span class="number">1</span>)/<span class="number">26</span>;</span><br><span class="line">            te.add(String.valueOf(contanier.charAt(temp)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j= (te.size()-<span class="number">1</span>);j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            sb.append(te.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的思路是对26取余，从低到高位，一位一位的取。其中的<code>n-1</code>将整除26的数取不到Z字母的问题解决了。</p><p>见到题解中有同学使用<code>&#39;A&#39;+数字</code>来取值，引发了我对char类型数据的思考：char占有2个字节，用16位表示Unicode编码。可以使用’A’加上一个整数来表示其编码的字符，如’A’+1则表示’B’这个字符。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p> continue reading 《effective java》</p><ul><li><p>Item 11 : Always override hashCode when you override equals</p><blockquote><ol><li>You must override hashCode method in every class that overrides equals.Here are the contract,adapted from the Object specification:<ul><li>when the hashCode method is invoked on an object repeatedly during an execution of an application, it must consistently return the same value.</li><li>if two objects are equal according to the equals method , then calling hashCode on the two  objects should return the same integer result.</li><li>if two objects are unequal according to the equals method , it is <strong>not required</strong> that calling hashCode method return distinct value.However, the programmer should be aware that producing distinct results for unequal objects may improve the performance of hash tables.(cause the same hashCode value can make the hashtable degenerate to linked list).</li></ul></li><li>A good hash function tends to produce unequal hash codes for unequal instances.</li><li>When you compute the hash codes , you <strong>must exclude</strong> any fields that are not used in equals comparisons, or you risk violating the second provision of the hashCode contract.</li><li>If you have a bona fide need for hash functions less likely to produce collisions , see Guava’s <code>com.google.common.hash.Hashing</code></li><li>if a class if immutable and the cost of computing the hash code is significant, you might consider caching the hash code in the object rather than recalculating it each time it is requested.</li><li>Do not be tempted to exclude significant fields from the hash code computation to improve perfoemance.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>无</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周新增了《并发编程的艺术》第三章内存模型相关内容的思维导图</p><p><img src="/2019/05/09/ARTS-6/Java并发编程的艺术.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第五周&quot;&gt;&lt;a href=&quot;#ARTS第五周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第五周&quot;&gt;&lt;/a&gt;ARTS第五周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：Excel列名称算法题；《Java并发编程艺术》内存模型的思维导图；《effective java》中关于重写hashcode方法的章节。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第五周</title>
    <link href="http://yoursite.com/2019/05/05/ARTS-5/"/>
    <id>http://yoursite.com/2019/05/05/ARTS-5/</id>
    <published>2019-05-05T15:15:09.000Z</published>
    <updated>2019-06-04T14:30:20.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第五周"><a href="#ARTS第五周" class="headerlink" title="ARTS第五周"></a>ARTS第五周</h1><p>本次ARTS主要包括：回文数、最长公共前缀算法、《effective java》关于复写equals方法的Item、VIM使用文本对象选择选区操作、《Java并发编程艺术》前两章的思维导图。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="9"><li>回文数</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rightToLeft =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> te =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = x;</span><br><span class="line">        <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">            te = y%<span class="number">10</span>;</span><br><span class="line">            rightToLeft = rightToLeft*<span class="number">10</span>+te;</span><br><span class="line">            y=y/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==rightToLeft)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚好昨晚刷题刷到了整数反转的题目，这里顺手一上来就想到了使用整数反转的方式来做。果然效果很不错。对于整数溢出的问题其实可以不用担心，因为回文数字肯定不会溢出。</p><blockquote><ol start="14"><li>最长公共前缀</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;;j++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag =<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span> publicChar = <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">if</span>(strs[<span class="number">0</span>]!=<span class="keyword">null</span> &amp;&amp; strs[<span class="number">0</span>].length()&gt;=j+<span class="number">1</span>)&#123;</span><br><span class="line">                publicChar = strs[<span class="number">0</span>].charAt(j);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">                String te = strs[i];</span><br><span class="line">                <span class="keyword">if</span>(te!=<span class="keyword">null</span> &amp;&amp;  te.length()&gt;=j+<span class="number">1</span> &amp;&amp; publicChar==te.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag )&#123;</span><br><span class="line">                res.append(publicChar);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始写的时候没有考虑到String获取长度的是length()方法与数组的length调用方式是不同的，导致编译未通过。后来测试案例又未通过<code>&quot;&quot;</code>的校验。测试了一番之后才知道<code>&quot;&quot;</code>的长度为0，在调用length()方法后，应该判断的条件是字符串的长度大于数组下标+1的值。</p><p>我的这个算法的最坏的时间复杂度为O(m*n)，m为数组的长度，n为公共前缀的字符数。查看了题解后发现与题解中的算法二思路相同，但是代码实现没有它的简单。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java 》</p><ul><li><p>Item 10 Obey the general contract when overriding equals</p><blockquote><ul><li>Each instance of the class is inherently unique.</li><li><strong>There is no need for the class to privide a “logical equality” test.</strong> For example,<em>java.util.regex.Pattern</em> could have overridden equals to check whether two Pattern instances represented exactly the same regular expression.But the client user doesn’t need this function.</li><li>A superclass has already overriden equals, and the superclass behavior is approriate for this class.For example, most Set implementations inherit their equals implementation from AbstractSet, List implementations from AbstractList, and Map implementations from AbstractMap.</li><li><strong>It’s  appropriate for you to overriden equal method when a class has a notion of <em>logical equality</em> that differ from mere object identity and a superclass has not already overridden equals.</strong> This is generally the case for value classes. A value class is simply a class that represents a value, such as Integer or String. A clent user need invoke equals method to find out whether they are logically equivalent or they refer to same object.</li><li>Here are some contract for overriden the <em>equals method</em>. <ul><li>Reflexive: For any non-null reference value x, x.equals(x) must return true.</li><li>Symmetric: For any non-null reference values x and y, x.equals(y) must return true if and only if y.equals(x) returns true.</li><li>Transitive: For any non-null reference values x, y, z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) must return true.</li><li>Consistent: For any non-null reference values x and y, multiple invocations of x.equals(y) must consistently return true or consistently return false, provided no information used in equals comparisons is modified.</li><li>For any non-null reference value x, x.equals(null) must return false.</li></ul></li></ul></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在使用vim编辑时，可以使用文本对象来进行选择。如：</p><p><img src="/2019/05/05/ARTS-5/微信截图_20190505222619.png" alt=""></p><p>同时还可以使用<code>ci}</code>或<code>da&quot;</code>、<code>ya&quot;</code>这种操作来将选中的部分替换、删除、复制。其中的<code>i</code>和<code>a</code>可以理解为<code>inside</code>和<code>arround</code>;<code>a&quot;</code>会选中由双引号括起来的字,<code>i}</code>会选中在一对大括号里面的内容。</p><p>除此之外，还可以使用<code>daw</code>、<code>ciw</code>、<code>yaw</code>这种操作来对一个单词进行删除、替换、复制等。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>放假期间在读《Java并发编程艺术》这本书。在读完了《Java并发编程实战》再来读这本书，发现很多东西，理解起来更容易了。同时这本书也对底层的指令实现原理讲解的更透彻，推荐阅读。</p><p><img src="/2019/05/05/ARTS-5/Java并发编程的艺术.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第五周&quot;&gt;&lt;a href=&quot;#ARTS第五周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第五周&quot;&gt;&lt;/a&gt;ARTS第五周&lt;/h1&gt;&lt;p&gt;本次ARTS主要包括：回文数、最长公共前缀算法、《effective java》关于复写equals方法的Item、VIM使用文本对象选择选区操作、《Java并发编程艺术》前两章的思维导图。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第四周</title>
    <link href="http://yoursite.com/2019/04/27/ARTS-4/"/>
    <id>http://yoursite.com/2019/04/27/ARTS-4/</id>
    <published>2019-04-27T15:05:39.000Z</published>
    <updated>2019-06-04T14:30:20.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第四周"><a href="#ARTS第四周" class="headerlink" title="ARTS第四周"></a>ARTS第四周</h1><p>快五一了，最近这段时间都是在看并发相关的知识。刚看完《Java并发编程实战》，基础部分还是需要恶补呀。加油，一步步来。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><ol start="7"><li>整数反转</li></ol></blockquote><p>标准答案的解法是通过使用取余法不断地取出整数的每一位，再用乘法加到新数的后面去，再判断一下整数是否溢出了即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rev = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> te = x%<span class="number">10</span>;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(rev&gt;Integer.MAX_VALUE/<span class="number">10</span> || (rev ==  Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; te&gt;<span class="number">7</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rev&lt;Integer.MIN_VALUE/<span class="number">10</span> || (rev == Integer.MIN_VALUE/<span class="number">10</span> &amp;&amp; te &lt;-<span class="number">8</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            rev = rev*<span class="number">10</span>+te;</span><br><span class="line">              x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rev;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》</p><ul><li><p>Item 7 Eliminate obsolete object references</p><blockquote><ol><li><strong>Nulling out object references should be the exception rather than the norm </strong></li><li>when a class manager its own memory , the programmer should be alert for memory leaks.</li><li>caches is common source of memory leaks</li></ol></blockquote></li><li><p>Item 8  Avoid Finalizers and cleaners</p><blockquote><ol><li>Finalizers are unpredictable , often dangerous, and generally unneccessary.Cleaners are less dangerous than finalizers,but still unpredicatable,slow,and generally unnecessary.</li><li>There is a severe performance penatly for using finalizer and cleaners.</li><li>They have two legitimate uses. One is to act as a safety net in case the owner of a resource neglects to call its close method .Another is native peers</li></ol></blockquote></li><li><p>Item 9 Perfer try-with-resources to try-finally</p></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在工作中遇到了需要用sql处理字符串的问题，使用到了substring_index这个函数，具体用法如下：</p><blockquote><p> <strong>substring_index(“待截取字符”，”分隔符”，截取第n个字符)</strong></p></blockquote><p>当最后的数字n为负数时，代表倒着数第n个字符。</p><p>将从<code>1010a2|192b23|33c23|12383d|12312f</code>这段字符中取出竖线分割的倒数第一个字符的用法为：<code>substring_index(&quot;1010a2|192b23|33c23|12383d|12312f&quot;,&quot;|&quot;,-1)</code>,取出第三个用法为<code>substring_index(&quot;1010a2|192b23|33c23|12383d|12312f&quot;,&quot;1&quot;,3)</code></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>最近几周都在死磕并发编程这本书，终于读完，收获颇丰，贴上自己整理的思维导图</p><p><img src="/2019/04/27/ARTS-4/Java 并发编程实战.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第四周&quot;&gt;&lt;a href=&quot;#ARTS第四周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第四周&quot;&gt;&lt;/a&gt;ARTS第四周&lt;/h1&gt;&lt;p&gt;快五一了，最近这段时间都是在看并发相关的知识。刚看完《Java并发编程实战》，基础部分还是需要恶补呀。加油，一步步来。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS补卡第三周</title>
    <link href="http://yoursite.com/2019/04/16/ARTS-3/"/>
    <id>http://yoursite.com/2019/04/16/ARTS-3/</id>
    <published>2019-04-16T13:20:29.000Z</published>
    <updated>2019-06-04T14:30:20.628Z</updated>
    
    <content type="html"><![CDATA[<p>上周工作任务很重，周日没来得及打卡，今天补上。真心希望忙完这一阵可以轻松点，不然真的撑不下去了。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><blockquote><p>237.删除链表中的结点</p></blockquote><p>本来是一道很简单的题，没有理解清楚变量<code>x</code>的含义，结果导致使用了递归还是没有做出来，很可惜；</p><p>贴上最后的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode nextNode =node.next;</span><br><span class="line">        node.val = nextNode.val;</span><br><span class="line">        node.next = nextNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>continue reading 《effective java》.</p><ul><li><p>Item 5 : Prefer Dependency injection to hardwiring resources.</p><blockquote><ol><li>static utility classes and singletons are inappropriate for classes whose behavior is parameterized by an underlying resource.</li><li>a simple pattern that satisfies that requirement is to pass the resource into the constructor when creating instance. This is one form of Dependency injection .</li><li>Do not use a singleton or static utility class to implements a class that depends on one or more   underlying resource whose  behavior affects that of class. And do not have the class create these resource.Instead, pass the resources,or factories to create them, into the constructor.</li></ol></blockquote></li><li><p>Item 6 : Avoid creating unnecessary object.</p><blockquote><ol><li>you can often avoid creating unnecessary object by using <code>static factory method</code> in preference to constructor on immutable classes that provide both.like use <code>String a= &quot;banana&quot;</code> ,not <code>String a = new String(&quot;banana&quot;)</code>. Besides,<code>Boolean(String)</code> is deprecated in Java 9,cause it must create the instance each time it’s invoked.The factory method <code>Boolean.valueOf(String)</code> is preferable to the constructor. </li><li>you can also reuse the <strong>mutable </strong>object if you know it won’t be modified. Some object creations are so expensive , cache it for reuse will provides significant performance gains if they are invoked frequently. if the object is immutable , it is obvious it can be reused safely.</li><li>Another way to create unnecessary object is <strong>autoboxing</strong> .we should prefer primitives to boxed primitives , and watch out unintentional autoboxing.</li><li>Conversely,avoid object creation by maintaining you own object pool is a bad idea,unless the object is extremely heavyweight.</li></ol></blockquote></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>这周在工作中遇到一个问题，当我试图把一个很大的文件通过流转换为<code>String</code>存储时，这个转换有时候会出错，报出<code>OutOfMemoryError:null</code>的错误。随即我开始调整内存大小，但是无论我怎么调整都没有用。</p><p>当我观察后发现，错误信息的后面是<code>null</code>而不是通常的堆栈溢出等。于是我开始跟踪源码，发现当我用流读进来后，用<code>StringBuilder</code>去拼接成字符串。然而<code>String</code>的字符数组的最大长度为：$$2^{31}=2^{10}\times2^{10}\times2^{10}\times2^{1}=1024\times1024\times1024\times2$$，即2GB。而我的文件刚好大于2GB。所以之前我在转其他文件的时候没有报错是由于文件小于2GB。此处的<code>OOM</code>错误是<code>StringBuilder</code>抛出的，而不是由于堆内存 不够导致的内存溢出。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周工作任务很重，周日没来得及打卡，今天补上。真心希望忙完这一阵可以轻松点，不然真的撑不下去了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第二周</title>
    <link href="http://yoursite.com/2019/04/03/ARTS-2/"/>
    <id>http://yoursite.com/2019/04/03/ARTS-2/</id>
    <published>2019-04-03T15:28:39.000Z</published>
    <updated>2019-06-04T14:30:20.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第二周"><a href="#ARTS第二周" class="headerlink" title="ARTS第二周"></a>ARTS第二周</h1><p>第二周赶上清明假期，察觉自己欠缺诸多，还是踏踏实实的一步一步来。所谓慢就是快，时常想尽力追赶前面的东西，没把基础打好，后面搞得自己很狼狈，实则是得不偿失。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>本周做的题目是最长回文子串，第一遍做的时候没有理解清楚什么是回文。第二次提交的时候未能通过测试用例。看了题解才做出来的。</p><p>思路是用中心点方法，从中心点开始往两侧推移。</p><p>贴出大佬的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] range = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            i = findLongest(str, i, range);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(range[<span class="number">0</span>], range[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> low, <span class="keyword">int</span>[] range)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> high = low;</span><br><span class="line">        <span class="keyword">while</span> (high &lt; str.length - <span class="number">1</span> &amp;&amp; str[high + <span class="number">1</span>] == str[low]) &#123;</span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = high;</span><br><span class="line">        <span class="keyword">while</span> (low &gt; <span class="number">0</span> &amp;&amp; high &lt; str.length - <span class="number">1</span> &amp;&amp; str[low - <span class="number">1</span>] == str[high + <span class="number">1</span>]) &#123;</span><br><span class="line">            low--;</span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (high - low &gt; range[<span class="number">1</span>] - range[<span class="number">0</span>]) &#123;</span><br><span class="line">            range[<span class="number">0</span>] = low;</span><br><span class="line">            range[<span class="number">1</span>] = high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于动态规划、字符串查找等算法还是很迷糊，还是需要加强训练和看书啊。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周继续阅读英文版《effective java》。</p><ul><li>Item2 consider a builder pattern when face many constructor parameters.</li></ul><blockquote><ol><li><p>The Builder pattern is a good choice when designing classes whose construct or static factories would have more than a handful parameters.</p></li><li><p>builder pattern is provide a public method which return ‘Builder’ type Object.And,The instant of Builder type Object would provide a build() method,which return the instant of outclass Object.</p></li></ol></blockquote><ul><li>Item 3 Enforce the singleton property with a private constructor or an enum type</li></ul><blockquote><ol><li>the normal approach to implement singletons are base on keeping the construstor private and export a public static member to provide access to the sole instance.but serialized instantce will create a new instance,unless you declare all instance fields <code>transient</code> and provide <code>readResolve</code> method.</li><li>a single-element enum type is often the best way to implement singleton.</li></ol></blockquote><ul><li>Item 4 Enforce nonistantiablity with a private contructor</li></ul><blockquote><ol><li>some utility classes is not designed for instantied. but the default construct would make it can be instantiated.we could make the constructor private to avoid user instantiated it.</li><li>private construct can make the subclass could’t instantiated too.cause the all constructors must invoke superclass contructor,explicitly or implicitly. and the private constructor is inaccessible from outside class.</li><li>The AccessError is not strictly required,but it provides insurance in case the constructor is invoked from inside class.</li></ol></blockquote><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>学习《VIM使用技巧》，工作中使用vim一直不会快速移动，在此记录下，最近学到的快速移动技巧</p><ol><li>区分屏幕行和实际行。例如在工作中编辑baseInfo文件时，其实就是一个实际行，但是这一行的内容非常多，导致在做查找、跳转等动作时很不方便，但是vim可以在移动命令前加上<code>g</code>表示移动屏幕行。如<code>gk</code>表示向上移动一个屏幕行。</li></ol><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">操作</th></tr></thead><tbody><tr><td style="text-align:center"><code>g0</code></td><td style="text-align:center">移动到屏幕行的行首</td></tr><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center">移动到实际行的行首</td></tr><tr><td style="text-align:center"><code>gk</code></td><td style="text-align:center">向上移动一个屏幕行</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">移动到实际行的第一个非空白字符</td></tr><tr><td style="text-align:center"><code>g^</code></td><td style="text-align:center">移动到屏幕行的第一个非空白字符</td></tr><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center">移动到实际行的行尾</td></tr><tr><td style="text-align:center"><code>g$</code></td><td style="text-align:center">移动到屏幕行的行尾</td></tr></tbody></table><ol start="2"><li><p>基于单词的移动，下面这张截图即可了解清楚各个命令的操作：</p><p><img src="/2019/04/03/ARTS-2/moveBaseWord.png" alt=""></p></li></ol><ol start="3"><li><p>区分单词和字符串：对于vim来说，单词是以各种逗号，括号，空格等符号分割的，而字符串则是单纯的以空格分割开来。基于这个认知，我们在做移动命令的时候，便可使用<code>W</code>/<code>E</code>/<code>B</code>等命令基于字符串移动。这样会比基于单词移动快很多，如果希望以细粒·度来移动则可以使用基于单词的方式。</p></li><li><p>使用<code>f{char}</code>+<code>;</code>命令可以在同一行中，根据查找的字母快速移动到自己希望的位置上去。若不小心跳过头了，还可以使用<code>,</code>命令往回跳。</p><blockquote><p>可以把 <code>t{char}</code> 及 <code>T{char}</code>命令当成“直到查找到指定的字符为止”（search till<br>the specified character）的命令，它们使光标停留在 {char} 前面的那个字符上，而<br><code>f{char}</code> 和 <code>F{char}</code>命令则把光标移动到指定字符上。</p></blockquote></li></ol><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>和同学一起做了个分享会，把提纲内容贴在这里，这个内容还没做完，后续还会在这里更新。</p><p><img src="/2019/04/03/ARTS-2/Java-concurrency-in-practice.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第二周&quot;&gt;&lt;a href=&quot;#ARTS第二周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第二周&quot;&gt;&lt;/a&gt;ARTS第二周&lt;/h1&gt;&lt;p&gt;第二周赶上清明假期，察觉自己欠缺诸多，还是踏踏实实的一步一步来。所谓慢就是快，时常想尽力追赶前面的东西，没把基础打好，后面搞得自己很狼狈，实则是得不偿失。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>ARTS打卡第一周</title>
    <link href="http://yoursite.com/2019/03/31/ARTS-1/"/>
    <id>http://yoursite.com/2019/03/31/ARTS-1/</id>
    <published>2019-03-31T15:28:39.000Z</published>
    <updated>2019-06-04T14:30:20.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARTS第一周"><a href="#ARTS第一周" class="headerlink" title="ARTS第一周"></a>ARTS第一周</h1><p>第一周参加ARTS打卡，将本周的总结都记录在个人的blog里。刚开始第二天，由于周末加班准备的很仓促，质量感觉一般，最后的share没有做，下周补上。</p><a id="more"></a><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>先是LeetCode上简单的算法题，两数之和。上次刷算法题应该是大四秋招前，那会儿什么也不懂，也没坚持下去，甚至当时都没觉得以后可以成为一个程序猿。直到阴差阳错，真的成为了程序猿后，发现基础太薄弱，需要补的东西太多了。索性一步一步来，花两年时间把改补的尽量都补上。下面是我的答案，做的很不好，只想到了暴力解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i]+nums[j] == target)&#123;</span><br><span class="line">                result[<span class="number">0</span>]=i;</span><br><span class="line">                result[<span class="number">1</span>]=j;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了题解后发现可以用<code>map</code>来做，而让我没能转过弯的是可以把两数之和转换成<code>x</code> 和 <code>target-x</code> 来从数组中查找。我只想到了单纯的相加。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>读了中英对照版的《effective java》Chapter 2 Item 1，英语不太好，对于其中的很多点理解的有些不到位，所以 需要对照着中文版才能看懂一些。模仿github上的总结，将自己的总结写在下面：</p><blockquote><ol><li><p>static factory methods have names,but constructors not;</p></li><li><p>not required to create new object when they’re invoked;</p></li><li>they can return any subtype of return type;</li><li>return type can vary from call to call as a function of the input parameters;</li><li>the return type can not exist when the static factory method is written;</li></ol></blockquote><p>there are two main limitation of static factory method :</p><blockquote><ol><li>the class without public or protected contructors can not be subclassed;</li><li>documentation is not frendly for programmers;</li></ol></blockquote><p><a href="https://jiapengcai.gitbooks.io/effective-java/content/chapter1/di-1-tiao-ff1a-kao-lv-yong-jing-tai-fang-fa-er-bu-shi-gou-zao-qi.html" target="_blank" rel="noopener">gitbook中英对照版</a></p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>最近在练习使用<code>vim</code>插件编辑代码，想到上次在客户现场，<code>json</code>文件是一行数据，很长很长。我用<code>vim</code>编辑不知道如何使用<code>replace</code>功能在同一行中选中部分进行替换。后来问了同学，他抛给我一个链接，是英文搜索出来的，而且讲解很详细。这次让我认识到学习英语对于查找问题很重要，很多信息确实在中文里搜索很难找到解答。在此记录下<code>vim</code>在<code>visual</code>模式下的替换技巧：可以使用<code>\%V</code>来指定在<code>visual</code>模式中替换选中部分的查找对象。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">music amuse fuse refuse</span><br></pre></td></tr></table></figure><p>In normal mode, type <code>^wvee</code> to visually select “amuse fuse” (<code>^</code> goes to first nonblank character, <code>w</code> moves forward a word, <code>v</code> enters visual mode, <code>e</code> moves forward to end of next word). Then press Escape and enter the following command to change all “us” to “az” in the last-selected area within the current line:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&apos;&lt;,&apos;&gt;s/\%Vus/az/g</span><br></pre></td></tr></table></figure><p>the result is :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">music amaze faze refaze</span><br></pre></td></tr></table></figure><p>注意V是大写，不是小写。</p><p><a href="https://vim.fandom.com/wiki/Search_and_replace_in_a_visual_selection" target="_blank" rel="noopener">原文地址链接</a></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ARTS第一周&quot;&gt;&lt;a href=&quot;#ARTS第一周&quot; class=&quot;headerlink&quot; title=&quot;ARTS第一周&quot;&gt;&lt;/a&gt;ARTS第一周&lt;/h1&gt;&lt;p&gt;第一周参加ARTS打卡，将本周的总结都记录在个人的blog里。刚开始第二天，由于周末加班准备的很仓促，质量感觉一般，最后的share没有做，下周补上。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ARTS" scheme="http://yoursite.com/tags/ARTS/"/>
    
  </entry>
  
  <entry>
    <title>RPS曲线制作与使用</title>
    <link href="http://yoursite.com/2018/10/28/RPS%E6%9B%B2%E7%BA%BF%E5%88%B6%E4%BD%9C%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/28/RPS曲线制作与使用/</id>
    <published>2018-10-28T04:11:23.000Z</published>
    <updated>2019-06-04T14:30:20.684Z</updated>
    
    <content type="html"><![CDATA[<p>此文章内容结合公众号“陶博士2006”的RPS曲线的编制方法，记录自己使用时的注意事项。</p><a id="more"></a><h2 id="RPS曲线编制"><a href="#RPS曲线编制" class="headerlink" title="RPS曲线编制"></a>RPS曲线编制</h2><h3 id="1-建立”上市一年以上”自定义板块并将股票选入板块"><a href="#1-建立”上市一年以上”自定义板块并将股票选入板块" class="headerlink" title="1.建立”上市一年以上”自定义板块并将股票选入板块"></a>1.建立”上市一年以上”自定义板块并将股票选入板块</h3><blockquote><p> 在通达信软件中，工具—自定义板块设置—新建板块。</p><p>功能（菜单）–选股器-定制选股–其它条件–上市天数–加入条件–上市天数大于360天–选股入板块（上市一年以上）。</p></blockquote><ul><li>注意：此处若想复现博士另一篇文章中的排序结果，则需要将上市天数设置为2016年6月1日至当前时间的天数。再通过.401进行rps排序可得出与博士另一篇文章相似的排序结果。我是以此来验证公式设置是否准确的。</li><li>此板块中的股票博士建议<strong>一个月更新一次</strong></li></ul><h3 id="2-设置公式"><a href="#2-设置公式" class="headerlink" title="2.设置公式"></a>2.设置公式</h3><p><strong>公式的本质是按照股票的涨幅排序来计算出相对股价强度</strong></p><blockquote><p>建立一个小公式，命名为“EXTRS”，用来计算股票涨跌幅</p><p>EXTRS:(C-REF(C,N))/REF(C,N);</p><p>N缺省值为250。</p><p>通达信软件，Control+F，技术指标公式—其他类型</p></blockquote><p>建立涨跌幅公式后，需要将股票按照涨跌幅排序，这里需要设置扩展数据：</p><blockquote><p>输入：.902，进入扩展数据管理器。 选中第1条扩展数据，点击修改。</p><p>技术指标公式选择新建的“EXTRS”指标</p><p>计算参数为120（对应半年期的RPS）</p><p>计算时段为本地所有数据</p><p>计算品种为“自定义板块”下面的“上市一年以上”这个板块</p><p>勾选“精确复权”及“生成横向排名数据”</p><p>排名方法为“0-1000归一化顺序”</p></blockquote><p>这是按照股价120天的涨幅对全市场所有股票数据进行排序，再按照同样的方式对扩展数据2进行设置，将参数设置为250天，计算的是股价一年的涨幅排序。</p><p>接下来，新建一个RPS公式指标：</p><blockquote><p>通达信软件，Control+F，技术指标公式—其他类型—新建：</p><p>股价相对强度RPS, 出两条彩线的代码如下：</p><p>X:=EXTDATA_USER(1,0);{120天的}</p><p>RPS120:X/10,LINETHICK2,COLORGREEN;</p><p>IF(RPS120&gt;=M,RPS120,DRAWNULL),LINETHICK2,COLORRED;</p><p>;</p><p>Y:=EXTDATA_USER(2,0);{250天的}</p><p>RPS250:Y/10,LINETHICK2,COLORWHITE;</p><p>IF(RPS250&gt;=M,RPS250,DRAWNULL),LINETHICK2,COLORRED;</p></blockquote><h3 id="3-下载历史数据"><a href="#3-下载历史数据" class="headerlink" title="3.下载历史数据"></a>3.下载历史数据</h3><p>软件计算需要使用全部的历史数据：</p><blockquote><p>通达信软件的菜单—系统—盘后数据下载：请自行修改下载的开始时间</p></blockquote><ul><li>博士建议这里需要每天存盘下载当天日线数据，并全部刷新两条扩展数据（即重新计算排名），这样才能显示最新的RPS曲线。</li></ul><h3 id="4-使用RPS排序"><a href="#4-使用RPS排序" class="headerlink" title="4.使用RPS排序"></a>4.使用RPS排序</h3><p>在“上市一年以上”的板块中采用RPS指标对该板块进行排序即可：</p><blockquote><p>通达信可以对RPS进行排序：.401（401前面有个点），进入历史行情指标排序，然后右键添加RPS指标，或者右键更改排序指标为RPS，就可以排序了。</p></blockquote><p>从公式里可以看到RPS的值其实是股价涨跌的排序值，股价涨幅最高的为100分，在板块中过滤后剩下的RPS大于90分的大概只有三四百只股票。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文章内容结合公众号“陶博士2006”的RPS曲线的编制方法，记录自己使用时的注意事项。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="陶博士2006" scheme="http://yoursite.com/tags/%E9%99%B6%E5%8D%9A%E5%A3%AB2006/"/>
    
  </entry>
  
  <entry>
    <title>指数基金投资指南</title>
    <link href="http://yoursite.com/2018/09/22/%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/09/22/指数基金投资指南/</id>
    <published>2018-09-22T10:28:40.000Z</published>
    <updated>2019-06-04T14:30:20.748Z</updated>
    
    <content type="html"><![CDATA[<p>一本从价值投资逻辑介绍指数基金投资的好书。</p><a id="more"></a><h2 id="为什么选择指数基金"><a href="#为什么选择指数基金" class="headerlink" title="为什么选择指数基金"></a>为什么选择指数基金</h2><p>投资指数基金的好处，自然无需多言，无论是巴菲特还是国内的投资大师们，都推荐普通人去投资指数基金。然而指数基金在国内并没有受到普通投资者的青睐。在这本书里，作者银行螺丝钉介绍了他投资指数基金的逻辑。因为国内A股市场的特殊性，所以我们不能采用无脑定投的方式投资指数基金。而是应该采用在低估的时候买入，在高估的时候卖出这种投资策略。</p><p>根据作者的数据和预测，即使采用无脑定投的方式投资指数基金，在A股过去的几十年里也可以获得10%以上的收益率。如果配合了<strong>低估买入，高估卖出</strong>的策略，则可以达到将近30%的收益率。这一切是基于改革开放40年以来的国内经济高速增长，然而目前国内经济增长速度有所减缓，但是采用低估买入，高估卖出的策略，在未来15%以上的收益率还是可以期待的。</p><p>与此同时，指数基金还具有“不会死”的特点，投资指数基金不像投资股票那样具有很高的风险，同时也可以带来长期较高的回报率。</p><h2 id="指数基金的估值"><a href="#指数基金的估值" class="headerlink" title="指数基金的估值"></a>指数基金的估值</h2><p>作者在书中介绍了两种挑选低估指数基金的方法，分别是盈利收益率法和博格公式法。盈利收益率法指的是采用盈利收益率来判断指数的估值。盈利收益率指的是市盈率的倒数。所以<strong>它只适用于流动性较好并且盈利稳定的品种。</strong>我们一般认为盈利收益率大于10%时，是处于低谷的区域。</p><p><strong>博格公式：指数基金未来的年复合收益率等于指数基金的投资初期股息率，加上指数基金每年的市盈率变化率，再加上指数基金每年的盈利变化率。</strong></p><p>这里的<strong>股息率等于分红率乘以盈利收益率</strong>，而分红率长期保持不变，所以一般当盈利收益率较高，是股息率也较高。所以根据博格公式，指数基金收益率的增长来源于三个部分分别是盈利，PE和股息。所以当我们在低估时买入指数基金时，相当于处于一个PE较低、盈利收益率和股息率较高的时间。当国家经济正常发展，企业盈利提升，我们就可以获得“股息带来的收益”还有“市盈率上涨带来的收益”。  </p><p>当某些<strong>周期性行业不适宜采用市盈率来判断估值</strong>时，可以采用博格公式的市净率版本来估值：</p><p><strong>指数基金未来的年复合率等于指数基金每年市净率的变化率，加上指数基金每年净资产的变化率。</strong></p><p>采用博格公式来判断是否低谷，则需要借助于历史数据。一般我们看当前的PB或PE处于历史的数据的百分位来判断是否处于低估区域。</p><p>根据指数背后公司的盈利状态，我们可以把指数分为四个类别，分别采用不同的估值方法来判断它们的估值：</p><ul><li>盈利稳定的指数。可采用盈利收益率法来估值，</li><li>盈利成高速增长态势的指数。可采用博格公式法来判断估值。</li><li>盈利处于不稳定状态，或呈周期性变化，<strong>但行业没有长期亏损纪录的指数。</strong>可采用博格公式的市净率来判断估值。</li><li>长期亏损的指数。直接放弃吧。</li></ul><table><thead><tr><th style="text-align:center">估值方法</th><th style="text-align:center">适用的指数</th></tr></thead><tbody><tr><td style="text-align:center">盈利收益率法</td><td style="text-align:center">上证50指数、上证红利指数、中证红利指数、基本面50指数、央视50指数、上证50AH优选指数、恒生指数、h股指数</td></tr><tr><td style="text-align:center">博格公式法（市盈率）</td><td style="text-align:center">沪深300指数、中证500指数、创业板指数、红利机会指数、必须消费行业指数、医药行业指数、可选消费行业指数、养老产业指数</td></tr><tr><td style="text-align:center">博格公式法（市净率）</td><td style="text-align:center">证券行业指数、金融行业指数、非银金融行业指数、地产行业指数</td></tr></tbody></table><p>也可以通过微信小程序且慢指数估值来查看。</p><h2 id="指数基金的买卖策略"><a href="#指数基金的买卖策略" class="headerlink" title="指数基金的买卖策略"></a>指数基金的买卖策略</h2><p>指数基金的投资策略，大体上是在低估时买入，高估时卖出，同时再辅以<strong>定期不定额定投</strong>方法来提高收益率。</p><p><strong>盈利收益率法+定投：</strong> </p><ul><li><strong>当盈利收益率大于10%时，开始定投。</strong></li><li><strong>当盈利收益率小于6.4%时，分批卖出。（这里采用6.4%是参考长期国债的收益率。如果指数的盈利收益率还不足6.4%的话，就可以将指数基金卖出换成债券。）</strong></li></ul><p><strong>博格公式法+定投：</strong></p><ul><li><strong>在市盈率或市净率处于历史底部区域时，坚持定投。</strong></li><li><strong>市盈率或市净率进入正常估值区域时暂停定投，继续持有，可以定投其他处于底部区域的品种。</strong></li><li><strong>市盈率或市净率进入历史较高区域时分批卖出。</strong></li></ul><h2 id="提升收益的投资技巧"><a href="#提升收益的投资技巧" class="headerlink" title="提升收益的投资技巧"></a>提升收益的投资技巧</h2><ul><li><p><strong>降低交易基金的费用。</strong></p></li><li><p><strong>正确处理基金分红。</strong>基金分红和资本利得是投资指数基金的两个主要收益来源。所以我们可以根据指数的估值对基金分红进行再投入或者取出。</p></li><li><p><strong>定期不定额。</strong> 其中采用盈利收益率估值的指数可采取下列公式来计算定投金额：<br>$$<br>首次低估时的定投资金\times(\frac{当月的盈利收益率}{首次的盈利收益率})^n<br>$$</p></li></ul><p>采用博格公式估值的指数可采取下列公式来计算定投金额：<br>$$<br>首次低估时的定投资金\times(\frac{首次的市盈率}{当月的市盈率})^n<br>$$</p><p>$$<br>首次低估时的定投资金\times(\frac{首次的市净率}{当月的市净率})^n<br>$$</p><p>上面的公式中的<code>n</code>为定投金额的放大器，一般来说<code>n</code>取1即可，资金足够的情况下可以取2。</p><h2 id="资产配置"><a href="#资产配置" class="headerlink" title="资产配置"></a>资产配置</h2><ul><li>拿出每月除去生活开销所剩余的钱的一半用于投资指数基金，因为这部分钱需要长期用来投资。</li><li>剩下的一般可以用来生活应急，投资货币基金。</li><li>家庭资产配置需要有30%以上的资金投资证券资产才会对家庭资产有较为明显的提升作用。</li><li>没有低估指数基金可供投资时可选取债券基金。同时也可作为资产配置的一项来降低资产组合的波动。</li><li>选择债券基金的方法：利率低位选短期，利率高位选长期。同时它可以随时投资，出现浮亏可以补仓拉低成本。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一本从价值投资逻辑介绍指数基金投资的好书。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="银行螺丝钉" scheme="http://yoursite.com/tags/%E9%93%B6%E8%A1%8C%E8%9E%BA%E4%B8%9D%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>Objectives and Key Results</title>
    <link href="http://yoursite.com/2018/09/02/2018%E7%A7%8B%E5%AD%A3OKR/"/>
    <id>http://yoursite.com/2018/09/02/2018秋季OKR/</id>
    <published>2018-09-02T12:02:12.000Z</published>
    <updated>2019-06-04T14:30:20.620Z</updated>
    
    <content type="html"><![CDATA[<p>​                                          <strong>2018秋季目标管理表格</strong> </p><p><img src="/2018/09/02/2018秋季OKR/图片1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​                                          &lt;strong&gt;2018秋季目标管理表格&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/09/02/2018秋季OKR/图片1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="谷歌目标管理法" scheme="http://yoursite.com/categories/%E8%B0%B7%E6%AD%8C%E7%9B%AE%E6%A0%87%E7%AE%A1%E7%90%86%E6%B3%95/"/>
    
    
      <category term="OKR" scheme="http://yoursite.com/tags/OKR/"/>
    
  </entry>
  
  <entry>
    <title>Java基本类型与类加载、方法调用</title>
    <link href="http://yoursite.com/2018/08/15/Java%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E3%80%81%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2018/08/15/Java基本类型与类加载、方法调用/</id>
    <published>2018-08-15T12:02:12.000Z</published>
    <updated>2019-06-04T14:30:20.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-Java代码的运行方式"><a href="#一、-Java代码的运行方式" class="headerlink" title="一、 Java代码的运行方式"></a>一、 Java代码的运行方式</h2><h3 id="1-Java程序需要运行在虚拟机中"><a href="#1-Java程序需要运行在虚拟机中" class="headerlink" title="1. Java程序需要运行在虚拟机中"></a>1. Java程序需要运行在虚拟机中</h3><p>Java虚拟机为java程序的运行提供了一个软件环境，这样做的好处是，可以使Java程序在不同的硬件平台上运行。Java程序被编译成为字节码文件后，只要在不同的平台上安装好Java虚拟机就可以运行了。</p><p>同时，Java虚拟机还为Java程序提供了一种托管环境，这个环境可以给Java程序提供一些很便捷的功能，如垃圾回收和自动内存管理等</p><a id="more"></a><h3 id="2-Java虚拟机如何运行字节码"><a href="#2-Java虚拟机如何运行字节码" class="headerlink" title="2. Java虚拟机如何运行字节码"></a>2. Java虚拟机如何运行字节码</h3><p>JVM运行Java程序，首先需要将它的class文件加载至内存的方法区中。在运行时，会执行方法区内的代码。Java的对象存在堆内存中，在栈内存中又分为面向本地方法的本地方法栈和面向Java方法的Java方法栈，以及记录每个线程执行位置的PC寄存器，JVM会在当前线程的Java方法栈中生成一个栈帧。每次执行一个方法，相当于栈帧的进栈和出栈。</p><p><img src="/2018/08/15/Java基本类型与类加载、方法调用/微信截图_20180811161053.png" alt=""></p><p>从硬件的角度来讲，机器是不能直接执行java字节码的。因此，jvm需要交java字节码翻译成机器码。在HotSpot里面，翻译成机器码的过程有两种方式，一种是解释执行，即逐条将字节码翻译成机器码。一种是即时编译（JIT），教一个方法中所有的字节码，全部编译成机器码之后再执行。解释执行的优势在于无需等待编译，而即时编译方式的优势在于，实际执行速度更快。</p><p><img src="/2018/08/15/Java基本类型与类加载、方法调用/微信截图_20180827220520.png" alt=""></p><p>在HotSpot中，将需要多次执行的热点代码，使用即时编译的方式执行。将执行次数小于15次定义为非热点代码，这一部分代码是通过解释执行的方式执行。</p><h2 id="二、基本类型"><a href="#二、基本类型" class="headerlink" title="二、基本类型"></a>二、基本类型</h2><p>在JVM中，变量存储的数据是可以超出它定义的范围的。boolean类型的数据在JVM中被翻译为1和0，但是我们可以通过修改字节码的方式，将2存储为boolean数据。</p><p><img src="/2018/08/15/Java基本类型与类加载、方法调用/微信截图_20180827221654.png" alt=""></p><ul><li>值域小的数据类型向值域大的类型转换时，是不需要进行数据强转的。</li><li><strong>基本类型的包装类型之间是无法进行强制转换。</strong> </li><li>java中的正无穷和负无穷，都是有明确的数值的。在内存中分别等同于十六进制整数 0x7F800000 和 0xFF800000。超出了正无穷和负无穷之间的其他数字对应的浮点数是<code>NaN</code>。</li><li><code>NaN</code>和任何一个浮点数（不管是0还是NaN）比较时，除了<code>!=</code>返回<code>true</code>以外，其他均返回<code>false</code>。</li></ul><h3 id="1-存储"><a href="#1-存储" class="headerlink" title="1.存储"></a>1.存储</h3><p>在java的方法栈帧中分为局部变量区和字节码的操作数栈。局部变量就相当于一个数组，除了long和double占两个数组单元以外，其他基本数据类型都只占用一个数组单元（32位是4个字节，64位是8个字节），也就是说，其他数据类型都和int型一样，在栈帧中占4个字节（64位的HotSpot占8个字节）。注意：<strong>这里是指在栈里面，而在堆中的字段或数据里面byte、char、short分别占有一个字节，两个字节，两个字节。 也就是说跟它们的值域是相吻合的。</strong></p><p>一个int型的数据存储进字段或数组中时，是会进行隐式的的掩码操作。举例来说，当我们把 0xFFFFFFFF（-1）存储到一个声明为 char 类型的字段里时，由于该字段仅占两字节，所以高两位字节会被截掉。同样，对于boolean类型来说，在存储时会显示的进行掩码操作，只取最后一位存入字段或数组中。</p><h3 id="2-加载"><a href="#2-加载" class="headerlink" title="2.加载"></a>2.加载</h3><p>我们需要将堆中全部数据加载到栈中计算，也就是说我们需要将boolean、byte、char、short加载到操作数栈中，而后将栈中的数值当成int型来计算。对于char和byte来说，无符号型数据加载伴随着0扩展。char占有两字节，会被复制到栈中的低两字节，高两字节则用0补充。</p><p>同理，对于有符号类型的数据加载则进行符号扩展，高两字节用符号位填充。</p><h2 id="三、类加载"><a href="#三、类加载" class="headerlink" title="三、类加载"></a>三、类加载</h2><p>类的加载过程主要是三大步骤。分别为加载、链接和初始化。</p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>加载的过程就是查找字节流，并且创建这个类。加载需要借助类加载器。在JVM中，类加载器使用双亲委派模式，收到一个类加载请求之后，需要先转派给父类加载器，父类加载器没有找到所请求的类的情况下，子类加载器才会尝试去加载。</p><p>最基础的类加载器是启动类加载器（boot classLoader），它是由C++实现的，没有对应的Java对象，因此只能用null来代表它。除了启动类加载器以外，其他的类加载器都是java.lang.ClassLoader的子类，这些类加载器都需要启动类加载器加载进JVM中才能使用。</p><p>除了启动类加载器以外，还有一些较为重要的加载器如扩展类加载器和应用类加载器。<strong>扩展类加载器的父类是启动类加载器，应用类加载器的父类是扩展类加载器。</strong> 默认情况下，应用程序中的类是由应用类加载器加载的。我们可以自己实现类加载器来完成自定义的一些功能，如class文件的加密解密等。</p><p>JVM中，类的唯一性是由类加载器实例以及类的全名一同确认的。所以同一段字节码，被两个类加载器加载之后也会得到两个不同的类。</p><p>相当于造房子的时候，找到一个老师傅来在一个地址上开始创建过程。</p><h3 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h3><p>链接又分为验证，准备和解析三个阶段。</p><p>验证是为了确保被加载的类能够符合JVM的约束条件。相当于上报监管部门审批造房。</p><p>准备是为了给被加载类的静态字段分配内存。相当于盖好了毛坯房。</p><p>解析是为了将被加载类的类成员、字段等符号引用解析成实际引用。如果符号引用指向的是一个未被加载的类，那么解析会出发那个类的加载，但不一定出发类的链接和初始化。这里的符号引用是指，编译器在编译的时候将被引用的字段、类、方法生成一个符号引用来代替它本身。而将符号引用解析未实际引用就是将在字节码中的符号引用替换位在JVM中的实际内存地址。</p><p>如果将这段话放在盖房子的语境下，那么符号引用就好比，“张三的房子”这种说法。不管他存不存在，我们都可以用这种说法来指代张三的房子，实际应用则好比是实际的通讯地址，如果我们想要与张三通信，那么必须要将“张三的房子”变成实际的通讯地址。如果这个实际的通讯地址不存在，则需要启动张三的盖房子过程的第一步，即选择好师傅在一个地址上开始创建。</p><h3 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h3><p>静态代码块中的代码和直接赋值操作被编译器放置在同一个方法中，叫做<clinit>。</clinit></p><p>类的初始化便是为常量值字段赋值以及执行<clinit>方法。</clinit></p><h2 id="四、方法调用"><a href="#四、方法调用" class="headerlink" title="四、方法调用"></a>四、方法调用</h2><h3 id="1-重载、重写、动态绑定与静态绑定"><a href="#1-重载、重写、动态绑定与静态绑定" class="headerlink" title="1. 重载、重写、动态绑定与静态绑定"></a>1. 重载、重写、动态绑定与静态绑定</h3><ul><li><strong>不建议重载可变长参数的方法。</strong>因为这可能会导致java编译器无法确定应该调用哪个目标方法。</li><li>java编译器在编译的时候已经区分了重载，所以我们可以认为在jvm里面不存在重载这个概念。</li><li>jvm中的动态绑定指的是需要在运行过程中，根据<strong>调用者的动态类型</strong>来识别目标方法。而静态绑定指的是在解析时便能够直接识别目标方法的情况。</li></ul><p>java字节码中调用相关的指令共有五种:</p><ul><li><code>invokestatic</code>:用于调用静态方法。</li><li><code>invokespecial</code>:用于调用私有实例方法，构造器，以及使用super关键字调用父类的实例方法或构造器，和所实现接口的默认方法。</li><li><code>invokevirtual</code>:用于调用非私有实例方法。</li><li><code>invokeinterface</code>:用于调用接口方法。</li><li><code>invokedynamic</code>:用于调用动态方法。</li></ul><p>对于<code>invokevirtual</code> 和<code>invokedynamic</code> 虚拟机需要在执行过程中，根据调用的动态类型来确定具体的目标方法。也就是说这两个编译指令，需要使用动态绑定。</p><p>对于静态绑定而已，符号引用被解析成实际引用时，这个实际引用是一个指向方法的指针。对于动态绑定而言，实际引用则是一个方法表的索引。</p><h3 id="2-动态绑定"><a href="#2-动态绑定" class="headerlink" title="2. 动态绑定"></a>2. 动态绑定</h3><p>在JVM中，静态绑定包括用于调用静态方法的<code>invokestatic</code>指令和用于调用构造器，私有实例方法以及父类非私有实例方法的<code>invokespecial</code> 指令。如果虚方法调用指向一个标记为final的方法，那么JVM也可以静态绑定该虚方法调用的目标方法。</p><ol><li>方法表</li></ol><p>在类加载的时候，除了为静态字段分配内存以外，还会构造与该类相关的方法表。</p><p>方法表的本质是一个数组，每个数组元素指向一个当前类以及其父类中非私有实例方法。对于动态绑定而言，实际引用则是方法表的索引值。</p><p>在执行过程中，JVM将获取调用者的实际类型，并在实际类型的虚方法表中，根据索引值获得目标方法，这个过程便是动态绑定。</p><ol start="2"><li>内联缓存</li></ol><p>内联缓存，本质上是一种加快动态绑定的技术。它能够缓存虚方法的调用者动态类型，以及该类型所对应的目标方法。在之后的执行过程中，如果已经到缓存过的类型，内联缓存便会直接调用该类型所对应的目标方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、-Java代码的运行方式&quot;&gt;&lt;a href=&quot;#一、-Java代码的运行方式&quot; class=&quot;headerlink&quot; title=&quot;一、 Java代码的运行方式&quot;&gt;&lt;/a&gt;一、 Java代码的运行方式&lt;/h2&gt;&lt;h3 id=&quot;1-Java程序需要运行在虚拟机中&quot;&gt;&lt;a href=&quot;#1-Java程序需要运行在虚拟机中&quot; class=&quot;headerlink&quot; title=&quot;1. Java程序需要运行在虚拟机中&quot;&gt;&lt;/a&gt;1. Java程序需要运行在虚拟机中&lt;/h3&gt;&lt;p&gt;Java虚拟机为java程序的运行提供了一个软件环境，这样做的好处是，可以使Java程序在不同的硬件平台上运行。Java程序被编译成为字节码文件后，只要在不同的平台上安装好Java虚拟机就可以运行了。&lt;/p&gt;
&lt;p&gt;同时，Java虚拟机还为Java程序提供了一种托管环境，这个环境可以给Java程序提供一些很便捷的功能，如垃圾回收和自动内存管理等&lt;/p&gt;
    
    </summary>
    
      <category term="JVM基础" scheme="http://yoursite.com/categories/JVM%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>见识</title>
    <link href="http://yoursite.com/2018/08/12/%E8%A7%81%E8%AF%86/"/>
    <id>http://yoursite.com/2018/08/12/见识/</id>
    <published>2018-08-12T11:13:40.000Z</published>
    <updated>2019-06-04T14:30:20.936Z</updated>
    
    <content type="html"><![CDATA[<p>《见识》这本书是偶然从一个公众号的文章推送里面得知的。后来得知是吴军写的便直接买回来看看。写这篇文章是为了记录下读了这本书之后所收获到的几点。</p><p>从整体上来说，这本书阐述了吴军老师对人生、对职业、对投资的思考和建议。</p><a id="more"></a><h2 id="一、关于人生"><a href="#一、关于人生" class="headerlink" title="一、关于人生"></a>一、关于人生</h2><p>从这个角度来说，我喜欢这本书的第一章标题，叫做<strong>幸福是目的，成功是手段。</strong>这章里面作者说，一个人需要相信自己的命运。而关于命，每个人是有不同的理解。</p><blockquote><p>命运取决于两个因素，一个是环境因素，是由我们的出身和环境来决定的。而另一个是我们自己对未来走向的规划，这一点是我们自己努力博弈出来的。所谓的命，我们能掌握的就是一个人看问题和做事情的方法，仅此而已，但是他们决定了一个人的一生。</p></blockquote><p>一个人的出生、生活环境和他受到的教育都会对他整个人生的命运产生非常大的影响。而我们常说”命运是掌握在自己的手里“指的是我们可以规划自己的未来方向，通过自己的努力获得想要的人生。对于一个普通人来说，想要逆袭是非常难，非常难的一件事情。作者在书中举了个例子说你可能需要花半辈子时间，来弥补自己的不足。然后再花半辈子的时间来追赶别人。因为别人的先天条件比你好的话，那么可能他只要付出三分的努力，就可以达到你付出十分努力所带来的效果。因此你必须要花很长的时间来弥补自己的不足，然后再努力的去追赶人家的脚步。</p><h3 id="1-对男生女生的建议"><a href="#1-对男生女生的建议" class="headerlink" title="1.对男生女生的建议"></a>1.对男生女生的建议</h3><p>人生最重要的投资其实是投资自己。对男生来说，选择好一个配偶十分重要。一个女生，她所表现出来的气质涵养，实际上跟她的家庭有很大的关系。选择一个聪明的跟你价值观完全相符合的女生，这对于你自己人生的未来会大有裨益。同时，男生需要有足够的独立性，承担自己未来对家庭的义务。在一段婚姻中，双方都需要明白关系的亲密程度和重要性依次是<strong>“夫妻优先于子女，更优先于双方的父母。”</strong></p><p>有很多人觉得结婚是两个家庭的事情。然而在这本书里面，作者说，婚姻它并不一定是两个家庭的事情，而是两个人要分得清楚大家和小家。两个人在婚姻中需要分清大家和小家之间的边界。</p><blockquote><p>一个人，特别是年轻的时候，可塑性非常重要。两个人在一起时间一长，肯定会遇到矛盾，能够有一些柔韧，彼此妥协的解决问题，相互适应，才能更好、更长远的走下去。</p></blockquote><p>对于女生来说，需要分清楚婚姻与恋爱的不同。恋爱是激情，是化学物质分泌所带来的愉悦；而婚姻则是两个人共同构造一个舒适体。在这个舒适体中，双方都会受益，彼此成长。不要总觉得老实的男人才能靠的住，或者找一个自己可以控制的人。因为你会发现很多身边看似老实的男人，会做出一些让你们大跌眼镜的事情。其实这些东西它本质上并没有什么意外的，因为人性就摆在那里。女生应该靠自己的能力去辨别一个，对自己好的男生。而对自己好，不应该靠男生怎么说来评判，要去发现他是怎么做。需要判断这个人的价值观和爱情观是否与自己相符，是否认可夫妻间的关系的重要性高于其他关系的重要性。只要仔细观察就可以发现他对你们之间关系的在乎程度。</p><blockquote><p>当然，一个男生最终能否对你好，还要看他有没有这个能力。因为大部分男生都会描绘一个美好的未来，但是很多人根本无力去实现它。</p></blockquote><h3 id="2-做人和作诗"><a href="#2-做人和作诗" class="headerlink" title="2.做人和作诗"></a>2.做人和作诗</h3><p>最近我在办公室中，跟一些同事玩得越来越熟。有些同事会说我是一个很会说话的人。当我听到他们这样评价我的时候，其实我的内心对自己多少是有点失望的。因为我知道自己不是个情商很高的人，我只是会偶尔抖个机灵，然后不向别人吝啬我的赞美。可能这些东西在别人的眼中，会有拍马屁的倾向。在这本书里面，作者把这些东西称之为会做人。在这个社会中并不缺会做人的人，但是缺会做诗的人。</p><p>这里的作诗指的是，他们有一种理想主义式的叛逆精神。在我的理解里，这大概是一种纯粹的理想主义。有一些了解我的朋友，可能因为觉得我喜欢老罗而认为我是个很理想主义的人。但是我其实更倾向于把自己归结为是一个现实理想主义者。我非常的认同和赞美理想主义精，但是我觉得脱离了现实的理想主义行为，是一种非常不理智的，甚至会给自己和家人带来生活上的窘境的行为。当然我更不喜欢那些把自己利益看得很重的精致利己主义者。我喜欢的是像鲁迅那样，一边拿着国民政府的钱，一边去骂国民政府。大概我的信条是应该在很多事情上有着理想主义的原则，但是不能脱离现实而活着。守住自己的底线，照顾好自己的家人，而不是用一种很幼稚的理想主义行为去跟这个丑恶世界进行搏斗。</p><h3 id="3-非线性增长"><a href="#3-非线性增长" class="headerlink" title="3.非线性增长"></a>3.非线性增长</h3><p>这本书的第四章叫做大家智慧。作者写了一些名人的故事，他告诉我们，<strong>做事情要认清成本并且看透本质。</strong>关于看透本质这件事情，我有另外个理解，叫做非线性增长。这是我从投资理念中学来的，不管是人生还是投资，在很多的时候都不是一个线性增长的过程。它是一个缓慢的由量变累积产生质变的非线性增长过程。它需要前期不断的进行投入累积，达到了临界点之后，发生一个突变带来很多的回报。所以我们需要看透这个增长过程的本质是非线性的，并不是投入多少就会得到多少回报。而是需要找到那个临界点，不断的积累，之后就会产生质变获得很大的收益。</p><p>就拿工作这件事情来说，工资的增长并不是线性的，它是一个人内在价值的外在定价。所以说，作者给毕业生的建议是，在工作的前三年不要太去关注工资多少，而需要关注的是自己内在价值的提升。你自己的内在价值才是工资的本质。等过了几年工作上有了很好的工作经验的累积和技能的提升。这些内在价值的积累产生质变就会体现在你的工资的大幅增长上，会很容易的翻倍增长。这一点跟延迟满足感也是同样的道理。就是说我们需要放弃前期短暂的满足感，而不断的积累，坚持到未来产生更大的收益。</p><h3 id="3-做好最后的1"><a href="#3-做好最后的1" class="headerlink" title="3.做好最后的1%"></a>3.做好最后的1%</h3><p>在做事情的时候，需要做好最后的1%。因为其实很多时候人与人之间的能力差距并没有那么大，但是正是这最后的1%却会拉开很大的差距。这一点是我需要始终铭记的，我在很多方面的最后1%都做的不够好。</p><h2 id="二、关于职业"><a href="#二、关于职业" class="headerlink" title="二、关于职业"></a>二、关于职业</h2><h3 id="1-职业误区"><a href="#1-职业误区" class="headerlink" title="1. 职业误区"></a>1. 职业误区</h3><p>在职业方面，作者给我最大的启发是：<strong>不要走入一个工作和职业分不清的误区。</strong></p><p>工作是谋生的手段，你去单位上班然后单位给了你一份工资就两清了。然而，职业却是需要从事一辈子的事情。为了这个一辈子的发展，应该选择性的做一些对职业有利的事情，不论是否有报酬或者报酬的高低。</p><p>对待自己的职业需要专业的工作态度。所谓的专业，就是一切以工作目标达成为中心，所有的会议、沟通都是以此为核心。不管在任何情况下，能够把事情做好才能够体现出你的职业素质。成为一个专业人士，也是我入职以后，邹总在给我们的新人培训中所提出的一点希望。希望我们能够专业人士的态度，把属于自己的每件事情做好，而不去考虑当前的一些短暂利益。</p><p>另外一个启发是：<strong>不要把自己当成一个单位的过客，而是将自己当成主人。</strong>对比我之前在恒生的工作经验来说，我其实从一开始入职恒生的时候，就想把恒生作为一个不错的跳板。其实这样的想法对我来说是非常不利的。在整个工作过程中，我并没有去做一个专业人士应该做的事情。所以我希望在以后我所经历的每一家公司，都有一种主人翁的意识。不仅仅需要把这当成是一份工作，而是当成我的职业来做。成为一个专业的人士，对我来说很重要。</p><p>为了避免陷入这些误区，作者给我们提出了几个解决办法：</p><ul><li>第一，任何时候都要为人谦卑，只有谦卑才能更有效的沟通。</li><li>第二，要用正确的方法对待语言暴力和其他故意伤害。</li><li>第三，永远要明确工作不是为了公司或者他人，而是为了自己的职业发展这个既定的大方向。想要成为领导者，要平实的学习做一个领导。走出自己的一亩三分地，主动的多做事情，多跟人打交道，去帮助他人，支持自己的老板和团队。</li><li>第四，注重长期效益，把一件事情放到2到3年的时间周期来看，这时候我们对它的态度就会完全的不同。永远在一家公司不要有过客心态，要抱着学本事的心态去专心的干事情。</li><li>第五，作为一个基层员工，需要有大局观。你不仅需要看到你工作中所专注的一些细节，你需要看到整个项目，整个团队是如何运行的。</li></ul><h3 id="2-伪工作者"><a href="#2-伪工作者" class="headerlink" title="2. 伪工作者"></a>2. 伪工作者</h3><p>作为一个程序员，我自然的想要在工作的时候追求效率减少加班。在这本书中，作者提出了我们要拒绝做一个伪工作者。</p><ul><li>我们首先需要确定，<strong>愿景-目标-道路。</strong>愿景就是说我们要确定一个明确的方向，然后在这个明确的方向上，我们需要设置一些阶段性的目标，战略的核心就是达到这些既定的目标，进而实现我们的愿景。</li><li>第二点是，即使听到了不中听的话也一定要虚心找出其中的合理之处。每次遇到别人和自己意见相左时，一定要开启寻找对方合理性的开关，这样会对你自己有很大的提升。</li><li>第三点时，凡事要做记录。做记录的过程其实是，有思考了一遍，这样会使得你进步更快。</li></ul><p>同时作者还分享了自己谷歌目标工作管理方法。将自己的年度目标，列成一个表格。然后再制作一个消耗跟踪曲线来跟踪自己的目标完成情况。</p><p><img src="/2018/08/12/见识/微信图片_20180812224407.jpg" alt=""></p><p><img src="/2018/08/12/见识/微信图片_20180812224419.jpg" alt=""></p><p><img src="/2018/08/12/见识/微信图片_20180812224424.jpg" alt=""></p><h2 id="三、关于投资"><a href="#三、关于投资" class="headerlink" title="三、关于投资"></a>三、关于投资</h2><h3 id="1-金钱观"><a href="#1-金钱观" class="headerlink" title="1.金钱观"></a>1.金钱观</h3><p>这本书的最后一部分作者关于投资的一些看法。每个人都需要有一个正确的金钱观和理性的投资观。首先是金钱观，在现实生活中，要有那种没有钱是万万不能的思想。如果太过理想的去抛弃了很多东西的话，只会让你的生活变得很糟糕，并且没有能力照顾你的家人。鲁迅先生自己曾讲，饭碗可以跟理想分开。每个人都需要在这个现实的世界中很好的生活下去，所以你需要努力的保住你的饭碗。这一点是非常重要的。</p><p>另外一点是：<strong>钱只有花出去了，才是你的。</strong>在很多时候，我们不应该吝啬自己。就我自己来说，凡是我觉得会提高自己生活品质的东西就肯定会买。但是我会根据自己的收入，来分配投资和消费的比例。因为有些东西，它并不是很紧急的。比如我最近一直想买的键盘和音箱，但是我这个月已经买了手机，而这些东西又不是非常紧急。所以，我可以把剩下的钱部分用作生活费，另一部分用作投资理财。等下个月的工资发下来之后，再去买键盘和音响。</p><h3 id="2-投资观"><a href="#2-投资观" class="headerlink" title="2.投资观"></a>2.投资观</h3><p>再来说说投资观。因为我的工作跟金融有关，同时我也很爱钱。所以很自然的对投资理财感兴趣。之前我读过一本书，它说你在投资的时候，首先需要确定的一点就是<strong>风险意识。</strong>我一开始并不知道怎么看待这个风险意识。但是关注了这个行业一段时间之后，就发现那些很著名的理财投资人，他们都会给自己和自己的家庭买上各种各样的保险。其实保险它的本质上就是转移你的生活风险。大家都知道，在现实生活中，一场疾病很可能会把一个家庭的财务状况给带入低估。但是如果我们提前配置了保险的话可能情况就会好很多，这就是风险意识的一种体现。</p><p>其实不仅是理财，在生活中的任何事情都有风险，如果我们提前有了风险意识，并且对可能发生的这些风险的情况，作出应对策略的话，那么我们就可以很好的应对生活中的那些未知情况。</p><p>这本书里作者提出的投资些思想和投资观点，跟我以前对于投资的认识是很相似的，比如专业人士并不一定会比我们自己投资做的好。</p><p>对于投资来说，最好的投资品种还是权益类产品。这里的权益类产品指的是债券、股票、指数基金等。从历史数据来看，不论是哪个国家，投资股市都是回报率最高的一种方式。而单个股票的投资风险是很高的，因为它存在于价值归零的可能。但是如果你投资指数基金的话，情况就完全不一样。你只要在指数低估的区间买入，然后长期持有或者定期投入的话，就可以获得一个相对不错的收益。所以对于普通的上班族来说，努力工作扩大每月的现金流，然后将每月的闲钱去投资到指数基金中，会给我们带来相对不错的受益。同时我们需要有足够的风险意识，给自己配置上保险来应对可能发生的亏损情况。</p><p><img src="/2018/08/12/见识/微信图片_20180812224340.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《见识》这本书是偶然从一个公众号的文章推送里面得知的。后来得知是吴军写的便直接买回来看看。写这篇文章是为了记录下读了这本书之后所收获到的几点。&lt;/p&gt;
&lt;p&gt;从整体上来说，这本书阐述了吴军老师对人生、对职业、对投资的思考和建议。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="吴军" scheme="http://yoursite.com/tags/%E5%90%B4%E5%86%9B/"/>
    
  </entry>
  
  <entry>
    <title>自私的基因</title>
    <link href="http://yoursite.com/2018/07/30/%E8%87%AA%E7%A7%81%E7%9A%84%E5%9F%BA%E5%9B%A0/"/>
    <id>http://yoursite.com/2018/07/30/自私的基因/</id>
    <published>2018-07-30T15:13:40.000Z</published>
    <updated>2019-06-04T14:30:20.916Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/07/30/自私的基因/s11214645.jpg" alt=""></p><p>这本书开始的时候，作者提出了达尔文进化论的物竞天择，适者生存中的“适者”到底是什么？是种群，个体，还是物种？都不是，在作者看来，基因是自然选择的单位。而所有的动物，植物，个体，都是基因控制的生存机器而已。基因的目的只有一个，那就是复制自己。所以，从这个角度出发，就有了这本书的名称——自私的基因。</p><a id="more"></a><p>基因的目的是为了让自己复制下去。所以他们选择了各种各样的策略，让自己尽可能的复制下去。那些会控制蛋白质给自己制造生存机器的基因则更大概率能在自然选择的情况下生存下去。所以自然选择使得制造生存机器的基因可以不断地复制，生存下来。于是，基因通过控制蛋白质合成的方式，来控制着生存机器。而基因无法知道，动物会在生存过程中遇到什么样的情况。所以它们会给这些动物，预先制定好策略。比如它们不知道北极熊出生后，会面临哪些遭遇。但是基因会给北极熊准备好厚厚的毛发，来帮助他们御寒。这就是基因的预测行为，它其实就像程序员写的代码一样。只是指定了固定模式下的蛋白质合成方式，而不去关心实际代码所处理的数据。</p><p>作者在这本书中又提到了进化稳定性策略（ESS），这种策略是一种自然选择上稳定性的策略，一旦一种稳定性策略确立起来之后，任何偏离这种策略的行为都会受到自然选择的惩罚。而这种策略的稳定性，并不在于它有利于这个群体中的个体，而是因为它的内部没有背叛行为。一个生物种群理论上可以达到多种稳定性策略，但是最终会以一种稳定性策略方式生存下去，这将取决于他们优先达到了哪一种稳定性策略。从基因的角度来说，基因库是由一组进化上稳定的基因形成的，这组基因成为一个不受任何新基因侵犯的基因库。而大部分因为基因突变、重新组合而产生的新基因，将会偏离这种稳定性策略，必然会受到自然选择的惩罚。但是新基因侵入一组稳定性基因库，偶尔也会获得成功。一旦成功，就会立马在基因库中散布开来，最终形成一组新的稳定性策略。按照这种进犯策略类推，一个种群可以从一个稳定性进化策略跳向另外一个稳定性进化策略。这就是进化的过程。</p><p>把个体动物视为独立的生存机器，便于理解进犯行为。但是如果有关个体是近亲的话，这一模式也许会失去效用，因为近亲体内存在着很大一部分共同的基因，而每一个基因同时需要忠于不同的个体。从基因的角度，也可以解释我们的近亲利他主义。如果一个个体为了拯救十个近亲而牺牲，操作个体对亲属表现利他行为的基因，就有可能因此失去一个拷贝，但同时，一个基因的大量拷贝却得以保存。从这个角度来说，父母之爱和兄弟姐妹的利他行为的形成，都可以用完全相同的原因来解释，在收益者体内存在这个利他性基因的可能性更大。</p><p>同时从自私的基因角度来看，很多生物界的动物会选择自发的计划生育。而他们这种行为的目的，其实是为了让自己后代的成活率更高，以保证自己的基因可以复制延续下去。</p><p>在父母与子女之间也存在着欺骗和自私行为，而这种行为正是自私基因的延伸。幼儿欺骗父母，为了获取更多的食物和理想的生存条件，是为了使基因可以复制下去。而父母防止幼儿欺骗，是为了使自己的基因，可以更好的复制到下一代身上去。因为父母能够能够给的资源是有限，而他们为了使自己的基因可以复制下去，必须选择性的将更多的资源给活下去可能性更大的子女。这些只是从基因的角度来说，不牵涉到任何有意识的行为。</p><blockquote><p>如果说我们从中有什么可以借鉴的话，那么就是我们必须把利他主义的美德，灌输到我们子女的头脑中去，因为我们不能指望他们的本性中有利他主义的成分。</p></blockquote><p>在自然界中，雌性的卵子比较珍贵，而雄性的精子相对廉价。所以雌雄两性为了使自己的基因有更大的可能性复制下去，他们分别进化出不同的策略来对抗对方。在书中，作者提到雌性可以选择大丈夫策略或者家庭幸福策略来选择自己的配偶。而雄性则会有不同的策略来对抗。</p><p>作者在书中还提出了一种新的复制基因。叫做meme(觅母)。作者认为，文化的传播和遗传相类似，即它能导致某种形式的进化。遗传的进化能以存在于一种稳定状态，向另一种稳定状态转变而取得进展。而觅母，从广义上说可以称为模仿过程，从一个大脑转向另一个大脑的过程。以这样的方式在觅母库中进行繁殖。觅母和基因一样，也是自私的。</p><blockquote><p>然而，即使我们着眼于阴暗面，假定人基本上是自私的。我们自觉的预见能力，能够防止自己纵容盲目的复制基因，干出那些最坏的、过分的自私行为。在必要时，我们也可以抗拒那些灌输到我们头脑里的自私觅母，我们甚至可以讨论如何审慎的培植纯粹的，无私的利他主义，这种利他主义在自然界里是没有立足之地的。在整个世界历史上也是前所未有的，我们是作为基因机器而被建造的，是作为觅母机器而被培养的，但我们具备足够的力量去反对我们的缔造者，在这个世界上只有我们，我们人类，能够反抗自私的复制基因的暴政。</p></blockquote><p>关于自然界中的互惠利他行为，作者也通过自私基因的角度来给出了解释。这里作者提出了，一个经典的，博弈论概念。叫做囚徒困境。在简单的囚徒困境中。无论怎么算，最好的策略是永远背叛，因为这是个零和博弈。然而所幸，在自然界中，我们并不是处于简单的囚徒困境中，而是充满了囚徒困境的重复博弈，这是一个非零和博弈。在有记忆的生物中，对于这种囚徒困境的重复博弈，我们最好的策略是：<strong>合作与互助 </strong>。也就是说，<strong>好人终有好报。</strong> </p><p><img src="/2018/07/30/自私的基因/微信图片_20180731232134.jpg" alt=""></p><p>一想到人一生下来就有太多的东西是受基因控制的，就不免感到有点悲哀。我们的一切行为，所有的本能和心理因素都受着基因的影响，不过所幸，我们是可以反抗的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/07/30/自私的基因/s11214645.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这本书开始的时候，作者提出了达尔文进化论的物竞天择，适者生存中的“适者”到底是什么？是种群，个体，还是物种？都不是，在作者看来，基因是自然选择的单位。而所有的动物，植物，个体，都是基因控制的生存机器而已。基因的目的只有一个，那就是复制自己。所以，从这个角度出发，就有了这本书的名称——自私的基因。&lt;/p&gt;
    
    </summary>
    
      <category term="Reading" scheme="http://yoursite.com/categories/Reading/"/>
    
    
      <category term="理查德道金斯" scheme="http://yoursite.com/tags/%E7%90%86%E6%9F%A5%E5%BE%B7%E9%81%93%E9%87%91%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>深入理解泛型</title>
    <link href="http://yoursite.com/2018/06/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/06/27/深入理解泛型/</id>
    <published>2018-06-27T11:40:59.000Z</published>
    <updated>2019-06-04T14:30:20.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>Java的泛型本质是参数化类型，就是将数据类型做为一个参数，在使用的时候再指定它的具体类型。但是因为Java使用了类型擦除，所以这个参数只存在于编译期，在运行期JVM是并不知道泛型的存在。</p><a id="more"></a><p><img src="/2018/06/27/深入理解泛型/微信截图_20180404211042.png" alt=""></p><p>上图运行结果可以看出，在JVM运行时将<code>new ArrayList&lt;String&gt;()</code>与<code>new ArrayList&lt;Integer&gt;()</code>看作是同一个class类。 </p><p>泛型参数会擦除到它的第一个边界。如果没有边界，则默认擦除到Object类。</p><blockquote><p>无论我们如何定义一个泛型类型，相应的都会有一个原始类型被自动提供。原始类型的名字就是擦除类型参数的泛型类型的名字。</p><p>如果泛型类型的类型变量没有<strong>限定(<t>) </t></strong>，那么我们就用Object作为原始类型；<br>如果有限定(<t extends="" xclass="">)，我们就XClass作为原始类型；<br>如果有多个限定(<t extends="" xclass1&xclass2="">)，我们就用第一个边界的类型变量XClass1类作为原始类型； </t></t></p></blockquote><h2 id="类型擦除带来的麻烦"><a href="#类型擦除带来的麻烦" class="headerlink" title="类型擦除带来的麻烦"></a>类型擦除带来的麻烦</h2><p>###1. 泛型数组 </p><p>Java中不允许直接以这种方式创建泛型数组<code>List&lt;String&gt;[] c = new List&lt;String&gt;[3]</code> 。如果Java允许创建泛型数组则会产生一个下面的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.  实际上是不允许的</span></span><br><span class="line">Object o = lsa;  <span class="comment">//强转为Object类型</span></span><br><span class="line">Object[] oa = (Object[]) o;  <span class="comment">//强转为Object[]数组</span></span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));  </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check 通过了存储校验  </span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.  产生类型强转异常</span></span><br></pre></td></tr></table></figure><p>上面代码的最后一句会产生运行时异常。这是因为JVM进行类型擦除之后是不知道泛型信息的，而数组是有协变效应的。所以支持将不同数据类型的数据放入到<code>Object[]</code>类型的数组中，所以就会导致取出数据的时候产生<code>ClassCastException</code>。 在取出数据的时候，泛型可以使得编译期上述最后一行代码不需要进行类型强转也可以通过编译器的检查（这是泛型设计的作用之一），但是在实际运行过程中又产生了<code>ClassCastException</code> 异常，这违背了泛型的设计原则（在编译期不出现 <code>未经检查的转换</code> ，运行期就不会报出类型转换异常）。</p><p>Java允许创建无边界通配符类型的数组，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type. </span></span><br><span class="line">Object o = lsa;</span><br><span class="line">Object[] oa = (Object[]) o;</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct. </span></span><br><span class="line">oa[<span class="number">2</span>] = <span class="string">"123"</span>;<span class="comment">//Object[]数组可以存储任意类型的对象数据</span></span><br><span class="line">String s = (String) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run time error, but cast is explicit.</span></span><br></pre></td></tr></table></figure><p>上述代码的最后一行也会产生运行期类型强转异常，但是使用类型通配符数组，在取出元素类型时，则需要显式的强转数据类型。这一点使得</p><blockquote><p><strong>协变：A是B的父类，并且A的容器也是B的容器的父类，则称之为协变。</strong></p></blockquote><p>泛型是不支持协变的，但是支持“伪协变”，意思是指泛型本身不支持协变，但是可以通过设置上下边界来实现类似协变的特性。</p><h3 id="2-泛型的多态"><a href="#2-泛型的多态" class="headerlink" title="2.泛型的多态"></a>2.泛型的多态</h3><p>我们先来看一个泛型父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T fruit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fruit</span><span class="params">(T fruit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fruit = fruit;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">getFruit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.fruit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setFruit</span><span class="params">(T f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fruit=f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个子类试图重写父类的<code>getFruit</code>方法的话，则有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setFruit</span><span class="params">(String f)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.name = f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面子类的<code>protected void setFruit(String f)</code> 方法试图覆盖父类的同名方法，但是实际上<strong>由于泛型擦除的原因</strong> 父类擦除后的set方法变成了<code>protected void setFruit(Object f)</code> 。此时，子类重写的方法与父类方法中的参数类型已不相同。因此，这样无法达到重写父类方法的目的。</p><p>在实际的重写中，编译器为我们解决了这个麻烦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编译器在子类中自动生成了一个桥方法，由这个桥方法重写了父类的方法，再调用我们重写的子类方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setFruit</span><span class="params">(Object f)</span></span>&#123;</span><br><span class="line">setFruit（（String）f）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，相当于在子类自动生成了个代理方法来解决了泛型由类型擦除带来的多态问题</p><p>如果在子类中我们再试图复写父类的<code>get</code> 方法的话,则会产生一个与我们自己定义的<code>get</code> 方法签名相同但是返回参数不同的桥方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*我们在子类中自己定义的重写方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*编译器自动生成的桥方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getFruit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFruit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，这个桥方法在编译器中存在是合法的。且看下面的几个知识点：</p><blockquote><ul><li>方法签名 确实只有方法名+参数列表 。这毫无疑问！</li><li>我们绝对不能编写出方法签名一样的多个方法 。如果这样写程序，编译器是不会放过的。这也毫无疑问！</li><li>最重要的一点是：JVM会用参数类型和返回类型来确定一个方法。 一旦编译器通过某种方式自己编译出方法签名一样的两个方法(只能编译器自己来创造这种奇迹，我们程序员却不能人为的编写这种代码)。JVM还是能够分清楚这些方法的，前提是需要返回类型不一样。</li></ul></blockquote><h3 id="3-泛型中方法的冲突"><a href="#3-泛型中方法的冲突" class="headerlink" title="3.泛型中方法的冲突"></a>3.泛型中方法的冲突</h3><p>如果我们在一个泛型类中定义了一个如下所示的<code>equals</code> 方法，则编译器会不让通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译不通过</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则会有如下错误：</p><blockquote><p>【Error】    Name clash: The method equals(T) of type Pair<t> has the same erasure as equals(Object) of type Object but does not override it。</t></p></blockquote><p>其中原因正是由于泛型的类型擦除，导致我们编写的<code>equals</code> 方法变成了<code>public boolean equals(Object obj)</code> 。此方法签名与<code>Object</code> 类中的<code>equals</code>方法签名相同。这就变成了覆盖父类的方法，然而我们的本意并不是想覆盖父类的方法。因此，如果这里编译器不报出错误的话，会给程序猿隐形中带来一个大坑。</p><h3 id="4-创建泛型实例"><a href="#4-创建泛型实例" class="headerlink" title="4.创建泛型实例"></a>4.创建泛型实例</h3><p>通过<code>new</code> 关键字创建泛型是不可行的，一是由于泛型擦除，二是由于编译器不知道T是否有默认的构造器。可以通过以下几种方法来创建泛型的实例：</p><h4 id="1-传递一个工厂对象，并且通过它来创建实例"><a href="#1-传递一个工厂对象，并且通过它来创建实例" class="headerlink" title="1. 传递一个工厂对象，并且通过它来创建实例"></a>1. 传递一个工厂对象，并且通过它来创建实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FactoryI</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T x;</span><br><span class="line">    <span class="keyword">public</span> &lt;F extends FactoryI&lt;T&gt;&gt; Foo2(F factory) &#123;</span><br><span class="line">    x = factory.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFactory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">FactoryI</span>&lt;<span class="title">Widget</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Widget <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Widget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryConstraint</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Integer&gt;(<span class="keyword">new</span> IntegerFactory());</span><br><span class="line">        <span class="keyword">new</span> Foo2&lt;Widget&gt;(<span class="keyword">new</span> Widget.Factory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个创建实例的工厂对象，在泛型类中使用工厂对象来创建泛型实例。然后每个实例的具体类型自己实现工厂方法的接口，创建自己的实例即工厂对象，作为构造器入参传递给泛型类的构造器。</p><h4 id="2-利用模板设计模式"><a href="#2-利用模板设计模式" class="headerlink" title="2. 利用模板设计模式"></a>2. 利用模板设计模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> T element;</span><br><span class="line">    GenericWithCreate() &#123; element = create(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> T <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creator</span> <span class="keyword">extends</span> <span class="title">GenericWithCreate</span>&lt;<span class="title">X</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">X <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> X(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(element.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatorGeneric</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Creator c = <span class="keyword">new</span> Creator();</span><br><span class="line">        c.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将创建实例的工作放在钩子方法中，通过子类去实现它，以达到创建实例的目的。</p><h4 id="3-利用Class类的反射"><a href="#3-利用Class类的反射" class="headerlink" title="3. 利用Class类的反射"></a>3. 利用Class类的反射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getObject</span><span class="params">(Class&lt;T&gt; t)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-静态方法与泛型"><a href="#5-静态方法与泛型" class="headerlink" title="5. 静态方法与泛型"></a>5. 静态方法与泛型</h3><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p><p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-泛型类与异常"><a href="#6-泛型类与异常" class="headerlink" title="6. 泛型类与异常"></a>6. 泛型类与异常</h3><ol><li>泛型类不能继承Throwable类，所以泛型类的对象既不能捕获也不能抛出。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设上面是合法的，那么在catch的时候，我们就可以有如下的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Problem&lt;String&gt; e1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Problem&lt;Integer&gt; e1) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Problem类在编译后会擦除泛型信息，这就相当于上面同时catch住了两个相同的异常，这在Java语法中是不允许的。</p><ol><li>不能在catch子句中使用泛型变量，如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (T e) &#123; <span class="comment">//编译错误</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设上面合法，那么下面的情况就会导致catch顺序不符合Java语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        ...  </span><br><span class="line">    &#125; <span class="keyword">catch</span>(T e) &#123;  <span class="comment">//此处泛型擦除后变成了 catch（Throwable e）</span></span><br><span class="line">        ...  </span><br><span class="line">    &#125; <span class="keyword">catch</span>(IndexOutOfBounds e) &#123;  </span><br><span class="line">        ...</span><br><span class="line">    &#125;                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="？与T的区别"><a href="#？与T的区别" class="headerlink" title="？与T的区别"></a>？与T的区别</h2><ul><li>如果类型参数在方法声明中只出现一次，可以用通配符代替它。</li><li>当一个泛型用来表达方法的两个参数之间的关系时，则需要应该使用T，如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">autoConvertType</span><span class="params">(T obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">return</span>(T)obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>?表示不确定的类型，T表示一个固定的类型，可以作为一个变量类型在方法体的函数中调用，如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printColl</span><span class="params">(ArrayList&lt;T&gt; al)</span></span>&#123;  </span><br><span class="line">        Iterator&lt;T&gt; it = al.iterator();  </span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())  </span><br><span class="line">        &#123;  </span><br><span class="line">            T t = it.next();  </span><br><span class="line">            System.out.println(t.toString());  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么需要引入泛型"><a href="#为什么需要引入泛型" class="headerlink" title="为什么需要引入泛型"></a>为什么需要引入泛型</h2><ul><li><strong>保证代码类型安全。</strong></li></ul><p>在编译期不出现 <code>未经检查的转换</code> ，运行期就不会报出类型转换异常。</p><ul><li><strong>提高了代码可重用性</strong></li></ul><p>在《Java核心技术》中对泛型的定义是：</p><blockquote><p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。</p></blockquote><p>在泛型中，可以将不同数据类型作为参数来使用，这就可以使得不同数据类型公用同一套代码，自然提升了代码的可重用性。</p><blockquote><p>泛型接口比较实用的使用场景就是用作策略模式的公共策略</p></blockquote><p>作为策略模式的公共策略，会被很多类实现，同时需要支持传入不同的数据类型作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(T lhs, T rhs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型接口定义基本的规则，作为引用传递给客户端，这样就可以在运行的时候传入不同的策略实现类。</p><ul><li><strong>消除强制类型转换</strong></li></ul><p>存储任意类型的数据在集合中，但是取出来的时候都是object类型，此时必须强转。使用了泛型之后，编译器会自动插入类型转换的代码。所见即所得，使用时直接得到目标类型。</p><ul><li><strong>为了创建容器类</strong></li></ul><p>根据《Java 编程思想》中的描述，泛型出现的动机在于：</p><blockquote><p>有许多原因促成了泛型的出现，而最引人注意的一个原因，就是为了创建容器类。</p></blockquote><p>在《effective java》中也建议使用List来代替Array，因为List可以保证编译期的类型安全，而Array不能。</p><h2 id="何时产生未经检查的异常"><a href="#何时产生未经检查的异常" class="headerlink" title="何时产生未经检查的异常"></a>何时产生未经检查的异常</h2><p>使用泛型类或泛型方法时，没有指定参数化类型的具体数据类型是什么的时候，编译器会自动检查泛型的参数化类型，会报出未经检查的异常。</p><p>以上内容来自于对其他博客的整理和自己的思考,参考文章链接如下：</p><p><a href="https://segmentfault.com/a/1190000005337789" target="_blank" rel="noopener"><strong>参考文章一</strong></a></p><p><a href="https://juejin.im/entry/584abdff61ff4b0058d50547#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4" target="_blank" rel="noopener"><strong>参考文章二</strong></a> </p><p><a href="https://www.cnblogs.com/ggjucheng/p/3352519.html" target="_blank" rel="noopener"><strong>参考文章三</strong></a>  </p><p><a href="http://hinylover.space/2016/07/03/relearn-java-generic-2/" target="_blank" rel="noopener"><strong>参考文章四</strong></a></p><p><a href="https://blog.csdn.net/s10461/article/details/53941091#t11" target="_blank" rel="noopener"><strong>参考文章五</strong></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类型擦除&quot;&gt;&lt;a href=&quot;#类型擦除&quot; class=&quot;headerlink&quot; title=&quot;类型擦除&quot;&gt;&lt;/a&gt;类型擦除&lt;/h2&gt;&lt;p&gt;Java的泛型本质是参数化类型，就是将数据类型做为一个参数，在使用的时候再指定它的具体类型。但是因为Java使用了类型擦除，所以这个参数只存在于编译期，在运行期JVM是并不知道泛型的存在。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>辛德勒的名单</title>
    <link href="http://yoursite.com/2018/06/17/%E8%BE%9B%E5%BE%B7%E5%8B%92%E7%9A%84%E5%90%8D%E5%8D%95/"/>
    <id>http://yoursite.com/2018/06/17/辛德勒的名单/</id>
    <published>2018-06-17T05:06:51.000Z</published>
    <updated>2019-06-04T14:30:20.940Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Whoever saves one life, save the world entire</strong></p><p>毕业的时候，因为马上就没有六维了。所以我离开学校之前，特意买了一块硬盘。从六维上下了很多电影资源放在里面。而辛德勒的名单就一直放在硬盘里面，你一直没有看它。直到最近，我决定把我看过的每一部影片，都写一篇博客记录下来，于是我开始翻起了我的硬盘，发现了这部电影。</p><p><img src="/2018/06/17/辛德勒的名单/p492406715.jpg" alt=""></p><a id="more"></a><p>没想到，影片居然是连姆尼森主演的。不得不说，年轻的连姆尼森真的很帅。</p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180609225448.png" alt=""></p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180609225501.png" alt=""></p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180609225514.png" alt=""></p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180609225541.png" alt=""></p><p>当最后柏林来的命令需要把所有的犹太人送到奥斯威辛集中营的时候。辛德勒在面临和老会计离别的时候，老会计终于肯跟辛德勒喝一杯酒。</p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180617133218.png" alt=""></p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180617133233.png" alt=""></p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180617133245.png" alt=""></p><p>辛德勒按人头算钱向军官买下了这些所有的工人，他要把他们都带回他的家乡，他要拯救快被灭族的犹太人。</p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180609230546.png" alt=""></p><p>海伦，一直在纳粹军官家做仆人，然而军官却爱上了她，但是她是一个犹太人。也正是这个原因，军官才一直没有杀了她。到后来，辛德勒试图把她带走的时候。军官居然想和他一起，白头偕老。但是在那个背景下，他们之间的爱情是不被允许的所以军官后来让辛德勒带走了她。</p><p>当德国宣布投降之后，辛德勒身为一个纳粹，不得不开始逃亡，在离别之前，所有的犹太人来打造了这枚戒指来送给他。这一段的表演太棒了，辛德勒哭的特别伤心，对自己没有拯救更多的人而愧疚。</p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180609235256.png" alt=""></p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180609235349.png" alt=""></p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180609235436.png" alt=""></p><p><strong>当你挽救了一条生命，就等于挽救了全世界。</strong></p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180617133612.png" alt=""></p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180617133623.png" alt=""></p><p>影片的最后介绍了，辛德勒救下来的犹太人的现状。后来辛德勒获得了耶路撒冷大屠杀纪念馆颁赠的正义勋章并受邀在当地的正义路种植了一棵小树，而那棵树一直到今天还存在。至今在波兰活着的犹太人还不到4000人。然而辛德勒犹太人的后裔已经超过6000人。<br>在那样的时代下，当你身边全都是恶魔的时候，你很难不被同化成一个恶魔。在电影里有一幕是，当犹太人迁往隔离区时，孩子向那些犹太人扔泥土并且大喊着。看到这里，我心里十分震惊，在那个时代背景下连一个孩子都认为犹太人是最低等最下贱的种族。</p><p><img src="/2018/06/17/辛德勒的名单/微信截图_20180623230150.png" alt=""></p><p>但是，即便是在那样的时代下，也有像辛德勒这样伟大的人，有着自己独立的人格和思想。在这个肮脏的世界里维持着自己的良知，艰难的与那些恶魔对抗下去。</p><p>看完电影觉得自己非常幸运地生活在一个没有战争的国度，同时也没有宗教信仰主义。每次一想到这里都会觉得自己身处在一个如此安全的环境里真的应该感谢我们的祖国。</p><p>另一个感觉就是，即使在现如今的时代下，也有很多人是没有自己的良知的，就像电影里的纳粹一样，他们在干着吸人血的事情，比如往奶粉里掺三聚氰胺的。同时也有很多人是没有自己的思想和独立的人格的，就像电影里的小女孩一样，这类人很可悲，但这类人也很多，就像现在网上的那些键盘侠一样。然而真正能够改变这个世界的，是辛德勒这类人，他们怀揣着正义的理想，在这个肮脏的世界里摸爬滚打，不惜弄脏自己的双手也要坚持下去。大概这就是为什么老罗会说，未来是属于那些愿意弄脏自己双手的人的~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Whoever saves one life, save the world entire&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;毕业的时候，因为马上就没有六维了。所以我离开学校之前，特意买了一块硬盘。从六维上下了很多电影资源放在里面。而辛德勒的名单就一直放在硬盘里面，你一直没有看它。直到最近，我决定把我看过的每一部影片，都写一篇博客记录下来，于是我开始翻起了我的硬盘，发现了这部电影。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/06/17/辛德勒的名单/p492406715.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="电影" scheme="http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="史蒂文·斯皮尔伯格" scheme="http://yoursite.com/tags/%E5%8F%B2%E8%92%82%E6%96%87%C2%B7%E6%96%AF%E7%9A%AE%E5%B0%94%E4%BC%AF%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>星际穿越</title>
    <link href="http://yoursite.com/2018/06/10/%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A/"/>
    <id>http://yoursite.com/2018/06/10/星际穿越/</id>
    <published>2018-06-10T12:20:29.000Z</published>
    <updated>2019-06-04T14:30:20.748Z</updated>
    
    <content type="html"><![CDATA[<p>诺兰大神14年的电影，上周末又拿出来再刷一遍，看得我好几次起鸡皮疙瘩，非常感动。看完觉得从另一个角度理解了时间，空间，虫洞，黑洞，同时诺兰又在电影里加上了人性和爱。</p><p><img src="/2018/06/10/星际穿越/p1839451104.jpg" alt=""><img src="/2018/06/10/星际穿越/p2205519883.jpg" alt=""></p><a id="more"></a><p><img src="/2018/06/10/星际穿越/微信截图_20180603135030.png" alt=""></p><p><img src="/2018/06/10/星际穿越/微信截图_20180603135057.png" alt=""></p><p>老物理学家说他害怕的是时间。是的，他已经解出了那个方程式，知道一切无望。只有B计划才是唯一能将人类种族繁衍下去的办法。他直到临终前都一直在说<code>Do not go gentle into that good night</code> 。诗里的night或许指的是地球上人类的灭亡，所以他即使已经算出了方程式，也希望可以找到一些方法拯救留在这个星球上的人类。所以他说自己害怕的是时间。在临终前，告诉了墨菲真相，他希望墨菲可以<code>Do not go gentle into that good night</code>,或许她可以拯救留在这个星球上的人类。</p><p><img src="/2018/06/10/星际穿越/微信截图_20180603143045.png" alt=""></p><p><img src="/2018/06/10/星际穿越/微信截图_20180603143100.png" alt=""></p><p><img src="/2018/06/10/星际穿越/微信截图_20180603143109.png" alt=""></p><p><img src="/2018/06/10/星际穿越/微信截图_20180603143126.png" alt=""></p><blockquote><p>不要温和地走入那良夜 </p><p>不要温和地走入那良夜，<br>老年人应该燃烧并对着日暮呼喊；<br>怒斥、怒斥那光明的微灭。 </p><p>尽管聪明人临终时知道黑暗真确，<br>是因为他们的话语没有迸射闪电，<br>他们并不温和地走入那良夜。 </p><p>好人，当最后一浪涌过，号呼他们脆弱的功业<br>本可以很光辉地起舞于绿色的海湾，<br>也怒斥、怒斥那光明的微灭。 </p><p>狂放的人碰见并歌唱过太阳的飞越，<br>意识到，太晚了，他们曾使它在途中哀叹，<br>他们也并不温和地走入那良夜。 </p><p>沉肃的人，临死时用目眩的视觉<br>看到瞎眼也能像流星般闪耀而欣欢，<br>也怒斥、怒斥那光明的微灭。 </p><p>而您呀，我的父亲，身处高度的悲切，<br>请用您的热泪诅咒、祝福我，我祈愿。<br>不要温和地走入那良夜，<br>怒斥、怒斥那光明的微灭。 </p></blockquote><p>上面是这首诗的一个翻译版本。这首诗原本是诗人写给临危的父亲的，诺兰将这首诗作为电影的主题，是写给临危的地球和人类的。<code>Do not go gentle into that good night</code>像是老教授对人类的呐喊，而库珀和墨菲则像是在<code>rage against the dying of the light</code> </p><p>最后，男主马修麦康纳和安妮海瑟薇的新片《宁静》最近曝光了预告片，期待一波~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;诺兰大神14年的电影，上周末又拿出来再刷一遍，看得我好几次起鸡皮疙瘩，非常感动。看完觉得从另一个角度理解了时间，空间，虫洞，黑洞，同时诺兰又在电影里加上了人性和爱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/06/10/星际穿越/p1839451104.jpg&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/2018/06/10/星际穿越/p2205519883.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="电影" scheme="http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="诺兰" scheme="http://yoursite.com/tags/%E8%AF%BA%E5%85%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git以及TortoiseGit安装使用</title>
    <link href="http://yoursite.com/2018/06/10/Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2018/06/10/Git使用手册/</id>
    <published>2018-06-10T12:02:12.000Z</published>
    <updated>2019-06-04T14:30:20.676Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-下载安装Git-2-8-3-64-bit-exe程序"><a href="#1-下载安装Git-2-8-3-64-bit-exe程序" class="headerlink" title="1. 下载安装Git-2.8.3-64-bit.exe程序"></a>1. 下载安装Git-2.8.3-64-bit.exe程序</h4><ul><li>默认选项一直next即可。</li></ul><ul><li><p>本地初始化git的配置项，设置username和email，使用如下命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"abc"</span></span><br><span class="line">git config --global user.email <span class="string">"123abc@163.com"</span></span><br></pre></td></tr></table></figure></li></ul><p>–global 表示全局属性，所有的git项目都会公用这个属性。因为Git是分布式版本控制系统，需要一个用户名和email作为一个标识。</p><a id="more"></a><h4 id="2-配置ssh-key"><a href="#2-配置ssh-key" class="headerlink" title="2. 配置ssh key"></a>2. 配置ssh key</h4><ul><li><p><strong>生成秘钥对</strong> </p><p>在Git Bash中输入以下命令 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;123abc@163.com&quot;</span><br></pre></td></tr></table></figure><p>之后可以不用设置密码，按下3个回车键即可。接下来可以去默认路径 <code>C:\Users\banana\.ssh</code>下查看生成的两个文件，分别为 私钥：<code>id_rsa</code> 公钥：<code>id_rsa.pub</code> </p><p><img src="/2018/06/10/Git使用手册/微信截图_20180324002602.png" alt=""></p></li><li><p>​ <strong>添加公钥到远程仓库</strong><br>打开GitHub主页，在<code>Settings</code>–&gt;<code>SSH and GPG keys</code>中，点击<code>New SSH key</code> 按钮；</p><p>再打开公钥文件，将其中的字符串完整复制，粘贴到<code>key</code> 中</p><p><img src="/2018/06/10/Git使用手册/微信截图_20180324002258.png" alt=""></p><p>执行<code>ssh -T git@github.com</code> 命令，查看公钥是否配置成功了，如下图所示则表示成功：</p><p><img src="/2018/06/10/Git使用手册/微信截图_20180324213757.png" alt=""></p></li><li><p><strong>将私钥添加到自己的系统中</strong> </p><p>使用命令： <code>ssh-add ~/.ssh/id_rsa</code>  添加私钥至系统中，若无效的话，建议采取以下两种方法：</p><ol><li>先执行 <code>eval &#39;ssh-agent-s&#39;</code> 再执行 <code>ssh-add ~/.ssh/id_rsa</code> ；</li><li>先执行<code>ssh-agent bash --login -i</code> 启动bash，或者说把bash挂到ssh-agent下面，再执行 <code>ssh-add</code></li></ol><p>当看到下图所示结果时，则表示成功了</p></li></ul><p><img src="/2018/06/10/Git使用手册/微信截图_20180324003452.png" alt=""></p><h4 id="3-配置远程仓库"><a href="#3-配置远程仓库" class="headerlink" title="3. 配置远程仓库"></a>3. 配置远程仓库</h4><ul><li><p>登录github账号，新建一个远程仓库。</p></li><li><p>在本地建一个与仓库同名的文件夹，在文件夹中打开Git Bash，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;# commang&quot; &gt;&gt; README.md</span><br><span class="line">新建一个README.md文件，写入“# commang”</span><br><span class="line">git init</span><br><span class="line">初始化git文件夹，创建master分支和.git文件夹</span><br><span class="line">git add README.md</span><br><span class="line">将工作区中的README.md文件添加进暂存区</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">将暂存区的文件提交到master分支上</span><br><span class="line">git remote add origin git@github.com:abc/gitTest.git</span><br><span class="line">配置远程仓库地址命名为origin</span><br><span class="line">git push -u origin master</span><br><span class="line">将本地master分支的数据push到远程仓库的master分支上</span><br></pre></td></tr></table></figure></li><li><p>若没能成功push去服务器的话，可以去检查下本地<code>.git</code> 文件夹下的<code>config</code> 文件，其中的url必须与上述命令中的远程地址相同。</p><p><img src="/2018/06/10/Git使用手册/微信截图_20180324141838.png" alt=""></p><h4 id="4-安装TortoiseGit-2-6-0-0-64bit-msi文件"><a href="#4-安装TortoiseGit-2-6-0-0-64bit-msi文件" class="headerlink" title="4.安装TortoiseGit-2.6.0.0-64bit.msi文件"></a>4.安装TortoiseGit-2.6.0.0-64bit.msi文件</h4></li></ul><p><a href="https://tortoisegit.org/download/" target="_blank" rel="noopener">下载TortoiseGit和中文语言包</a></p><ul><li><p>默认选项一直next即可。</p></li><li><p>创建本地仓库，在文件夹中<code>右键--&gt;Git在这里创建版本库</code> （我使用的是中文版本），如下图：<br><img src="/2018/06/10/Git使用手册/微信截图_20180324214536.png" alt=""></p><p>不用勾选，直接确定即可。</p></li><li><p><strong>设置网络和远端</strong> </p><p><strong>1. <code>右键--&gt;设置</code> 将本地安装Git的ssh.exe路径地址配置到网络上，如下图：</strong></p><p><img src="/2018/06/10/Git使用手册/微信截图_20180324215326.png" alt=""></p><p>我的Git是安装在<code>C:\software\Git\</code>路径下 。</p><p><strong>2. 将远程仓库的地址粘贴到<code>URL</code>和<code>推送URL</code> 中，如下图：</strong></p><p><img src="/2018/06/10/Git使用手册/微信截图_20180324214754.png" alt=""></p></li><li><p>至此，你已经可以愉快的使用右键进行push和update了，但是会时不时遇到需要输入密码，但是你怎么输都不对的情况。</p></li></ul><h4 id="5-使用本地Pageant记住你的私钥密码"><a href="#5-使用本地Pageant记住你的私钥密码" class="headerlink" title="5. 使用本地Pageant记住你的私钥密码"></a>5. 使用本地<code>Pageant</code>记住你的私钥密码</h4><ol><li><p>开始菜单找到TortoiseGit菜单下的puttygen，打开puttygen</p><p><img src="/2018/06/10/Git使用手册/1.png" alt=""></p></li></ol><ol start="2"><li><p>选择导入秘钥</p><p><img src="/2018/06/10/Git使用手册/2.png" alt=""></p></li><li><p>选择C:\Users\Administrator.ssh目录下的私钥，并输入秘钥密码</p><p><img src="/2018/06/10/Git使用手册/3.png" alt=""></p><p><img src="/2018/06/10/Git使用手册/3.1.png" alt=""></p></li><li><p>选择save private key，将私钥另存为ppk格式的秘钥</p><p><img src="/2018/06/10/Git使用手册/4.png" alt=""></p><p><img src="/2018/06/10/Git使用手册/4.1.png" alt=""></p></li><li><p>开始菜单找到TortoiseGit菜单下的pageant，打开</p><p><img src="/2018/06/10/Git使用手册/5.png" alt=""></p></li><li><p>点击add key，选择ppk秘钥，输入密码</p><p><img src="/2018/06/10/Git使用手册/6.png" alt=""></p><p><img src="/2018/06/10/Git使用手册/6.1.png" alt=""></p><p>每次开机启动pagent并添加ppk秘钥</p></li><li><p>点击torise git – settings </p><p><img src="/2018/06/10/Git使用手册/7.png" alt=""></p></li><li><p>设置network—ssh的路径，设置为“C:\Program Files\TortoiseGit\bin\TortoisePlink.exe” </p><p><img src="/2018/06/10/Git使用手册/8.png" alt=""></p></li></ol><h4 id="6-使用过程遇到的问题"><a href="#6-使用过程遇到的问题" class="headerlink" title="6. 使用过程遇到的问题"></a>6. 使用过程遇到的问题</h4><ol><li><p><strong>在新文件下拉取远程仓库报错：You asked to pull from the remote ‘origin’, but did not specify:a branch. Because this is not the default configured remotefor your current branch, you must specify a branch on the command line.</strong></p><p>找到：<code>.git/config</code>文件 添加如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote = origin</span><br><span class="line">    merge = refs/heads/master</span><br></pre></td></tr></table></figure></li><li><p><strong>在设置git远端地址时，尽量修改远端名称</strong> </p><p><img src="/2018/06/10/Git使用手册/C:/Users\banana\Pictures\微信截图_20180327222554.png" alt=""></p><p>如果不设置的话，在同一个文件夹下，新建两个文件夹，在这两个文件夹中分别拉取不同仓库的内容时就会报错</p></li><li><p><strong>当新建了一个空的远程仓库，本地创建了一个关联到远端地址的仓库后，不要尝试拉取，否则会报出<code>Couldn&#39;t find remote ref master</code>错误信息</strong></p></li><li><p><strong>idea使用Git时，需要配置ssh</strong></p><ul><li><strong>设置私钥地址</strong></li></ul><p><img src="/2018/06/10/Git使用手册/C:/Users\banana\Pictures\微信截图_20180327233928.png" alt=""></p><p>​</p><ul><li><strong>设置Git地址和SSH executable 为Native</strong></li></ul><p><img src="/2018/06/10/Git使用手册/C:/Users\banana\Pictures\微信截图_20180327234038.png" alt=""></p><ul><li><p><strong>设置github地址</strong></p><p><img src="/2018/06/10/Git使用手册/C:/Users\banana\Pictures\微信截图_20180327234303.png" alt=""></p></li></ul></li><li><p><strong>对于重命名改名字等操作都可以在本地，修改完后添加进版本控制再push到远端仓库即可</strong></p></li><li><p>对于在第2步中修改了本地远端的名称的操作，如果在idea中拉取代码的话，回报出这个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Can&apos;t Update</span><br><span class="line">No tracked branch configured for branch master or the branch doesn&apos;t exist.</span><br><span class="line">To make your branch track a remote branch call, for example,</span><br><span class="line">git branch --set-upstream-to origin/master master (show balloon)</span><br></pre></td></tr></table></figure><p>此时，可以执行命令<code>git branch --set-upstream-to origin-repo/master master</code> 意思是使我们在git设置的本地远程名称<code>origin-repo/master</code>追踪远程仓库的<code>master</code>分支</p><p>​</p><p>​</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-下载安装Git-2-8-3-64-bit-exe程序&quot;&gt;&lt;a href=&quot;#1-下载安装Git-2-8-3-64-bit-exe程序&quot; class=&quot;headerlink&quot; title=&quot;1. 下载安装Git-2.8.3-64-bit.exe程序&quot;&gt;&lt;/a&gt;1. 下载安装Git-2.8.3-64-bit.exe程序&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;默认选项一直next即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本地初始化git的配置项，设置username和email，使用如下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email &lt;span class=&quot;string&quot;&gt;&quot;123abc@163.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;–global 表示全局属性，所有的git项目都会公用这个属性。因为Git是分布式版本控制系统，需要一个用户名和email作为一个标识。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="GIT" scheme="http://yoursite.com/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>Nginx安装部署web工程</title>
    <link href="http://yoursite.com/2018/05/30/Nginx%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2web%E5%B7%A5%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/30/Nginx安装部署web工程/</id>
    <published>2018-05-30T11:40:59.000Z</published>
    <updated>2019-06-04T14:30:20.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h2><h3 id="1-下载依赖包"><a href="#1-下载依赖包" class="headerlink" title="1. 下载依赖包"></a>1. 下载依赖包</h3><ul><li><p>如果你的服务器可以连接网络的话可以直接通过命令的方式下载tar包</p><ol><li><p>下载PCRE库</p><p><code>wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz</code></p></li><li><p>下载zlib库</p><p><code>wget http://zlib.net/zlib-1.2.10.tar.gz</code></p></li><li><p>下载OpenSSL库</p><p><code>wget https://www.openssl.org/source/openssl-1.0.2o.tar.gz</code></p></li></ol><a id="more"></a></li><li><p>如果你的服务器无法联网，可以自行去上面的<code>wget</code>命令后面的地址下载对应的tar包文件，ftp路径也可以直接通过浏览器打开，再将他们传到服务器中。</p></li></ul><h3 id="2-安装依赖包"><a href="#2-安装依赖包" class="headerlink" title="2. 安装依赖包"></a>2. 安装依赖包</h3><ul><li><p>安装PCRE库</p><ul><li><p><code>tar -zxvf pcre-8.37.tar.gz</code> 先使用命令解压tar包</p></li><li><p><code>cd pcre-8.38</code> 进去解压后的文件目录</p></li><li><p><code>./configure</code> 运行初始化脚本</p><p><strong>如果此时你不是用root用户安装，或者希望指定安装根路径，可以使用<code>--prefix=</code>参数来指定安装路径</strong> </p><p>如：使用<code>./configure --prefix=/home/test/pcre</code>命令来指定将pcre安装到<code>/home/tese/pcre</code>目录下</p></li><li><p><code>make</code> 使用make命令尝试编译</p></li><li><p><code>make install</code> 编译安装</p></li></ul></li><li><p>安装zlib库</p><ul><li><p><code>tar -zxvf zlib-1.2.10.tar.gz</code> 先使用命令解压tar包</p></li><li><p><code>cd zlib-1.2.10</code> 进去解压后的文件目录</p></li><li><p><code>./configure</code> 运行初始化脚本</p><p><strong>如果此时你不是用root用户安装，或者希望指定安装根路径，可以使用<code>--prefix=</code>参数来指定安装路径</strong> </p><p>如：使用<code>./configure --prefix=/home/test/zlib</code>命令来指定将zlib安装到<code>/home/test/zlib</code>目录下</p></li><li><p><code>make</code> 使用make命令尝试编译</p></li><li><p><code>make install</code> 编译安装</p></li></ul></li><li><p>安装OpenSSL库</p><ul><li><code>tar -zxvf openssl-1.0.2o.tar.gz</code> 使用命令解压tar包即可</li></ul></li></ul><h3 id="3-安装Nginx"><a href="#3-安装Nginx" class="headerlink" title="3. 安装Nginx"></a>3. 安装Nginx</h3><h4 id="3-1-安装步骤"><a href="#3-1-安装步骤" class="headerlink" title="3.1 安装步骤"></a>3.1 安装步骤</h4><ul><li><p>先下载Nginx的tar包，我这里选择的是最新的稳定版<code>nginx-1.14.0.tar.gz</code></p><p>跟上面安装依赖包一样，如果你的服务器可以联网的话建议使用<code>wget http://nginx.org/download/nginx-1.14.0.tar.gz</code>命令来下载tar包；如果不能联网的话建议自己通过浏览器访问http地址下载</p></li><li><p><code>tar -zxvf nginx-1.14.0.tar.gz</code> 解压Nginx的tar包</p></li><li><p><code>cd nginx-1.14.0</code> 进入解压后的目录</p></li><li><p><code>./configure</code>运行初始化脚本</p><p><strong>注意：Nginx默认的安装路径是<code>/usr/local/nginx</code>,如果你不是使用root用户的话，就不能使用该路径。这里同样可以使用<code>--prefix=</code>参数来指定安装路径</strong> </p><p>同时，你可以使用<code>--with-pcre=/home/test/pcre-8.38</code>来指定pcre安装路径</p><p>使用<code>--with-zlib=/home/test/zlib</code>来指定zlib的安装路径</p></li><li><p><code>make</code> 使用make命令尝试编译</p></li><li><p><code>make install</code> 编译安装</p></li><li><p><code>cd sbin</code> 进入sbin目录下</p></li><li><p><code>./nginx</code> 启动Nginx  同时可以使用 <code>./nginx -s reload</code> 重启Nginx 使用<code>./nginx -s stop</code> 关停Nginx</p></li></ul><h4 id="3-2-Nginx常用编译选项"><a href="#3-2-Nginx常用编译选项" class="headerlink" title="3.2 Nginx常用编译选项"></a>3.2 Nginx常用编译选项</h4><blockquote><p>make是用来编译的，它从Makefile中读取指令，然后编译。</p><p>make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p><p>configure命令是用来检测你的安装平台的目标特征的。它定义了系统的各个方面，包括nginx的被允许使用的连接处理的方法，比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本，执行结束时，它会创建一个Makefile文件。nginx的configure命令支持以下参数：</p><ul><li><p><code>--prefix=*path*</code>    定义一个目录，存放服务器上的文件 ，也就是nginx的安装目录。默认使用 <code>/usr/local/nginx。</code></p></li><li><p><code>--sbin-path=*path*</code> 设置nginx的可执行文件的路径，默认为  <code>*prefix*/sbin/nginx</code>.</p></li><li><p><code>--conf-path=*path*</code>  设置在nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为<code>*prefix*/conf/nginx.conf</code>.</p></li><li><p><code>--pid-path=*path*  设置nginx.pid文件，将存储的主进程的进程号。安装完成后，可以随时改变的文件名 ， 在nginx.conf配置文件中使用 PID指令。默认情况下，文件名 为`</code><em>prefix</em>/logs/nginx.pid`.</p></li><li><p><code>--error-log-path=*path*</code> 设置主错误，警告，和诊断文件的名称。安装完成后，可以随时改变的文件名 ，在nginx.conf配置文件中 使用 的error_log指令。默认情况下，文件名 为<code>*prefix*/logs/error.log</code>.</p></li><li><p><code>--http-log-path=*path*</code>  设置主请求的HTTP服务器的日志文件的名称。安装完成后，可以随时改变的文件名 ，在nginx.conf配置文件中 使用 的access_log指令。默认情况下，文件名 为<code>*prefix*/logs/access.log</code>.</p></li><li><p><code>--user=*name*</code>  设置nginx工作进程的用户。安装完成后，可以随时更改的名称在nginx.conf配置文件中 使用的 user指令。默认的用户名是nobody。</p></li><li><p><code>--group=*name*</code>  设置nginx工作进程的用户组。安装完成后，可以随时更改的名称在nginx.conf配置文件中 使用的 user指令。默认的为非特权用户。</p></li><li><p><code>--with-select_module</code> <code>--without-select_module 启用或禁用构建一个模块来允许服务器使用select()方法。该模块将自动建立，如果平台不支持的kqueue，epoll，rtsig或/dev/poll。</code></p></li><li><p><code>--with-poll_module</code> <code>--without-poll_module</code> 启用或禁用构建一个模块来允许服务器使用poll()方法。该模块将自动建立，如果平台不支持的kqueue，epoll，rtsig或/dev/poll。</p></li><li><p><code>--without-http_gzip_module</code> — 不编译压缩的HTTP服务器的响应模块。编译并运行此模块需要zlib库。</p></li><li><p><code>--without-http_rewrite_module</code>  不编译重写模块。编译并运行此模块需要PCRE库支持。</p></li><li><p><code>--without-http_proxy_module</code> — 不编译http_proxy模块。</p></li><li><p><code>--with-http_ssl_module</code> — 使用https协议模块。默认情况下，该模块没有被构建。建立并运行此模块的OpenSSL库是必需的。</p></li><li><p><code>--with-pcre=*path*</code> — 设置PCRE库的源码路径。PCRE库的源码（版本4.4 - 8.30）需要从PCRE网站下载并解压。其余的工作是Nginx的./ configure和make来完成。正则表达式使用在location指令和 ngx_http_rewrite_module 模块中。</p></li><li><p><code>--with-pcre-jit</code> —编译PCRE包含“just-in-time compilation”（1.1.12中， pcre_jit指令）。</p></li><li><p><code>--with-zlib=*path*</code> —设置的zlib库的源码路径。要下载从 zlib（版本1.1.3 - 1.2.5）的并解压。其余的工作是Nginx的./ configure和make完成。ngx_http_gzip_module模块需要使用zlib 。</p></li><li><p><code>--with-cc-opt=*parameters*</code> — 设置额外的参数将被添加到CFLAGS变量。例如,当你在FreeBSD上使用PCRE库时需要使用:<code>--with-cc-opt=&quot;-I /usr/local/include。</code>.如需要需要增加 <code>select()支持的文件数量</code>:<code>--with-cc-opt=&quot;-D FD_SETSIZE=2048&quot;.</code></p></li><li><p><code>--with-ld-opt=*parameters*</code> —设置附加的参数，将用于在链接期间。例如，当在FreeBSD下使用该系统的PCRE库,应指定:<code>--with-ld-opt=&quot;-L /usr/local/lib&quot;.</code></p></li><li><p>典型实例(下面为了展示需要写在多行，执行时内容需要在同一行)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;   ./configure</span><br><span class="line">&gt;       --sbin-path=/usr/local/nginx/nginx</span><br><span class="line">&gt;       --conf-path=/usr/local/nginx/nginx.conf</span><br><span class="line">&gt;       --pid-path=/usr/local/nginx/nginx.pid</span><br><span class="line">&gt;       --with-http_ssl_module</span><br><span class="line">&gt;       --with-pcre=../pcre-4.4</span><br><span class="line">&gt;       --with-zlib=../zlib-1.1.3</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="部署web工程"><a href="#部署web工程" class="headerlink" title="部署web工程"></a>部署web工程</h2><h3 id="1-关于Nginx配置文件"><a href="#1-关于Nginx配置文件" class="headerlink" title="1. 关于Nginx配置文件"></a>1. 关于Nginx配置文件</h3><p>在部署web工程前，我们需要了解Nginx的配置文件。Nginx的配置文件存放在<code>nginx/conf/nginx.conf</code>。我们需要打开这个文件根据自己的web工程需求配置这个文件。</p><blockquote><p>在nginx配置文件中主要分为四部分：<code>main</code> 全局设置，<code>server</code>主机设置，<code>upstream</code>（上游服务器设置，主要为反向代理、负载均衡相关配置）和 <code>location</code>（URL匹配特定位置后的设置） main部分设置的指令将影响其它所有部分的设置；server部分的指令主要用于指定虚拟主机域名、IP和端口；upstream的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；location部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。他们之间的关系式：server继承main，location继承server；upstream既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。 </p></blockquote><p>先贴一个配置文件，再来按照这个文件进行说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line"></span><br><span class="line">#在配置文件的顶级main部分，worker角色的工作进程的个数，master进程是接收并分配请求给worker处理。这个数值简单一点可以设置为cpu的核数grep ^processor /proc/cpuinfo | wc -l，也是 auto 值，如果开启了ssl和gzip更应该设置成与逻辑CPU数量一样甚至为2倍，可以减少I/O操作。如果nginx服务器还有其它服务，可以考虑适当减少。</span><br><span class="line"></span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">#写在events部分。每一个worker进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。nginx作为反向代理服务器，计算公式 最大连接数 = worker_processes * worker_connections/4，所以这里客户端最大连接数是1024，这个可以增到到8192都没关系，看情况而定，但不能超过后面的worker_rlimit_nofile。当nginx作为http服务器时，计算公式里面是除以2。</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。</span><br><span class="line">    sendfile        on;</span><br><span class="line">    # tcp_nopush     on;</span><br><span class="line">#长连接超时时间，单位是秒。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s内没上传完成会导致失败。如果设置时间过长，用户又多，长时 间保持连接会占用大量资源。</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">  # gzip压缩功能设置</span><br><span class="line"># 开启gzip压缩输出，减少网络传输</span><br><span class="line">    gzip on;</span><br><span class="line">#设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是20。建议设置成大于1k的字节数，小于1k可能会越压越大</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">#设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。</span><br><span class="line">    gzip_buffers    4 16k;</span><br><span class="line">#gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)</span><br><span class="line">    gzip_comp_level 6;</span><br><span class="line">#匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。</span><br><span class="line">    gzip_types text/html text/plain text/css text/javascript application/json application/javascript application/x-javascript application/xml;</span><br><span class="line">    #和http头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过gzip压缩的页面，例如，用Squid缓存经过Nginx压缩的数据。。</span><br><span class="line">gzip_vary on;</span><br><span class="line">  </span><br><span class="line">  # http_proxy 设置</span><br><span class="line">#允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值</span><br><span class="line">    client_max_body_size   10m;</span><br><span class="line">#缓冲区代理缓冲用户端请求的最大字节数</span><br><span class="line">    client_body_buffer_size   128k;</span><br><span class="line">#nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">    proxy_connect_timeout   75;</span><br><span class="line">#连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时)</span><br><span class="line">    proxy_read_timeout   75;</span><br><span class="line">#设置代理服务器（nginx）从后端realserver读取并保存用户头信息的缓冲区大小，默认与proxy_buffers大小相同，其实可以将这个指令值设的小一点</span><br><span class="line">    proxy_buffer_size   4k;</span><br><span class="line">#proxy_buffers缓冲区，nginx针对单个连接缓存来自后端realserver的响应，网页平均  在32k以下的话，这样设置</span><br><span class="line">    proxy_buffers   4 32k;</span><br><span class="line">#高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">    proxy_busy_buffers_size   64k;</span><br><span class="line">#当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。proxy_temp_path（可以在编译的时候）指定写到哪那个目录。。</span><br><span class="line">    proxy_temp_file_write_size  64k;</span><br><span class="line">#指定将上面的临时文件写到哪那个目录。</span><br><span class="line">    proxy_temp_path   /usr/local/nginx/proxy_temp 1 2;</span><br><span class="line"></span><br><span class="line">  # 设定负载均衡后台服务器列表 </span><br><span class="line">    upstream  arc  &#123; </span><br><span class="line">              #ip_hash; </span><br><span class="line">              server   192.168.10.100:8080 max_fails=2 fail_timeout=30s ;  </span><br><span class="line">              server   192.168.10.101:8080 max_fails=2 fail_timeout=30s ;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  # 很重要的虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">#虚拟主机监听的端口</span><br><span class="line">        listen       8001;</span><br><span class="line">#服务器名</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset utf-8;</span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">        #对 / 所有做负载均衡+反向代理</span><br><span class="line">        location / &#123;</span><br><span class="line">   #定义服务器的默认网站根目录位置。</span><br><span class="line">            root   html;</span><br><span class="line">   #定义路径下默认访问的文件名</span><br><span class="line">            index  index.jsp index.html index.htm;</span><br><span class="line">   #请求转向arc定义的服务器列表，即反向代理，对应upstream负载均衡器。</span><br><span class="line">            proxy_pass        http://arc;</span><br><span class="line">   #下面这几个就这么设置吧  具体的我也不清楚</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header  Host  $host;</span><br><span class="line">            proxy_set_header  X-Real-IP  $remote_addr;  </span><br><span class="line">            proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ## 其它虚拟主机，server 指令开始</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-部署前端工程"><a href="#2-部署前端工程" class="headerlink" title="2. 部署前端工程"></a>2. 部署前端工程</h3><p>将web项目上传到Nginx的安装目录中的<code>html</code>文件夹中。修改<code>nginx.conf</code>配置文件。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ol><li><p>web端不能访问</p><p>检查防火墙是否关闭！关闭防火墙：<code>service iptables stop</code></p></li><li><p>非root用户报出<code>bind() to 0.0.0.0:80 failed (13:Permission denied)</code>错误</p><p>这是由于非root用户启动时，<code>nginx.conf</code>文件中配置的端口为<code>80</code>，而在Linux中只有root用户才能使用1024以下的端口。所以只要讲配置文件中的端口修改为1024以上即可。</p></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.nginx.cn/install" target="_blank" rel="noopener">Nginx安装</a></p><p><a href="https://blog.csdn.net/tototuzuoquan/article/details/47381907" target="_blank" rel="noopener">Nging下部署项目，配置文件修改</a></p><p><a href="http://seanlook.com/2015/05/17/nginx-install-and-config/" target="_blank" rel="noopener">nginx服务器安装及配置文件详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nginx安装&quot;&gt;&lt;a href=&quot;#Nginx安装&quot; class=&quot;headerlink&quot; title=&quot;Nginx安装&quot;&gt;&lt;/a&gt;Nginx安装&lt;/h2&gt;&lt;h3 id=&quot;1-下载依赖包&quot;&gt;&lt;a href=&quot;#1-下载依赖包&quot; class=&quot;headerlink&quot; title=&quot;1. 下载依赖包&quot;&gt;&lt;/a&gt;1. 下载依赖包&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果你的服务器可以连接网络的话可以直接通过命令的方式下载tar包&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载PCRE库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载zlib库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget http://zlib.net/zlib-1.2.10.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下载OpenSSL库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget https://www.openssl.org/source/openssl-1.0.2o.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux环境" scheme="http://yoursite.com/categories/Linux%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>关于第一次换工作的面试经验</title>
    <link href="http://yoursite.com/2018/05/27/%E5%85%B3%E4%BA%8E%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8D%A2%E5%B7%A5%E4%BD%9C%E7%9A%84%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <id>http://yoursite.com/2018/05/27/关于第一次换工作的面试经验/</id>
    <published>2018-05-27T15:13:40.000Z</published>
    <updated>2019-06-04T14:30:20.748Z</updated>
    
    <content type="html"><![CDATA[<p>因为一直想去南方的城市。所以我决定离开恒生去深圳发展，于是在2018年3月份的时候开始计划准备离职，那时候我还在北京。当时已经跟我的主管老大提出离职的意向。离职的流程大概要走一个月左右，在这一个月的时间内，我开始准备一些面试的东西，主要还是java基础这一块。所以从那个时候起，我开始写一些笔记，然后参加一些面试，主要是想通过这种方式，来增加自己的面试经验,了解自己有哪些不足的地方。然后当时恒生也在招人，所以就跟着几个老同事一起面了几个开发。在这里记录一下，我从2018年4月份至2018年5月份，这一个多月的时间里，参加过的所有面试经历，还有碰到的一些的面试题以及我个人对面试这件事情的看法和总结。</p><a id="more"></a><h2 id="先锋支付"><a href="#先锋支付" class="headerlink" title="先锋支付"></a>先锋支付</h2><p><strong>面试流程</strong><br>先锋支付的面试流程是先参加笔试，笔试之后紧接着参加面试。这也是大多数公司都会采用的一种面试流程。当然也有很多公司追求效率直接让你参加面试。<br><strong>笔试和面试题</strong></p><ol><li><p>内连接，左连接，全连接之间的区别。</p></li><li><p>chmod 给文件授权和find命令的使用</p></li><li><p>如何在数据库每一秒钟都有数据写入的时候进行拆表。</p></li><li><p>spring scope？</p><p>这个问题经常遇到，我在目前工作的这家公司笔试的时候也遇到过。</p></li><li><p>spring动态代理 实现方式和配置</p></li><li><p>java的几种加密方式</p></li><li><p>定时任务的实现方式</p></li><li><p>final,finally,finalize这三者之间的区别。</p></li><li><p>策略模式，命令模式与模板模式之间的区别。</p></li></ol><h2 id="灵狮区块链"><a href="#灵狮区块链" class="headerlink" title="灵狮区块链"></a>灵狮区块链</h2><p><strong>面试流程</strong><br>这家公司是约的电话面试。面试官人很好，面试问到的内容，基本上都是关于java基础然后跟面试官聊的也比较久，双方对彼此都有一个比较好的了解。<br><strong>面试题</strong></p><ol><li><p>java内存模型，堆内存和栈内存的区别。</p></li><li><p>spring aop使用了什么设计模式? 关于spring aop的考察也是会经常遇到的问题。主要需要了解的就是spring aop的实现方式，它是通过动态代理实现的，然后面试官又会扩展的问道，动态代理有几种实现方式？</p></li><li><p>socket网络编程</p></li><li><p>如何实现线程之间的通信。</p><p>这里主要是看一下juc包的源码</p></li><li><p>hashmap的数据结构，以及实现方式。</p><p>关于这一块，我有写过它的源码分析文章。</p></li><li><p>mongodb与传统数据库有什么区别？</p><p>以及mangodb常用的命令这个问题我也遇到过很多次其实问的都不难，是一些比较基础的东西。</p></li><li><p>关于jpa的了解。</p><p>其实这里暴露了我的一个问题。我当时不知道jpa是啥。包括在后来的面试中，一个面试官问我关于orm的理解。其实我也不太清楚，orm是什么东西。所以在面试的时候，关于这些特别基础的常识性的东西，还是需要了解清楚。否则答不上来的话，会让人觉得你比较业余。而我当时，只顾着复习java基础的东西，关于框架这一块学习的不多。之前在公司，都是使用现成的框架，也没有去折腾过jpa，orm</p></li><li><p>查询sql语句优化。关于sq优化的问题我在很多面试中都遇到过。  </p></li><li><p>左连接，右连接，与内连接之间的区别？</p><p>这个问题我在之前的面试中就已经遇到过。</p></li><li><p>平时喜欢钻研的技术？</p><p>这个问题其实在很多公司面试的时候都会问到。很多面试官其实就是项目组的技术负责人，然后他们会考察你作为一个开发人员对于技术的热情。所以这个时候，如果你有写过一些，技术博客，或者看过一些源码，或者直接把github账号展现给面试官看的话，会是一个优势。</p></li></ol><h2 id="嘉联支付"><a href="#嘉联支付" class="headerlink" title="嘉联支付"></a>嘉联支付</h2><p><strong>面试流程</strong><br>嘉联支付的面试流程是先笔试，然后紧接着跟技术负责人聊。<br><strong>笔试和面试题</strong></p><ol><li><p>mybatis分页实现。</p><p>这个我之前在恒生的时候已经看过mybatis分页的源代码。这一块主要是通过分页插件拦截器实现的。</p></li><li><p>springaop原理。</p><p>这个问题我在上面遇到过。</p></li><li><p>对spring mvc和severlet的了解。</p><p>关于spring mvc这一块的东西在面试中还是会经常遇到的。因为我之前一直是做后台的开发，所以对前台mvc的东西了解的不多。去找工作面试的话，还是应该要全面一点，至少要了解一些常用的东西。要做到你知道这是一个什么东西，即使你不精通，但是哪怕你写过一个简单的demo。也比直接说，我不知道要强。</p></li><li><p>单例模式手写。</p><p>嘉联支付的笔试要求手写出单例模式。当时我并没有完整的写出来。程序里面忘了加static关键字。</p></li><li><p>zk分布式锁的实现。</p></li><li><p>sql去重有哪些方法。</p></li></ol><h2 id="软通动力"><a href="#软通动力" class="headerlink" title="软通动力"></a>软通动力</h2><p><strong>面试流程</strong><br>软通动力的面试也是先笔试再面试的形式。但是软通动力的面试官真的很不专业。所以不建议大家以后去这种，外包公司去面试，其实对于你刷面试经验并没有太大的帮助。因为你极有可能碰到的是一个非常不靠谱的面试官，他不懂得怎么面试。</p><p><strong>笔试和面试题</strong> </p><ol><li><p>说一下nginx如何部署。</p><p>这个我不会，没答上来。</p></li><li><p>为什么选用mongodb。</p><p>这个问题我当时直接说了一下mangodb，它解决了我们哪些业务场景的问题</p></li><li><p>查看数据库表用户命令。</p><p>这个问题我也没有答上来。</p></li><li><p>说一下spring MVC</p></li><li><p>说一下serverlet</p></li><li><p>说一下java这门语言</p><p>当面试官问出这些问题的时候，我其实是比较反感的。首先，面试一定是面试者和公司双方之间的交流。并不是单纯的面试官问面试者问题。所以，对于面试者来说，在一场面试中，他需要从面试官那里充分了解这个公司。所以经常有一些面试官会问，你有些什么想要从我这里获知的。对于面试官来说，他想要知道的是，面试者是否达到了自己这个岗位的要求。</p><p>因此当面试官问我怎么看java这门语言的时候。我觉得这种问题除了让面试官秀自己的优越感以外，其他毫无意义。即使我这个问题回答的再好，也并不能体现我开发技能有多好，最多只能体现出我对java这门语言的理解水平。</p></li></ol><ol start="7"><li><p>说一下java并发和多线程。</p><p>在回答这一题的时候，我直接说出了一种最简单的实现方式。后来我反思了一下，觉得我说得并不好，因为其实面试官肯定知道这种简单的东西，他希望的是你要答出他的痛点。你需要讲出多线程并发编程的时候，哪些需要注意的事项。这个也是我后来跟一个猎头朋友，还有一个技术负责人聊天的时候，他们给我的一点提示，对我的帮助还是很大的。</p></li></ol><p><strong>关于软通动力面试后的总结</strong><br>在经过了软通动力的面试之后，我自己反思了一下在这场面试中有哪些不足的地方？最后我得到的收获是，第一点对于自己原本就，不是太有兴趣的公司，应该直接不去面试，否则其实是浪费自己的时间。本来我是想通过面试来刷一下自己的面试经验。但是后来我发现，会经常碰到一些不太靠谱的面试官。就像软通动力的这个面试官一样，甚至我答完了面试官的问题之后，我还没有来得及问他一些关于公司的事情，他就直接让我在那里等结果。结果等了一个小时也没有结果。非常不尊重面试者。所以从那之后，任何外包公司的面试我一律不去。<br>第二点是，我没有回答好面试官的说一下XXX系列问题，其实这种问题很难回答，你可以往简单的说，也可以往复杂了说。而且因为这个问题不具体，你不知道面试官的痛点在哪里，很难把这个问题回答的很好。有水平的面试官，他会根据你说出的答案，不断的进行深挖。这样才能体现出你对一个技术点，了解的深度。然而在像软通动力这种外包公司里他们并不注重技术，所以他们的面试官，也不太会注重深挖你的技术。这也是我不建议大家去外包公司面试的原因。因为你有很大的概率会遇到这种麻瓜面试官。</p><h2 id="赢时胜"><a href="#赢时胜" class="headerlink" title="赢时胜"></a>赢时胜</h2><p><strong>面试流程</strong><br>赢时胜的面试流程也是先笔试再面试。<br><strong>面试过程</strong><br>面试官没有问太多技术性的问题，主要是针对笔试题问了些简单的问题，大多数时间聊的还是业务上的事情。因为我之前做的是银行的开发，刚好跟他们的一个现有的项目对口。所以后来赢时胜还是给我发了offer。但是这些大公司都会压你的工资。他们根据工作经验划分出不同的薪资水平，然后根据面试者的面试情况，压低面试者的薪资。他们的这种做法让我觉得很不喜欢，所以虽然后来拿了offer，但是也不是我期望的薪资，当时作为一个保底就先接受了。<br>这里也说一下关于，期望薪资的问题。我之前刷面试经验的时候会去面很多做外包的小公司，然后这些公司出于人力成本的考虑，本来就不会给岗位开出很高的薪资，但是他们会在，招聘信息上把薪资上限的很高。比如三年工作经验以内，给的薪资水平是9k到18k这种。其实他们真正能跟岗位开出的工资也就是9k左右，即使你面试的情况再好，也不可能到18k。当我带着13k期望薪资去面试他们这种岗位的时候，面试官看到你的期望薪资，其实就已经觉得你不太合适了。然后如果他们觉得你的面试情况好的话，肯定会压低你的薪资。</p><h2 id="木槿科技"><a href="#木槿科技" class="headerlink" title="木槿科技"></a>木槿科技</h2><p><strong>面试流程</strong><br>木槿科技的面试时先HR面，人力会跟你大体上聊一些离职原因，之前负责的工作，期望薪资这些。然后是技术负责人面试，他们没有笔试环节。<br><strong>面试题</strong></p><ol><li><p>你对ORM的了解</p><p>这里就再次丢脸了，没答出来</p></li><li><p>zk如何实现分布式锁</p><p>这个问题也是之前遇到过的</p></li><li><p>简述Jdbc的编程过程</p><p>这个我之前一直没有自己写过，都是通过使用Mybatis框架来做的这个事情。</p></li><li><p>Redis的几种数据结构</p></li><li><p>Hash型数据存储的基本使用命令</p><p>这个我之前看过这些简单的命令，但是当时忘了也没答上来。</p></li></ol><p><strong>木槿科技面试总结</strong></p><p>在面试木槿的时候遇到过几次很基础，很简单的问题没有答出来。而在这之前我准备的面试方向都是Java基础比较深入的应用。面试了这几家公司发现他们大多数其实问的内容都很简单，根本不会涉及到很深的原理性问题，也不会深挖技术细节。而很多很简单的概念其实我不是很清楚，之前也没关注过这些，所以导致了我很受挫，在面试的时候这种问题答不出来显得很业余。</p><h2 id="华锐金融"><a href="#华锐金融" class="headerlink" title="华锐金融"></a>华锐金融</h2><p><strong>面试流程</strong><br>华锐的面试也是采用先笔试后面试的方式进行<br><strong>面试和笔试题</strong></p><ol><li><p>一个文件里面包含很多个乱序不重复的电话号码，需要在20兆内存的空间内，将这些电话号码进行排序，并重新输出到另一个文件内。</p><p>这一题我没有做出来。</p></li><li><p>java内存模型中，堆内存和栈内存的区别。</p></li><li><p>垃圾回收算法</p></li><li><p>如何复制一个对内存中的对象？</p></li></ol><p><strong>华锐面试的总结</strong><br>其实一开始我笔试题做得并不好，技术面之后，我一度以为自己已经挂了。没想到后来人力资源，和面试官一起讨论了一下，觉得我还可以。紧接着后来就是人力资源给我介绍一下这家公司详细情况。介绍完之后，立马就进行了ceo面。跟ceo聊的很好，然后也了解了这个公司的团队情况，觉得非常厉害，也是我期望的那种工作团队。从面试体验也可以看出来，整个公司团队的，效率和执行力是非常高的。CEO非常尊重工程师，面试结束之后，亲自把我送到了电梯门口。面试是当天上午十点开始的，等结束的时候，快下午1点了。后来我回到家里，下午两三点的时候，人力给我发来录用通知，开出的薪资条件，远远超过了我的期望。可以看出来他们非常的有诚意，也非常尊重工程师文化。通过华锐的面试，给我的感觉是，运气也非常的重要。所以在找工作面试的时候，不要因为，有几家面试失败了，就轻易的看低自己，一定要坚持下去，尽量去一家你想去的公司。如果这家公司从一开始就压榨你的薪资的话，也不用指望你入职之后能有多大的改善</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为一直想去南方的城市。所以我决定离开恒生去深圳发展，于是在2018年3月份的时候开始计划准备离职，那时候我还在北京。当时已经跟我的主管老大提出离职的意向。离职的流程大概要走一个月左右，在这一个月的时间内，我开始准备一些面试的东西，主要还是java基础这一块。所以从那个时候起，我开始写一些笔记，然后参加一些面试，主要是想通过这种方式，来增加自己的面试经验,了解自己有哪些不足的地方。然后当时恒生也在招人，所以就跟着几个老同事一起面了几个开发。在这里记录一下，我从2018年4月份至2018年5月份，这一个多月的时间里，参加过的所有面试经历，还有碰到的一些的面试题以及我个人对面试这件事情的看法和总结。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试总结" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>老无所依</title>
    <link href="http://yoursite.com/2018/05/27/%E8%80%81%E6%97%A0%E6%89%80%E4%BE%9D/"/>
    <id>http://yoursite.com/2018/05/27/老无所依/</id>
    <published>2018-05-27T11:40:59.000Z</published>
    <updated>2019-06-04T14:30:20.832Z</updated>
    
    <content type="html"><![CDATA[<p>天一给我推荐的科恩兄弟系列，反派发型很萌，又很聪明，演员是西班牙人，叫哈维尔巴登。把反派演的很有魅力，天一称之为影史上最难忘的反派之一，其实在我心里最好的反派依旧是小丑。</p><p><img src="/2018/05/27/老无所依/p551171670.jpg" alt="海报看起来有点恐怖，但其实跟恐怖惊悚都没关系，你看我都敢看~"></p><a id="more"></a><p><img src="/2018/05/27/老无所依/p1196957913.jpg" alt=""></p><p>一直没看懂为什么片名叫老无所依，但是很喜欢这张海报</p><p><img src="/2018/05/27/老无所依/p1303044912.jpg" alt=""></p><p>向来很喜欢红色，这张海报简直大爱</p><p><img src="/2018/05/27/老无所依/p1424911515.jpg" alt=""></p><p>看完电影你就知道为什么我要放这张图了，设计的很棒</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天一给我推荐的科恩兄弟系列，反派发型很萌，又很聪明，演员是西班牙人，叫哈维尔巴登。把反派演的很有魅力，天一称之为影史上最难忘的反派之一，其实在我心里最好的反派依旧是小丑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/05/27/老无所依/p551171670.jpg&quot; alt=&quot;海报看起来有点恐怖，但其实跟恐怖惊悚都没关系，你看我都敢看~&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="电影" scheme="http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="科恩兄弟" scheme="http://yoursite.com/tags/%E7%A7%91%E6%81%A9%E5%85%84%E5%BC%9F/"/>
    
  </entry>
  
</feed>
